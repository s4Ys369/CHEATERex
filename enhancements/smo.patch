diff --git a/Makefile b/Makefile
index aa9c3d7..1c9f477 100644
--- a/Makefile
+++ b/Makefile
@@ -299,6 +299,9 @@ ULTRA_BIN_DIRS := lib/bin
 
 GODDARD_SRC_DIRS := src/goddard src/goddard/dynlists
 
+# SMO Stuff
+SRC_DIRS += data/smo data/smo/system data/smo/object data/smo/mario data/smo/cappy data/smo/capture data/smo/debug
+
 MIPSISET := -mips2
 MIPSBIT := -32
 
@@ -554,6 +557,12 @@ endif
 
 # Check for enhancement options
 
+# Debug
+ifeq ($(DEBUG),1)
+  CC_CHECK += -DDEBUG
+  CFLAGS += -DDEBUG
+endif
+
 # Check for Puppycam option
 ifeq ($(BETTERCAMERA),1)
   CC_CHECK += -DBETTERCAMERA
diff --git a/data/behavior_data.c b/data/behavior_data.c
index d27cf09..807bf9a 100644
--- a/data/behavior_data.c
+++ b/data/behavior_data.c
@@ -3989,7 +3989,7 @@ const BehaviorScript bhvExplosion[] = {
     SET_INTERACT_TYPE(INTERACT_DAMAGE),
     SET_INT(oDamageOrCoinValue, 2),
     SET_INT(oIntangibleTimer, 0),
-    SET_HITBOX_WITH_OFFSET(/*Radius*/ 150, /*Height*/ 150, /*Downwards offset*/ 150),
+    SET_HITBOX_WITH_OFFSET(/*Radius*/ 150, /*Height*/ 150, /*Downwards offset*/ 0), /* <-- Bobomb explosion fix */
     SET_INT(oAnimState, -1),
     CALL_NATIVE(bhv_explosion_init),
     BEGIN_LOOP(),
diff --git a/data/smo/cappy/smo_cappy_bhv1.c b/data/smo/cappy/smo_cappy_bhv1.c
new file mode 100644
index 0000000..b7d9bd4
--- /dev/null
+++ b/data/smo/cappy/smo_cappy_bhv1.c
@@ -0,0 +1,120 @@
+#include "smo_cappy_common.inl"
+
+//
+// Init
+//
+
+static const f32 sCappyMovStraightLineParams[][5] = {
+    { CAPPY_DELTA_VEL,             0.f, 0, 1, 50 },
+    { CAPPY_DELTA_VEL,             0.f, 0, 1, 50 },
+    { CAPPY_DELTA_VEL, CAPPY_DELTA_VEL, 1, 1,  0 },
+    { CAPPY_DELTA_VEL,             0.f, 0, 1, 50 },
+};
+
+void cappy_bhv1_init(struct Object *cappy, struct MarioState *m) {
+    f32 hVel     = sCappyMovStraightLineParams[m->oCappyActionFlag][0];
+    f32 vVel     = sCappyMovStraightLineParams[m->oCappyActionFlag][1];
+    s16 mPitch   = sCappyMovStraightLineParams[m->oCappyActionFlag][2] * m->faceAngle[0];
+    s16 mYaw     = sCappyMovStraightLineParams[m->oCappyActionFlag][3] * m->faceAngle[1];
+    f32 yOffset  = sCappyMovStraightLineParams[m->oCappyActionFlag][4];
+
+    cappy->oPosX = m->pos[0];
+    cappy->oPosY = m->pos[1] + yOffset;
+    cappy->oPosZ = m->pos[2];
+    cappy->oVelX = coss(mPitch) * sins(mYaw) * hVel;
+    cappy->oVelY = sins(mPitch) * vVel;
+    cappy->oVelZ = coss(mPitch) * coss(mYaw) * hVel;
+}
+
+//
+// Movement
+//
+
+static void cappy_bhv1_stop(struct Object *cappy, f32 x, f32 y, f32 z) {
+    cappy->oPosX = x;
+    cappy->oPosY = y;
+    cappy->oPosZ = z;
+    cappy->oVelX = 0;
+    cappy->oVelY = 0;
+    cappy->oVelZ = 0;
+}
+
+#define STEPS 8
+static void cappy_bhv1_move(struct Object *cappy, struct MarioState *m) {
+    m->oCappyWallObject  = NULL;
+    m->oCappyFloorObject = NULL;
+    m->oCappyCeilObject  = NULL;
+
+    for (s32 i = 0; i != STEPS; ++i) {
+        f32 x = cappy->oPosX;
+        f32 y = cappy->oPosY;
+        f32 z = cappy->oPosZ;
+        cappy->oPosX += (cappy->oVelX / STEPS);
+        cappy->oPosY += (cappy->oVelY / STEPS);
+        cappy->oPosZ += (cappy->oVelZ / STEPS);
+
+        // Walls
+        struct WallCollisionData hitbox;
+        hitbox.x = cappy->oPosX;
+        hitbox.y = cappy->oPosY;
+        hitbox.z = cappy->oPosZ;
+        hitbox.offsetY = cappy->hitboxHeight / 2;
+        hitbox.radius = cappy->oWallHitboxRadius;
+        if (find_wall_collisions(&hitbox) != 0) {
+            cappy_register_wall_object(cappy, m, hitbox.walls[0]->object);
+            cappy_bhv1_stop(cappy, hitbox.x, hitbox.y, hitbox.z);
+            break;
+        }
+
+        // Floor
+        struct Surface *floor = NULL;
+        f32 floorY = find_floor(cappy->oPosX, cappy->oPosY, cappy->oPosZ, &floor);
+        if (floor != NULL) {
+            f32 diffY = cappy->oPosY - floorY;
+            if (diffY < 0) {
+                cappy_register_floor_object(cappy, m, floor->object);
+                if (floor->normal.y < 0.707f) { // ~45 deg
+                    cappy_bhv1_stop(cappy, x, y, z);
+                    break;
+                } else {
+                    cappy->oPosY = floorY;
+                    cappy->oVelY = 0;
+                }
+            }
+        } else {
+            cappy_bhv1_stop(cappy, x, y, z);
+            break;
+        }
+
+        // Ceiling
+        struct Surface *ceil = NULL;
+        f32 ceilY = find_ceil(cappy->oPosX, cappy->oPosY, cappy->oPosZ, &ceil);
+        if (ceil != NULL) {
+            f32 h = (cappy->hitboxHeight - cappy->hitboxDownOffset);
+            if (cappy->oPosY <= ceilY && cappy->oPosY + h > ceilY) {
+                cappy_register_ceiling_object(cappy, m, ceil->object);
+                if (ceil->normal.y > -0.707f) { // ~45 deg
+                    cappy_bhv1_stop(cappy, x, y, z);
+                    break;
+                } else {
+                    cappy->oPosY = MAX(ceilY - h, floorY);
+                    cappy->oVelY = 0;
+                }
+            }
+        }
+    }
+}
+#undef STEPS
+
+//
+// Update
+//
+
+void cappy_bhv1_update(struct Object *cappy, struct MarioState *m) {
+    if (cappy->oTimer < 12) {
+        m->oCappyInteractMario = FALSE;
+        cappy_bhv1_move(cappy, m);
+    } else {
+        m->oCappyInteractMario = TRUE;
+    }
+}
diff --git a/data/smo/cappy/smo_cappy_bhv2.c b/data/smo/cappy/smo_cappy_bhv2.c
new file mode 100644
index 0000000..87afd23
--- /dev/null
+++ b/data/smo/cappy/smo_cappy_bhv2.c
@@ -0,0 +1,102 @@
+#include "smo_cappy_common.inl"
+
+//
+// Init
+//
+
+void cappy_bhv2_init(struct Object *cappy, struct MarioState *m) {
+    cappy->oPosX = m->pos[0];
+    cappy->oPosY = m->pos[1] + 60;
+    cappy->oPosZ = m->pos[2];
+    cappy->oFaceAngleYaw = m->faceAngle[1];
+}
+
+//
+// Movement
+//
+
+#define STEPS 16
+static void cappy_bhv2_move(struct Object *cappy, struct MarioState *m) {
+    f32 radius = MIN(cappy->oTimer * 16.f, 240.f);
+    s16 angle = (s16)(cappy->oFaceAngleYaw + (s32)(cappy->oTimer) * 0x0C00);
+    f32 dx = radius * coss(angle);
+    f32 dz = radius * sins(angle);
+    cappy->oPosX = m->pos[0];
+    cappy->oPosY = m->pos[1] + 60;
+    cappy->oPosZ = m->pos[2];
+
+    for (s32 i = 0; i != STEPS; ++i) {
+        f32 x = cappy->oPosX;
+        f32 y = cappy->oPosY;
+        f32 z = cappy->oPosZ;
+        cappy->oPosX += (dx / STEPS);
+        cappy->oPosZ += (dz / STEPS);
+
+        // Walls
+        struct WallCollisionData hitbox;
+        hitbox.x = cappy->oPosX;
+        hitbox.y = cappy->oPosY;
+        hitbox.z = cappy->oPosZ;
+        hitbox.offsetY = cappy->hitboxHeight / 2;
+        hitbox.radius = cappy->oWallHitboxRadius;
+        if (find_wall_collisions(&hitbox) != 0) {
+            cappy_register_wall_object(cappy, m, hitbox.walls[0]->object);
+            cappy->oPosX = hitbox.x;
+            cappy->oPosY = hitbox.y;
+            cappy->oPosZ = hitbox.z;
+            break;
+        }
+
+        // Floor
+        struct Surface *floor = NULL;
+        f32 floorY = find_floor(cappy->oPosX, cappy->oPosY, cappy->oPosZ, &floor);
+        if (floor != NULL) {
+            f32 diffY = cappy->oPosY - floorY;
+            if (diffY < 0) {
+                cappy_register_floor_object(cappy, m, floor->object);
+                if (floor->normal.y < 0.707f) { // ~45 deg
+                    cappy->oPosX = x;
+                    cappy->oPosY = y;
+                    cappy->oPosZ = z;
+                    break;
+                } else {
+                    cappy->oPosY = floorY;
+                }
+            }
+        } else {
+            cappy->oPosX = x;
+            cappy->oPosY = y;
+            cappy->oPosZ = z;
+            break;
+        }
+
+        // Ceiling
+        struct Surface *ceil = NULL;
+        f32 ceilY = find_ceil(cappy->oPosX, cappy->oPosY, cappy->oPosZ, &ceil);
+        if (ceil != NULL) {
+            f32 h = (cappy->hitboxHeight - cappy->hitboxDownOffset);
+            if (cappy->oPosY <= ceilY && cappy->oPosY + h > ceilY) {
+                cappy_register_ceiling_object(cappy, m, ceil->object);
+                if (ceil->normal.y > -0.707f) { // ~45 deg
+                    cappy->oPosX = x;
+                    cappy->oPosY = y;
+                    cappy->oPosZ = z;
+                    break;
+                } else {
+                    cappy->oPosY = MAX(ceilY - h, floorY);
+                }
+            }
+        }
+    }
+}
+#undef STEPS
+
+//
+// Update
+//
+
+void cappy_bhv2_update(struct Object *cappy, struct MarioState *m) {
+    m->oCappyInteractMario = FALSE;
+    cappy_bhv2_move(cappy, m);
+}
+
diff --git a/data/smo/cappy/smo_cappy_bhv3.c b/data/smo/cappy/smo_cappy_bhv3.c
new file mode 100644
index 0000000..8fb7f37
--- /dev/null
+++ b/data/smo/cappy/smo_cappy_bhv3.c
@@ -0,0 +1,109 @@
+#include "smo_cappy_common.inl"
+
+//
+// Init
+//
+
+void cappy_bhv3_init(struct Object *cappy, struct MarioState *m) {
+    cappy->oPosX = m->pos[0];
+    cappy->oPosY = m->pos[1] + 30;
+    cappy->oPosZ = m->pos[2];
+    cappy->oFaceAngleYaw = m->faceAngle[1];
+}
+
+//
+// Movement
+//
+
+#define STEPS 16
+static void cappy_bhv3_move(struct Object *cappy, struct MarioState *m) {
+    f32 radius = MIN(cappy->oTimer * 12.f, 180.f);
+    s16 angle = (s16)(cappy->oFaceAngleYaw + (s32)(cappy->oTimer) * 0x0C00);
+    Vec3f v = { radius * coss(angle), radius * sins(angle), 0 };
+    vec3f_rotate_zxy(v, -m->faceAngle[0], m->faceAngle[1], 0);
+    cappy->oPosX = m->pos[0];
+    cappy->oPosY = m->pos[1] + 30;
+    cappy->oPosZ = m->pos[2];
+
+    for (s32 i = 0; i != STEPS; ++i) {
+        f32 x = cappy->oPosX;
+        f32 y = cappy->oPosY;
+        f32 z = cappy->oPosZ;
+        cappy->oPosX += (v[0] / STEPS);
+        cappy->oPosY += (v[1] / STEPS);
+        cappy->oPosZ += (v[2] / STEPS);
+
+        // Walls
+        struct WallCollisionData hitbox;
+        hitbox.x = cappy->oPosX;
+        hitbox.y = cappy->oPosY;
+        hitbox.z = cappy->oPosZ;
+        hitbox.offsetY = cappy->hitboxHeight / 2;
+        hitbox.radius = cappy->oWallHitboxRadius;
+        if (find_wall_collisions(&hitbox) != 0) {
+            cappy_register_wall_object(cappy, m, hitbox.walls[0]->object);
+            cappy->oPosX = hitbox.x;
+            cappy->oPosY = hitbox.y;
+            cappy->oPosZ = hitbox.z;
+            break;
+        }
+
+        // Floor
+        struct Surface *floor = NULL;
+        f32 floorY = find_floor(cappy->oPosX, cappy->oPosY, cappy->oPosZ, &floor);
+        if (floor != NULL) {
+            f32 diffY = cappy->oPosY - floorY;
+            if (diffY < 0) {
+                cappy_register_floor_object(cappy, m, floor->object);
+                if (floor->normal.y < 0.707f) { // ~45 deg
+                    cappy->oPosX = x;
+                    cappy->oPosY = y;
+                    cappy->oPosZ = z;
+                    break;
+                } else {
+                    cappy->oPosY = floorY;
+                }
+            }
+        } else {
+            cappy->oPosX = x;
+            cappy->oPosY = y;
+            cappy->oPosZ = z;
+            break;
+        }
+
+        // Ceiling
+        struct Surface *ceil = NULL;
+        f32 ceilY = find_ceil(cappy->oPosX, cappy->oPosY, cappy->oPosZ, &ceil);
+        if (ceil != NULL) {
+            f32 h = (cappy->hitboxHeight - cappy->hitboxDownOffset);
+            if (cappy->oPosY <= ceilY && cappy->oPosY + h > ceilY) {
+                cappy_register_ceiling_object(cappy, m, ceil->object);
+                if (ceil->normal.y > -0.707f) { // ~45 deg
+                    cappy->oPosX = x;
+                    cappy->oPosY = y;
+                    cappy->oPosZ = z;
+                    break;
+                } else {
+                    cappy->oPosY = MAX(ceilY - h, floorY);
+                }
+            }
+        }
+    }
+}
+#undef STEPS
+
+//
+// Update
+//
+
+void cappy_bhv3_update(struct Object *cappy, struct MarioState *m) {
+    m->oCappyInteractMario = FALSE;
+    if (m->action != ACT_FLYING) {
+        cappy_start_return_to_mario(cappy);
+    } else {
+        if (cappy->oTimer < 12) {
+            m->marioObj->header.gfx.angle[2] += ((cappy->oTimer * 65536) / 12);
+        }
+        cappy_bhv3_move(cappy, m);
+    }
+}
diff --git a/data/smo/cappy/smo_cappy_collision.inl b/data/smo/cappy/smo_cappy_collision.inl
new file mode 100644
index 0000000..97eb01e
--- /dev/null
+++ b/data/smo/cappy/smo_cappy_collision.inl
@@ -0,0 +1,313 @@
+#include "../smo_c_includes.h"
+
+//
+// List of enemies attackable by Cappy (behaviors)
+//
+
+static const BehaviorScript* sAttackableBehaviors[] = {
+    bhvPiranhaPlant,
+    bhvBoo,
+    bhvBooInCastle,
+    bhvBooWithCage,
+    bhvBalconyBigBoo,
+    bhvMerryGoRoundBigBoo,
+    bhvGhostHuntBigBoo,
+    bhvMerryGoRoundBoo,
+    bhvGhostHuntBoo,
+    bhvHauntedBookshelf,
+    bhvScuttlebug,
+    bhvMoneybag,
+    bhvMoneybagHidden,
+    bhvKoopa,
+    bhvPokey,
+    bhvPokeyBodyPart,
+    bhvSwoop,
+    bhvFlyGuy,
+    bhvGoomba,
+    bhvEnemyLakitu,
+    bhvSpiny,
+    bhvMontyMole,
+    bhvFlyingBookend,
+    bhvFirePiranhaPlant,
+    bhvSnufit,
+    bhvKlepto,
+    bhvSkeeter,
+    bhvSmallBully,
+    bhvBigBully,
+    bhvBigBullyWithMinions,
+    bhvSmallChillBully,
+    bhvBigChillBully,
+    bhvSpindrift
+};
+static const u32 sAttackableCount = sizeof(sAttackableBehaviors) / sizeof(const BehaviorScript*);
+
+//
+// Bullies
+//
+
+static const BehaviorScript* sBullyBehaviors[] = {
+    bhvSmallBully,
+    bhvBigBully,
+    bhvBigBullyWithMinions,
+    bhvSmallChillBully,
+    bhvBigChillBully
+};
+static const u32 sBullyCount = sizeof(sBullyBehaviors) / sizeof(const BehaviorScript*);
+
+//
+// Collision handler
+//
+
+static s32 cappy_detect_hitbox_overlap(struct Object *cappy, struct Object *obj) {
+    if (obj->hitboxRadius == 0 || obj->hitboxHeight == 0) {
+        return FALSE;
+    }
+
+    // Radius check
+    f32 dx = cappy->oPosX - obj->oPosX;
+    f32 dz = cappy->oPosZ - obj->oPosZ;
+    f32 collisionRadius2 = (cappy->hitboxRadius + obj->hitboxRadius) * (cappy->hitboxRadius + obj->hitboxRadius);
+    f32 distance2 = (dx * dx + dz * dz);
+    if (distance2 > collisionRadius2) {
+        return FALSE;
+    }
+
+    // Height check
+    f32 capLowerBound = cappy->oPosY - cappy->hitboxDownOffset;
+    f32 capUpperBound = cappy->hitboxHeight + capLowerBound;
+    f32 objLowerBound = obj->oPosY - obj->hitboxDownOffset;
+    f32 objUpperBound = obj->hitboxHeight + objLowerBound;
+    f32 sumOfHeights = cappy->hitboxHeight + obj->hitboxHeight;
+    if (((objUpperBound - capLowerBound) > sumOfHeights) ||
+        ((capUpperBound - objLowerBound) > sumOfHeights)) {
+        return FALSE;
+    }
+
+    return TRUE;
+}
+
+static s32 is_coin_or_secret(struct Object *obj) {
+
+    // Coin
+    if (obj->oInteractType & INTERACT_COIN) {
+        return TRUE;
+    }
+
+    // Star secret
+    if (obj->behavior == bhvHiddenStarTrigger) {
+        return TRUE;
+    }
+
+    return FALSE;
+}
+
+static s32 is_grabbable(struct Object *obj) {
+
+    // Not Bowser
+    if (obj->behavior == bhvBowser) {
+        return FALSE;
+    }
+
+    // Not that @#%! hat stealer ukiki
+    if (obj->behavior == bhvUkiki && obj->oBehParams2ndByte == UKIKI_HAT) {
+        return FALSE;
+    }
+    if (obj->behavior == bhvMacroUkiki && obj->oBehParams2ndByte == UKIKI_HAT) {
+        return FALSE;
+    }
+
+    // Not Heave ho
+    if (obj->oInteractionSubtype & INT_SUBTYPE_NOT_GRABBABLE) {
+        return FALSE;
+    }
+
+    // Grabbable
+    if (obj->oInteractType & INTERACT_GRABBABLE) {
+        return TRUE;
+    }
+
+    return FALSE;
+}
+
+static s32 is_attackable(struct Object *obj) {
+    for (u32 i = 0; i != sAttackableCount; ++i) {
+        if (obj->behavior == sAttackableBehaviors[i]) {
+            return TRUE;
+        }
+    }
+    return FALSE;
+}
+
+static s32 is_bully(struct Object *obj) {
+    for (u32 i = 0; i != sBullyCount; ++i) {
+        if (obj->behavior == sBullyBehaviors[i]) {
+            return TRUE;
+        }
+    }
+    return FALSE;
+}
+
+static s32 cappy_give_collectible_to_mario(UNUSED struct Object *cappy, struct MarioState *m, struct Object *obj) {
+
+    // Teleports collectible directly to Mario
+    // The object is then collected on the very next frame
+    obj->oPosX = m->marioObj->oPosX;
+    obj->oPosY = m->marioObj->oPosY + 80;
+    obj->oPosZ = m->marioObj->oPosZ;
+    return TRUE;
+}
+
+static s32 cappy_try_to_grab_object(struct Object *cappy, struct MarioState *m, struct Object *obj) {
+
+    // Even if an object is grabbable by Cappy,
+    // the actual grab is performed only by grounded Mario
+    if (!(m->action & (ACT_FLAG_AIR | ACT_FLAG_SWIMMING | ACT_FLAG_METAL_WATER))) {
+        m->input |= INPUT_INTERACT_OBJ_GRABBABLE;
+        m->interactObj = obj;
+        m->usedObj = obj;
+        m->vel[0] = 0;
+        m->vel[1] = 0;
+        m->vel[2] = 0;
+        set_mario_animation(m, MARIO_ANIM_FIRST_PUNCH);
+        set_mario_action(m, ACT_PICKING_UP, 0);
+        cappy_start_return_to_mario(cappy);
+        return TRUE;
+    }
+    return FALSE;
+}
+
+static s32 cappy_attack_object(struct Object *cappy, UNUSED struct MarioState *m, struct Object *obj) {
+    
+    // Attack
+    if (is_bully(obj)) {
+        obj->oMoveAngleYaw = atan2s(cappy->oPosZ, cappy->oPosX);
+        obj->oForwardVel = 3392.0f / obj->hitboxRadius;
+    }
+    obj->oInteractStatus = (0x02 | INT_STATUS_INTERACTED | INT_STATUS_WAS_ATTACKED);
+
+    // Return on contact
+    if (m->oCappyBehavior == 1) {
+        spawn_object(cappy, MODEL_NONE, bhvHorStarParticleSpawner);
+        play_sound(SOUND_OBJ_DEFAULT_DEATH, cappy->header.gfx.cameraToObject);
+        cappy_start_return_to_mario(cappy);
+        return TRUE;
+    }
+
+    return FALSE;    
+}
+
+static s32 cappy_process_collision(struct Object *cappy, struct MarioState *m, struct Object *obj) {
+
+    // Collectible
+    if (is_coin_or_secret(obj)) {
+        cappy_give_collectible_to_mario(cappy, m, obj);
+        return FALSE;
+    }
+
+    // Capturable
+    if (mario_possess_object(m, obj)) {
+        mario_unload_cappy(m);
+        return TRUE;
+    }
+
+    // Grabbable
+    if (is_grabbable(obj)) {
+        return cappy_try_to_grab_object(cappy, m, obj);
+    }
+
+    // Attackable
+    if (is_attackable(obj)) {
+        return cappy_attack_object(cappy, m, obj);
+    }
+
+    return FALSE;
+}
+
+static s32 cappy_process_collision_in_list(struct Object *cappy, struct MarioState *m, struct Object *obj, struct ObjectNode *list) {
+    while (obj != NULL) {
+        if (obj != cappy && obj->oIntangibleTimer == 0 &&
+            cappy_detect_hitbox_overlap(cappy, obj) &&
+            cappy_process_collision(cappy, m, obj)) {
+            return TRUE;
+        }
+        obj = obj_get_next(list, obj);
+    }
+    return FALSE;
+}
+
+static s32 check_cappy_interact_with_mario(struct Object *cappy, struct MarioState *m) {
+
+    // Is Cappy tangible for Mario?
+    if (!m->oCappyInteractMario || m->oCappyJumped) {
+        return FALSE;
+    }
+
+    // Intangible/Underwater (non Metal) Mario can't interact with Cappy
+    if (m->action & (ACT_FLAG_INTANGIBLE | ACT_FLAG_INVULNERABLE | ACT_FLAG_SWIMMING)) {
+        return FALSE;
+    }
+
+    // Hitbox overlapping
+    if (!cappy_detect_hitbox_overlap(cappy, m->marioObj)) {
+        return FALSE;
+    }
+
+    // Counts as a Cappy jump only
+    // if Mario is airborne
+    if (m->action & ACT_FLAG_AIR) {
+        if (SMO_UCJ == 0) {
+            m->oCappyJumped = TRUE;
+        }
+    }
+
+    if (m->action & ACT_FLAG_METAL_WATER) {
+        set_mario_action(m, ACT_METAL_WATER_JUMP, 0);
+        m->vel[1] = 32.0f;
+    } else {
+        set_mario_action(m, ACT_SMO_CAPPY_JUMP, 0);
+        mario_set_forward_vel(m, m->forwardVel * 0.8f);
+        m->vel[1] = 56.0f;
+    }
+
+    spawn_object(m->marioObj, MODEL_NONE, bhvHorStarParticleSpawner);
+    play_sound(SOUND_GENERAL_BOING1, m->marioObj->header.gfx.cameraToObject);
+    cappy_start_return_to_mario(cappy);
+    return TRUE;
+}
+
+static void cappy_process_object_collision(struct Object *cappy, struct MarioState *m) {
+    static s8 sObjTypeInteractCappy[] = {
+        OBJ_LIST_SURFACE,
+        OBJ_LIST_POLELIKE,
+        OBJ_LIST_PUSHABLE,
+        OBJ_LIST_GENACTOR,
+        OBJ_LIST_DESTRUCTIVE,
+        OBJ_LIST_LEVEL,
+        -1
+    };
+
+    // Mario
+    if (check_cappy_interact_with_mario(cappy, m)) {
+        return;
+    }
+
+    // Surface objects
+    if (m->oCappyWallObject && cappy_process_collision(cappy, m, m->oCappyWallObject)) {
+        return;
+    }
+    if (m->oCappyFloorObject && cappy_process_collision(cappy, m, m->oCappyFloorObject)) {
+        return;
+    }
+    if (m->oCappyCeilObject && cappy_process_collision(cappy, m, m->oCappyCeilObject)) {
+        return;
+    }
+
+    // Objects
+    s8 *type = sObjTypeInteractCappy;
+    for (; *type != -1; ++type) {
+        struct ObjectNode *list = &gObjectLists[*type];
+        if (cappy_process_collision_in_list(cappy, m, obj_get_first(list), list)) {
+            return;
+        }
+    }
+}
diff --git a/data/smo/cappy/smo_cappy_common.inl b/data/smo/cappy/smo_cappy_common.inl
new file mode 100644
index 0000000..6cdc69d
--- /dev/null
+++ b/data/smo/cappy/smo_cappy_common.inl
@@ -0,0 +1,53 @@
+#include "../smo_c_includes.h"
+
+#define CAPPY_MAX_LIFETIME  120     // 4 seconds
+#define CAPPY_DELTA_VEL     80.f    // max number of units cappy moves per frame
+
+//
+// Return to Mario
+//
+
+inline static void cappy_start_return_to_mario(struct Object *cappy) {
+    cappy->oTimer = CAPPY_MAX_LIFETIME;
+}
+
+inline static s32 cappy_return_to_mario(struct Object *cappy, struct MarioState *m) {
+    f32 dx = m->pos[0] - cappy->oPosX;
+    f32 dy = m->pos[1] - cappy->oPosY + 60;
+    f32 dz = m->pos[2] - cappy->oPosZ;
+    f32 dv = sqrtf(sqr(dx) + sqr(dy) + sqr(dz));
+    if (dv <= cappy->hitboxRadius) {
+        return TRUE;
+    }
+
+    dx /= dv;
+    dy /= dv;
+    dz /= dv;
+    dv = MIN(dv, CAPPY_DELTA_VEL);
+    cappy->oPosX += (dx * dv);
+    cappy->oPosY += (dy * dv);
+    cappy->oPosZ += (dz * dv);
+    return FALSE;
+}
+
+//
+// Register surface objects
+//
+
+inline static void cappy_register_wall_object(UNUSED struct Object *cappy, struct MarioState *m, struct Object *obj) {
+    if (obj != NULL) {
+        m->oCappyWallObject = obj;
+    }
+}
+
+inline static void cappy_register_floor_object(UNUSED struct Object *cappy, struct MarioState *m, struct Object *obj) {
+    if (obj != NULL) {
+        m->oCappyFloorObject = obj;
+    }
+}
+
+inline static void cappy_register_ceiling_object(UNUSED struct Object *cappy, struct MarioState *m, struct Object *obj) {
+    if (obj != NULL) {
+        m->oCappyCeilObject = obj;
+    }
+}
diff --git a/data/smo/cappy/smo_mario_cappy.c b/data/smo/cappy/smo_mario_cappy.c
new file mode 100644
index 0000000..344b429
--- /dev/null
+++ b/data/smo/cappy/smo_mario_cappy.c
@@ -0,0 +1,167 @@
+#include "smo_cappy_common.inl"
+#include "smo_cappy_collision.inl"
+#ifdef SMO_SGI
+#include "sgi/utils/characters.h"
+#endif
+
+//
+// Behavior Script
+//
+
+static const BehaviorScript bhvCappy[] = {
+    0x00060000,
+    0x08000000,
+    0x09000000
+};
+
+static u8 cappy_get_behavior(struct MarioState *m, u8 actFlag) {
+
+    // Flying throw
+    if (actFlag == CAPPY_ACT_FLAG_FLYING) {
+        m->input &= ~(INPUT_A_PRESSED | INPUT_A_DOWN);
+        return 3;
+    }
+
+    // Spin throw
+    if (m->input & INPUT_A_PRESSED) {
+        m->input &= ~(INPUT_A_PRESSED | INPUT_A_DOWN);
+        return 2;
+    }
+
+    // Normal throw
+    return 1;
+}
+
+// 0bWMV
+// bit 0 = Vanish
+// bit 1 = Metal
+// bit 2 = Wing
+static const s32 sMariosCapModel[8] = {
+    MODEL_MARIOS_CAP,               /* 000 - Normal */ 
+    MODEL_MARIOS_CAP,               /* 001 - Vanish */
+    MODEL_MARIOS_METAL_CAP,         /* 010 - Metal */
+    MODEL_MARIOS_METAL_CAP,         /* 011 - Metal/Vanish */
+    MODEL_MARIOS_WING_CAP,          /* 100 - Wing */
+    MODEL_MARIOS_WING_CAP,          /* 101 - Wing/Vanish */
+    MODEL_MARIOS_WINGED_METAL_CAP,  /* 110 - Wing/Metal */
+    MODEL_MARIOS_WINGED_METAL_CAP,  /* 111 - Wing/Metal/Vanish */
+};
+
+#ifdef SMO_SGI
+static const s32 sLuigisCapModel[8] = {
+    MODEL_LUIGIS_CAP,               /* 000 - Normal */
+    MODEL_LUIGIS_CAP,               /* 001 - Vanish */
+    MODEL_LUIGIS_METAL_CAP,         /* 010 - Metal */
+    MODEL_LUIGIS_METAL_CAP,         /* 011 - Metal/Vanish */
+    MODEL_LUIGIS_WING_CAP,          /* 100 - Wing */
+    MODEL_LUIGIS_WING_CAP,          /* 101 - Wing/Vanish */
+    MODEL_LUIGIS_WINGED_METAL_CAP,  /* 110 - Wing/Metal */
+    MODEL_LUIGIS_WINGED_METAL_CAP,  /* 111 - Wing/Metal/Vanish */
+};
+#endif
+
+u32 mario_spawn_cappy(struct MarioState *m, u8 actFlag) {
+
+    // Cappy must be available
+    if (SMO_CAPPY == 0 || !(m->flags & MARIO_CAP_ON_HEAD)) {
+        return 0;
+    }
+
+    // Unspawn Cappy if spawned for more than 30 frames (1 second)
+    struct Object *cappy = m->oCappyObject;
+    if (cappy) {
+        if (cappy->oTimer < 30) {
+            return 0;
+        }
+        obj_mark_for_deletion(cappy);
+    }
+
+    // Spawn Cappy according to the current cap
+    m->oCappyBehavior = cappy_get_behavior(m, actFlag);
+#ifdef SMO_SGI
+    if (getCharacterType() == LUIGI) {
+        cappy = spawn_object(m->marioObj, sLuigisCapModel[(m->flags >> 1) & 0b111], bhvCappy);
+        cappy->header.gfx.scale[0] = LUIGIS_CAPPY_SCALE_MULTIPLIER;
+        cappy->header.gfx.scale[1] = LUIGIS_CAPPY_SCALE_MULTIPLIER;
+        cappy->header.gfx.scale[2] = LUIGIS_CAPPY_SCALE_MULTIPLIER;
+    } else {
+#endif
+        cappy = spawn_object(m->marioObj, sMariosCapModel[(m->flags >> 1) & 0b111], bhvCappy);
+        cappy->header.gfx.scale[0] = 1.f;
+        cappy->header.gfx.scale[1] = 1.f;
+        cappy->header.gfx.scale[2] = 1.f;
+#ifdef SMO_SGI
+    }
+#endif
+    
+    // Init    
+    cappy->hitboxRadius = 80.f;
+    cappy->hitboxHeight = 112.f;
+    cappy->hitboxDownOffset = 32.f;
+    cappy->oWallHitboxRadius = 48.f;
+    m->oCappyObject = cappy;
+    m->oCappyActionFlag = actFlag;
+    m->oCappyInitialized = FALSE;
+    return m->oCappyBehavior;
+}
+
+void mario_update_cappy(struct MarioState *m) {
+    struct Object *cappy = m->oCappyObject;
+    if (cappy) {
+
+        // Check if Mario should have his cap on his head
+        if (!(m->flags & MARIO_CAP_ON_HEAD)) {
+            mario_unload_cappy(m);
+            return;
+        }
+
+        // Init behavior
+        if (!m->oCappyInitialized) {
+            switch (m->oCappyBehavior) {
+                case 1: cappy_bhv1_init(cappy, m); break;
+                case 2: cappy_bhv2_init(cappy, m); break;
+                case 3: cappy_bhv3_init(cappy, m); break;
+            }
+            m->oCappyInitialized = TRUE;
+        }
+
+        // Update behavior
+        if (cappy->oTimer < CAPPY_MAX_LIFETIME) {
+            switch (m->oCappyBehavior) {
+                case 1: cappy_bhv1_update(cappy, m); break;
+                case 2: cappy_bhv2_update(cappy, m); break;
+                case 3: cappy_bhv3_update(cappy, m); break;
+            }
+            cappy_process_object_collision(cappy, m);
+        } else {
+            if (cappy_return_to_mario(cappy, m)) {
+                mario_unload_cappy(m);
+                return;
+            }
+        }
+
+        // Update Gfx
+        if (cappy->activeFlags) {
+            cappy->header.gfx.pos[0] = cappy->oPosX;
+            cappy->header.gfx.pos[1] = cappy->oPosY;
+            cappy->header.gfx.pos[2] = cappy->oPosZ;
+            cappy->header.gfx.angle[0] = 0;
+            cappy->header.gfx.angle[1] += 0x2000;
+            cappy->header.gfx.angle[2] = 0;
+            cappy->oOpacity = ((m->flags & MARIO_VANISH_CAP) ? 0x80 : 0xFF);
+            cappy->activeFlags |= GRAPH_RENDER_ACTIVE;
+            cappy->activeFlags &= ~GRAPH_RENDER_INVISIBLE;
+            spawn_object(cappy, MODEL_NONE, bhvSparkleSpawn);
+
+            // Update Mario's cap state
+            m->marioBodyState->capState = MARIO_HAS_DEFAULT_CAP_OFF;
+        }
+    }
+}
+
+void mario_unload_cappy(struct MarioState *m) {
+    if (m->marioObj->smoData && m->oCappyObject) {
+        obj_mark_for_deletion(m->oCappyObject);
+        m->oCappyObject = NULL;
+    }
+}
\ No newline at end of file
diff --git a/data/smo/cappy/smo_mario_cappy.h b/data/smo/cappy/smo_mario_cappy.h
new file mode 100644
index 0000000..c3933dd
--- /dev/null
+++ b/data/smo/cappy/smo_mario_cappy.h
@@ -0,0 +1,27 @@
+#ifndef SMO_MARIO_CAPPY_H
+#define SMO_MARIO_CAPPY_H
+
+#include "types.h"
+
+enum {
+	CAPPY_ACT_FLAG_GROUND		= 0,
+	CAPPY_ACT_FLAG_AIRBORNE		= 1,
+	CAPPY_ACT_FLAG_WATER		= 2,
+	CAPPY_ACT_FLAG_METAL_WATER	= 3,
+	CAPPY_ACT_FLAG_FLYING		= 4,
+};
+
+/* Cappy */
+u32  mario_spawn_cappy(struct MarioState *m, u8 actFlag);
+void mario_update_cappy(struct MarioState *m);
+void mario_unload_cappy(struct MarioState *m);
+
+/* Behaviors */
+void cappy_bhv1_init(struct Object *cappy, struct MarioState *m);
+void cappy_bhv1_update(struct Object *cappy, struct MarioState *m);
+void cappy_bhv2_init(struct Object *cappy, struct MarioState *m);
+void cappy_bhv2_update(struct Object *cappy, struct MarioState *m);
+void cappy_bhv3_init(struct Object *cappy, struct MarioState *m);
+void cappy_bhv3_update(struct Object *cappy, struct MarioState *m);
+
+#endif // SMO_MARIO_CAPPY_H
diff --git a/data/smo/capture/capture_all.c b/data/smo/capture/capture_all.c
new file mode 100644
index 0000000..d8253a7
--- /dev/null
+++ b/data/smo/capture/capture_all.c
@@ -0,0 +1,765 @@
+#include "../smo_c_includes.h"
+#include <string.h>
+#ifdef BETTERCAMERA
+#include "game/bettercamera.h"
+#endif
+
+//
+// Capture Data
+// These values are for an Object of scale 1.0f
+//
+
+#define ID(name) #name, cappy_##name##_init, cappy_##name##_end, cappy_##name##_get_top, cappy_##name##_mloop
+struct SmoCaptureData sSmoCaptureData[] = {
+    { ID(goomba),       12.f, 24.f,  24.f, 25.f, -40.f, -2.65f,  60.f,  65.f,   0.f,  50.f },
+    { ID(koopa),        16.f, 24.f,  32.f, 35.f, -48.f, -2.65f,  60.f,  40.f,   0.f,  50.f },
+    { ID(bobomb),       22.f, 22.f,  22.f, 36.f, -60.f, -4.00f,  65.f, 100.f,   0.f,  50.f },
+    { ID(bobomb_buddy),  0.f,  0.f,   0.f,  0.f,   0.f,  0.00f,   0.f,   0.f,   0.f,   0.f },
+    { ID(bobomb_king),   0.f,  0.f,   0.f,  0.f,   0.f,  0.00f,   0.f,   0.f,   0.f,   0.f },
+    { ID(chain_chomp),  15.f, 15.f,  45.f, 15.f, -36.f, -2.00f, 100.f, 160.f,   0.f,  80.f },
+
+    { ID(bullet_bill),  75.f, 75.f, 150.f,  0.f,   0.f,  0.00f, 200.f, 400.f, 200.f, 200.f },
+    { ID(hoot),         20.f, 20.f,  20.f, 24.f, -16.f, -2.00f,  75.f, 100.f,   0.f,  60.f },
+    { ID(whomp),        12.f, 12.f,  12.f, 40.f, -80.f, -4.00f, 100.f, 400.f,   0.f, 100.f },
+    { ID(whomp_king),    0.f,  0.f,   0.f,  0.f,   0.f,  0.00f,   0.f,   0.f,   0.f,   0.f },
+
+};
+static const u32 sSmoCaptureDataCount = sizeof(sSmoCaptureData) / sizeof(sSmoCaptureData[0]);
+#undef ID
+
+//
+// Capture Binds
+//
+
+struct SmoCaptureBind {
+    const BehaviorScript *behavior;
+    const char *id;
+};
+
+#define BIND(bhv, name) { bhv, #name }
+static const struct SmoCaptureBind sSmoCaptureBinds[] = {
+
+    /* Bob-omb Battlefield */
+    BIND(bhvGoomba, goomba),
+    BIND(bhvKoopa, koopa),
+    BIND(bhvBobomb, bobomb),
+    BIND(bhvBobombBuddy, bobomb_buddy),
+    BIND(bhvBobombBuddyOpensCannon, bobomb_buddy),
+    BIND(bhvKingBobomb, bobomb_king),
+    BIND(bhvChainChomp, chain_chomp),
+    BIND(bhvChainChompFreed, chain_chomp),
+
+    /* Whomp Fortress */
+    BIND(bhvBulletBill, bullet_bill),
+    BIND(bhvHoot, hoot),
+    BIND(bhvSmallWhomp, whomp),
+    BIND(bhvWhompKingBoss, whomp_king),
+
+};
+static const u32 sSmoCaptureBindCount = sizeof(sSmoCaptureBinds) / sizeof(sSmoCaptureBinds[0]);
+#undef BIND
+
+//
+// Possessed object stuff
+//
+
+void pobj_decelerate(struct PObject *pobj) {
+    if (obj_is_on_ground(pobj) && pobj->oFloor->type == SURFACE_ICE) {
+        pobj->oVelX *= 0.95f;
+        pobj->oVelZ *= 0.95f;
+        pobj->oForwardVel *= 0.95f;
+    } else {
+        pobj->oVelX *= 0.90f;
+        pobj->oVelZ *= 0.90f;
+        pobj->oForwardVel *= 0.90f;
+    }
+}
+
+void pobj_apply_gravity(struct PObject *pobj) {
+    pobj->oVelY += pobj->cdGravity;
+    if (pobj->oVelY < pobj->cdTerminalVelocity) {
+        pobj->oVelY = pobj->cdTerminalVelocity;
+    }
+}
+
+void pobj_handle_special_floors(struct PObject *pobj) {
+    pobj->oFloorType = POBJ_FLOOR_TYPE_NONE;
+
+    // Out of bounds
+    if (pobj->oFloor == NULL) {
+        mario_unpossess_object(pobj->oMario, MARIO_UNPOSSESS_ACT_JUMP_OUT, FALSE, 6);
+        obj_instant_death(pobj);
+        return;
+    }
+
+    // Squished
+    if (pobj->oSquishedTimer >= 6) {
+        set_camera_shake_from_hit(SHAKE_SMALL_DAMAGE);
+        mario_unpossess_object(pobj->oMario, MARIO_UNPOSSESS_ACT_KNOCKED_BACK, TRUE, 15);
+        return;
+    }
+
+    // On ground
+    s32 isOnGround = obj_is_on_ground(pobj);
+    if (isOnGround) {
+        pobj->oFloorType = POBJ_FLOOR_TYPE_GROUND;
+    }
+
+    // Above water
+    f32 waterLevel = find_water_level(pobj->oPosX, pobj->oPosZ);
+    if (!obj_is_underwater(pobj, waterLevel) && !(pobj->oProperties & POBJ_PROP_ABOVE_WATER)) {
+        mario_unpossess_object(pobj->oMario, MARIO_UNPOSSESS_ACT_JUMP_OUT, FALSE, 6);
+        obj_instant_death(pobj);
+        return;
+    }
+
+    // Walk/Slide on water
+    if (pobj->oPosY <= waterLevel && (pobj->oProperties & POBJ_PROP_WALK_ON_WATER)) {
+        pobj->oPosY = waterLevel;
+        pobj->oVelY = MAX(pobj->oVelY, 0.f);
+        pobj->oFloorHeight = 0.f;
+        pobj->oFloorType = POBJ_FLOOR_TYPE_WATER;
+    }
+    
+    // Underwater
+    else if (obj_is_underwater(pobj, waterLevel) && !(pobj->oProperties & POBJ_PROP_UNDERWATER)) {
+        pobj->oPosY = waterLevel + MAX(((pobj->hitboxHeight / 2) - pobj->hitboxDownOffset), 60.f);
+        mario_unpossess_object(pobj->oMario, MARIO_UNPOSSESS_ACT_JUMP_OUT, FALSE, 6);
+        obj_instant_death(pobj);
+        return;
+    }
+
+    // Special floors
+    switch (pobj->oFloor->type) {
+        case SURFACE_DEATH_PLANE:
+        case SURFACE_VERTICAL_WIND:
+            if (pobj->oFloorHeight <= 2048.f) {
+                mario_unpossess_object(pobj->oMario, MARIO_UNPOSSESS_ACT_JUMP_OUT, FALSE, 6);
+                obj_instant_death(pobj);
+            }
+            break;
+
+        case SURFACE_INSTANT_QUICKSAND:
+        case SURFACE_INSTANT_MOVING_QUICKSAND:
+            if (pobj->oFloorHeight <= 10.f && !(pobj->oProperties & POBJ_PROP_IMMUNE_TO_QUICKSANDS)) {
+                mario_unpossess_object(pobj->oMario, MARIO_UNPOSSESS_ACT_JUMP_OUT, FALSE, 6);
+                obj_instant_death(pobj);
+            }
+            break;
+
+        case SURFACE_BURNING:
+            if (pobj->oFloorHeight <= 10.f && !(pobj->oProperties & POBJ_PROP_IMMUNE_TO_LAVA)) {
+                mario_unpossess_object(pobj->oMario, MARIO_UNPOSSESS_ACT_JUMP_OUT, FALSE, 6);
+                obj_instant_death(pobj);
+            } else if (isOnGround) {
+                pobj->oFloorType = POBJ_FLOOR_TYPE_LAVA;
+            }
+            break;
+    }
+}
+
+//
+// Hits
+//
+
+#define INT_STATUS_ATTACKED         (0x02 | INT_STATUS_INTERACTED | INT_STATUS_WAS_ATTACKED)
+#define INT_STATUS_HIT_FROM_ABOVE   (0x03 | INT_STATUS_INTERACTED | INT_STATUS_WAS_ATTACKED)
+#define INT_STATUS_HIT_FROM_BELOW   (0x06 | INT_STATUS_INTERACTED | INT_STATUS_WAS_ATTACKED)
+
+static s32 is_backwards(struct PObject *pobj, struct Object *obj) {
+    s16 yawPobjToObj = obj_get_object1_angle_yaw_to_object2(pobj, obj);
+    s32 yawDiff = (s32)((s16)((s32)(yawPobjToObj) - (s32)(pobj->oFaceAngleYaw)));
+    pobj->oFaceAngleYaw = yawPobjToObj;
+    return (-0x4000 <= yawDiff) && (yawDiff <= +0x4000);
+}
+
+//
+// Interactions
+//
+
+static struct PObject *sPObj;
+static struct Object *sObj;
+static s32 sOverlapHitbox;
+static s32 sOverlapHurtbox;
+
+static s32 pobj_push_out_of_object_hitbox() {
+    if (sOverlapHitbox) {
+
+        // Push
+        f32 dx = sPObj->oPosX - sObj->oPosX;
+        f32 dz = sPObj->oPosZ - sObj->oPosZ;
+        f32 d = sqrtf(sqr(dx) + sqr(dz));
+        if (d == 0.f) {
+            // This is unlikely, but we must
+            // prevent a div/0 error
+            return FALSE;
+        }
+        f32 diff = (sPObj->hitboxRadius + sObj->hitboxRadius) - d;
+        f32 pushX = (dx / d) * diff;
+        f32 pushZ = (dz / d) * diff;
+
+        // Makes all SURFACE and POLELIKE objects unpushable, and ignore POBJ_PROP_UNPUSHABLE property
+        if (obj_is_surface(sObj) || !(sPObj->oProperties & POBJ_PROP_UNPUSHABLE)) {
+            sPObj->oPosX += pushX;
+            sPObj->oPosZ += pushZ;
+        } else {
+            sObj->oPosX -= pushX;
+            sObj->oPosZ -= pushZ;
+        }
+        return TRUE;
+    }
+    return FALSE;
+}
+
+static s32 pobj_push_out_of_object_hurtbox() {
+    if (sOverlapHurtbox) {
+
+        // Push
+        f32 dx = sPObj->oPosX - sObj->oPosX;
+        f32 dz = sPObj->oPosZ - sObj->oPosZ;
+        f32 d = sqrtf(sqr(dx) + sqr(dz));
+        if (d == 0.f) {
+            // This is unlikely, but we must
+            // prevent a div/0 error
+            return FALSE;
+        }
+        f32 diff = (sPObj->hitboxRadius + (sObj->hurtboxRadius > 0 ? sObj->hurtboxRadius : sObj->hitboxRadius)) - d;
+        f32 pushX = (dx / d) * diff;
+        f32 pushZ = (dz / d) * diff;
+
+        // Makes all SURFACE and POLELIKE objects unpushable, and ignore POBJ_PROP_UNPUSHABLE property
+        if (obj_is_surface(sObj) || !(sPObj->oProperties & POBJ_PROP_UNPUSHABLE)) {
+            sPObj->oPosX += pushX;
+            sPObj->oPosZ += pushZ;
+        } else {
+            sObj->oPosX -= pushX;
+            sObj->oPosZ -= pushZ;
+        }
+        return TRUE;
+    }
+    return FALSE;
+}
+
+static s32 pobj_interact_coin() {
+    if (sOverlapHitbox) {
+
+        // Add coins to Mario's
+        sPObj->oMario->numCoins += sObj->oDamageOrCoinValue;
+        sPObj->oMario->healCounter += 4 * sObj->oDamageOrCoinValue;
+        sObj->oInteractStatus = INT_STATUS_INTERACTED;
+
+        // Spawn 100 coins star
+        if (COURSE_IS_MAIN_COURSE(gCurrCourseNum)
+            && sPObj->oMario->numCoins - sObj->oDamageOrCoinValue < 100
+            && sPObj->oMario->numCoins >= 100) {
+            struct Object *star = spawn_object(sObj, MODEL_STAR, bhvSpawnedStarNoLevelExit);
+            star->oBehParams = (6 << 24);
+            star->oInteractionSubtype = INT_SUBTYPE_NO_EXIT;
+            obj_set_angle(star, 0, 0, 0);
+        }
+
+        return TRUE;
+    }
+    return FALSE;
+}
+
+static s32 pobj_mario_take_damage_and_unpossess() {
+
+    // No damage, push out of object
+    if (sOverlapHurtbox) {
+        if (sObj->oDamageOrCoinValue == 0 || (sPObj->oProperties & POBJ_PROP_INVULNERABLE)) {
+            return pobj_push_out_of_object_hurtbox();
+        }
+    }
+
+    // Damage Mario
+    if (sOverlapHurtbox) {
+        sObj->oInteractStatus = INT_STATUS_INTERACTED | INT_STATUS_ATTACKED_MARIO;
+        sPObj->oMario->hurtCounter += 4 * sObj->oDamageOrCoinValue;
+        sPObj->oMario->interactObj = sObj;
+        set_camera_shake_from_hit(SHAKE_SMALL_DAMAGE + MIN(sObj->oDamageOrCoinValue / 2, 2));
+        mario_unpossess_object(sPObj->oMario, MARIO_UNPOSSESS_ACT_KNOCKED_BACK, is_backwards(sPObj, sObj), 15);
+        return TRUE;
+    }
+
+    return FALSE;
+}
+
+static s32 pobj_interact_bounce_top() {
+
+    // Hit and bounce
+    if (sOverlapHitbox) {
+        if (obj_is_object2_hit_from_above(sPObj, sObj)) {
+            sObj->oInteractStatus = INT_STATUS_HIT_FROM_ABOVE;
+            sPObj->oPosY = sObj->oPosY + sObj->hitboxHeight - sObj->hitboxDownOffset + 20.f;
+            sPObj->oVelY = 20.f * sqrtf(absx(sPObj->smoData->captureData->gravity * sPObj->oScaleY));
+            play_sound(SOUND_ACTION_BOUNCE_OFF_OBJECT, sPObj->header.gfx.cameraToObject);
+            return TRUE;
+        }
+    }
+
+    // Attack
+    if (sOverlapHitbox) {
+        if (sPObj->oProperties & (POBJ_PROP_ATTACK | POBJ_PROP_STRONG_ATTACK)) {
+            sObj->oInteractStatus = INT_STATUS_ATTACKED;
+            return TRUE;
+        }
+    }
+
+    // Damage Mario
+    if (sOverlapHurtbox) {
+        return pobj_mario_take_damage_and_unpossess(sPObj, sObj, sPObj->oMario);
+    }
+
+    return FALSE;
+}
+
+static s32 pobj_interact_hit_from_below() {
+    
+    // Hit from below
+    if (sOverlapHitbox) {
+        if (obj_is_object2_hit_from_below(sPObj, sObj)) {
+            sObj->oInteractStatus = INT_STATUS_HIT_FROM_BELOW;
+            sPObj->oVelY = 0;
+            play_sound(SOUND_ACTION_BOUNCE_OFF_OBJECT, sPObj->header.gfx.cameraToObject);
+            set_camera_shake_from_hit(SHAKE_HIT_FROM_BELOW);
+            return TRUE;
+        }
+    }
+
+    // Hit from above
+    if (sOverlapHitbox) {
+        return pobj_interact_bounce_top(sPObj, sObj, sPObj->oMario);
+    }
+
+    return FALSE;
+}
+
+static s32 pobj_mario_burn_and_unpossess() {
+
+    // Burn Mario
+    if (sOverlapHurtbox) {
+
+        // No damage if underwater or immune
+        if (obj_is_underwater(sPObj, find_water_level(sPObj->oPosX, sPObj->oPosZ)) || (sPObj->oProperties & POBJ_PROP_IMMUNE_TO_FIRE)) {
+            return FALSE;
+        }
+
+        sObj->oInteractStatus = INT_STATUS_INTERACTED;
+        sPObj->oMario->interactObj = sObj;
+        sPObj->oMario->marioObj->oMarioBurnTimer = 0;
+        play_sound(SOUND_MARIO_ON_FIRE, sPObj->oMario->marioObj->header.gfx.cameraToObject);
+        mario_unpossess_object(sPObj->oMario, MARIO_UNPOSSESS_ACT_BURNT, FALSE, 15);
+        return TRUE;
+    }
+
+    return FALSE;
+}
+
+static s32 pobj_interact_bully() {
+
+    // Bully
+    if (sOverlapHitbox) {
+        f32 knockback = 3600.f / sObj->hitboxRadius;
+        s16 angle = obj_get_object1_angle_yaw_to_object2(sPObj, sObj);
+
+        // Bully the bully if sPObj attacks or is unpushable
+        if (sPObj->oProperties & (POBJ_PROP_UNPUSHABLE | POBJ_PROP_ATTACK | POBJ_PROP_STRONG_ATTACK)) {
+            // sPObj
+            sPObj->oUnresponsiveTimer = 6;
+            sPObj->oFaceAngleYaw = angle;
+            sPObj->oMoveAngleYaw = angle;
+            obj_set_forward_vel(sPObj, sPObj->oFaceAngleYaw, 0.2f, -knockback);
+            pobj_push_out_of_object_hitbox();
+
+            // Bully
+            sObj->oFaceAngleYaw = angle + 0x8000;
+            sObj->oMoveAngleYaw = angle;
+            sObj->oForwardVel = knockback;
+            sObj->oInteractStatus = INT_STATUS_ATTACKED;
+            play_sound(SOUND_OBJ_BULLY_METAL, sObj->header.gfx.cameraToObject);
+
+        } else {
+            // sPObj
+            sPObj->oUnresponsiveTimer = 30;
+            sPObj->oFaceAngleYaw = angle;
+            sPObj->oMoveAngleYaw = angle;
+            obj_set_forward_vel(sPObj, sPObj->oFaceAngleYaw, 1.f, -knockback);
+            pobj_push_out_of_object_hitbox();
+            play_sound(sPObj->oDeathSound, sPObj->header.gfx.cameraToObject);
+
+            // Bully
+            sObj->oFaceAngleYaw = angle + 0x8000;
+            sObj->oMoveAngleYaw = angle + 0x8000;
+            sObj->oInteractStatus = INT_STATUS_INTERACTED;
+            play_sound(SOUND_OBJ_BULLY_METAL, sObj->header.gfx.cameraToObject);
+        }
+        return TRUE;
+    }
+
+    return FALSE;
+}
+
+static s32 pobj_interact_breakable() {
+    
+    // Hit from below
+    if (sOverlapHitbox) {
+        if (obj_is_object2_hit_from_below(sPObj, sObj)) {
+            sObj->oInteractStatus = INT_STATUS_HIT_FROM_BELOW;
+            sPObj->oVelY = 0;
+            set_camera_shake_from_hit(SHAKE_HIT_FROM_BELOW);
+            return TRUE;
+        }
+    }
+
+    // Strong attack
+    if (sOverlapHitbox) {
+        if (sPObj->oProperties & POBJ_PROP_STRONG_ATTACK) {
+            sObj->oInteractStatus = INT_STATUS_ATTACKED;
+            set_camera_shake_from_hit(SHAKE_ATTACK);
+            return TRUE;
+        }
+    }
+
+    // Push
+    if (sOverlapHitbox) {
+        return pobj_push_out_of_object_hitbox();
+    }
+
+    return FALSE;
+}
+
+static s32 pobj_interact_grabbable() {
+    
+    // Is attackable (bob-ombs)
+    if (sOverlapHitbox) {
+        if ((sObj->oInteractionSubtype & INT_SUBTYPE_KICKABLE) && (sPObj->oProperties & (POBJ_PROP_ATTACK | POBJ_PROP_STRONG_ATTACK))) {
+            sObj->oInteractStatus = INT_STATUS_ATTACKED;
+            return FALSE;
+        }
+    }
+
+    // Is destructible (small boxes)
+    if (sOverlapHitbox) {
+        if (sPObj->oProperties & POBJ_PROP_STRONG_ATTACK) {
+            if (sObj->behavior == bhvBreakableBoxSmall) {
+                sObj->oNumLootCoins = 3;
+                obj_spawn_white_puff(sObj, SOUND_GENERAL_BREAK_BOX);
+                obj_spawn_triangle_break_particles(sObj, 20, 138, 0.7f, 3);
+                obj_spawn_loot_yellow_coins(sObj, 3, 20.0f);
+                obj_mark_for_deletion(sObj);
+                return TRUE;
+            }
+        }
+    }
+    
+    // Grabs Mario out of his possession
+    if (sOverlapHitbox) {
+        if ((sObj->oInteractionSubtype & INT_SUBTYPE_GRABS_MARIO) && obj_is_object1_facing_object2(sObj, sPObj, 0x2800)) {
+            sObj->oInteractStatus = INT_STATUS_INTERACTED | INT_STATUS_GRABBED_MARIO;
+            sPObj->oFaceAngleYaw = sObj->oMoveAngleYaw;
+            sPObj->oMario->interactObj = sObj;
+            sPObj->oMario->usedObj = sObj;
+            play_sound(SOUND_MARIO_OOOF, sPObj->oMario->marioObj->header.gfx.cameraToObject);
+            mario_unpossess_object(sPObj->oMario, MARIO_UNPOSSESS_ACT_GRABBED, FALSE, 15);
+            return TRUE;
+        }
+    }
+
+    // Damage Mario
+    if (sOverlapHurtbox) {
+        return pobj_mario_take_damage_and_unpossess(sPObj, sObj, sPObj->oMario);
+    }
+
+    return FALSE;
+}
+
+static s32 pobj_interact_clam_or_bubba() {
+
+    // Eats Mario and his possession
+    if (sOverlapHurtbox) {
+        if (sObj->oInteractionSubtype & INT_SUBTYPE_EATS_MARIO) {
+            sObj->oInteractStatus = INT_STATUS_INTERACTED;
+            sPObj->oMario->interactObj = sObj;
+            mario_unpossess_object(sPObj->oMario, MARIO_UNPOSSESS_ACT_EATEN, FALSE, 15);
+            obj_instant_death(sPObj);
+            return TRUE;
+        }
+    }
+
+    // Damage Mario
+    if (sOverlapHurtbox) {
+        return pobj_mario_take_damage_and_unpossess(sPObj, sObj, sPObj->oMario);
+    }
+
+    return FALSE;
+}
+
+static s32 pobj_interact_strong_wind() {
+
+    // Blow Mario away, out of his possession
+    if (sOverlapHitbox) {
+
+        // SL walking penguin
+        if (sPObj->oProperties & POBJ_PROP_RESIST_STRONG_WINDS) {
+            sObj->oIntangibleTimer = -1;
+            obj_mark_for_deletion(sObj);
+            return FALSE;
+        }
+
+        sObj->oInteractStatus = INT_STATUS_INTERACTED;
+        sPObj->oMario->interactObj = sObj;
+        sPObj->oMario->usedObj = sObj;
+        sPObj->oMario->unkC4 = 0.4f;
+        sPObj->oFaceAngleYaw = sObj->oMoveAngleYaw + 0x8000;
+        play_sound(SOUND_MARIO_WAAAOOOW, sPObj->oMario->marioObj->header.gfx.cameraToObject);
+        mario_unpossess_object(sPObj->oMario, MARIO_UNPOSSESS_ACT_BLOWN, FALSE, 15);
+        return TRUE;
+    }
+    
+    return FALSE;
+}
+
+static s32 pobj_interact_tornado() {
+
+    // Suck Mario out of his possession
+    if (sOverlapHitbox) {
+
+        // Same flag used to resist tornados
+        if (sPObj->oProperties & POBJ_PROP_RESIST_STRONG_WINDS) {
+            return FALSE;
+        }
+
+        sObj->oInteractStatus = INT_STATUS_INTERACTED;
+        sPObj->oMario->interactObj = sObj;
+        sPObj->oMario->usedObj = sObj;
+        sPObj->oMario->marioObj->oMarioTornadoYawVel = 0x400;
+        sPObj->oMario->marioObj->oMarioTornadoPosY = sPObj->oPosY - sObj->oPosY;
+        play_sound(SOUND_MARIO_WAAAOOOW, sPObj->oMario->marioObj->header.gfx.cameraToObject);
+        mario_unpossess_object(sPObj->oMario, MARIO_UNPOSSESS_ACT_TORNADO, FALSE, 15);
+        return TRUE;
+    }
+
+    return FALSE;
+}
+
+s32 pobj_process_interaction(struct PObject *pobj, struct Object *obj, u32 interactType) {
+
+    // Set up statics
+    sPObj = pobj;
+    sObj  = obj;
+    sOverlapHitbox  = obj_detect_overlap(pobj, obj, OBJ_OVERLAP_FLAG_HITBOX, OBJ_OVERLAP_FLAG_HITBOX);
+    sOverlapHurtbox = obj_detect_overlap(pobj, obj, OBJ_OVERLAP_FLAG_HITBOX, OBJ_OVERLAP_FLAG_HURTBOX_HITBOX_IF_ZERO);
+
+    // Interaction
+    switch (interactType) {
+        case INTERACT_COIN:
+            return pobj_interact_coin();
+
+        case INTERACT_SNUFIT_BULLET:
+        case INTERACT_MR_BLIZZARD:
+        case INTERACT_UNKNOWN_08:
+        case INTERACT_SHOCK:
+        case INTERACT_DAMAGE:
+            return pobj_mario_take_damage_and_unpossess();
+
+        case INTERACT_KOOPA:
+        case INTERACT_BOUNCE_TOP:
+        case INTERACT_BOUNCE_TOP2:
+            return pobj_interact_bounce_top();
+
+        case INTERACT_HIT_FROM_BELOW:
+            return pobj_interact_hit_from_below();
+
+        case INTERACT_FLAME:
+            return pobj_mario_burn_and_unpossess();
+
+        case INTERACT_BULLY:
+            return pobj_interact_bully();
+
+        case INTERACT_BREAKABLE:
+            return pobj_interact_breakable();
+
+        case INTERACT_GRABBABLE:
+            return pobj_interact_grabbable();
+
+        case INTERACT_CLAM_OR_BUBBA:
+            return pobj_interact_clam_or_bubba();
+
+        case INTERACT_STRONG_WIND:
+            return pobj_interact_strong_wind();
+
+        case INTERACT_TORNADO:
+            return pobj_interact_tornado();
+
+        case INTERACT_DOOR:
+        case INTERACT_WARP_DOOR:
+        case INTERACT_POLE:
+        case INTERACT_IGLOO_BARRIER:
+        case INTERACT_KOOPA_SHELL:
+        case INTERACT_UNKNOWN_31:
+            return pobj_push_out_of_object_hitbox();
+
+        case INTERACT_CAP:
+        case INTERACT_WARP:
+        case INTERACT_STAR_OR_KEY:
+        case INTERACT_WATER_RING:
+        case INTERACT_WHIRLPOOL:
+        case INTERACT_TEXT:
+        case INTERACT_BBH_ENTRANCE:
+        case INTERACT_CANNON_BASE:
+        default:
+            break; // Do nothing
+    }
+    return FALSE;
+}
+
+//
+// Dialog
+//
+
+enum {
+    DIALOG_STATE_NONE,
+    DIALOG_STATE_BEGIN,
+    DIALOG_STATE_WAIT,
+    DIALOG_STATE_END
+};
+static u8 sDialogState = DIALOG_STATE_NONE;
+static s16 sDialogId = -1;
+
+s32 dialog_start(s16 dialogId) {
+    if (sDialogState != DIALOG_STATE_NONE || dialogId < 0) {
+        return FALSE;
+    }
+    sDialogId = dialogId;
+    sDialogState = DIALOG_STATE_BEGIN;
+    return TRUE;
+}
+
+s32 dialog_update() {
+    switch (sDialogState) {
+        case DIALOG_STATE_NONE:
+            return TRUE;
+
+        case DIALOG_STATE_BEGIN:
+            create_dialog_box(sDialogId);
+            sDialogState = DIALOG_STATE_WAIT;
+            break;
+
+        case DIALOG_STATE_WAIT:
+            if (get_dialog_id() < 0) {
+                sDialogState = DIALOG_STATE_END;
+            }
+            break;
+
+        case DIALOG_STATE_END:
+            sDialogId = -1;
+            sDialogState = DIALOG_STATE_NONE;
+            break;
+    }
+    return FALSE;
+}
+
+enum {
+    CUTSCENE_STATE_NONE,
+    CUTSCENE_STATE_BEGIN,
+    CUTSCENE_STATE_WAIT,
+    CUTSCENE_STATE_END
+};
+static u8 sCutsceneState = CUTSCENE_STATE_NONE;
+static u8 sCutsceneId = 0;
+static struct Object *sCutsceneObject = NULL;
+
+s32 cutscene_start(u8 cutsceneId, struct Object* obj) {
+    if (sCutsceneState != CUTSCENE_STATE_NONE || cutsceneId == 0 || obj == NULL) {
+        return FALSE;
+    }
+    sCutsceneId = cutsceneId;
+    sCutsceneObject = obj;
+    sCutsceneState = CUTSCENE_STATE_BEGIN;
+    return TRUE;
+}
+
+s32 cutscene_update() {
+    switch (sCutsceneState) {
+        case CUTSCENE_STATE_NONE:
+            return TRUE;
+
+        case CUTSCENE_STATE_BEGIN:
+            if (cutscene_object(sCutsceneId, sCutsceneObject) == 1) {
+                sCutsceneState = CUTSCENE_STATE_WAIT;
+            } else {
+                sCutsceneState = CUTSCENE_STATE_END;
+            }
+            break;
+
+        case CUTSCENE_STATE_WAIT:
+            if (cutscene_object(sCutsceneId, sCutsceneObject) == -1) {
+                sCutsceneState = CUTSCENE_STATE_END;
+            }
+            break;
+
+        case CUTSCENE_STATE_END:
+            sCutsceneId = 0;
+            sCutsceneObject = NULL;
+            sCutsceneState = CUTSCENE_STATE_NONE;
+            break;
+    }
+    return FALSE;
+}
+
+//
+// Camera
+//
+
+void smo_capture_set_camera_behind_mario(struct PObject *pobj) {
+    if (pobj->oMario->area->camera->mode != CAMERA_MODE_BEHIND_MARIO) {
+#ifndef BETTERCAMERA
+        set_camera_mode(pobj->oMario->area->camera, CAMERA_MODE_BEHIND_MARIO, 1);
+#else
+        if (newcam_active == 0) {
+            set_camera_mode(pobj->oMario->area->camera, CAMERA_MODE_BEHIND_MARIO, 1);
+        } else {
+            pobj->oCameraBehindMario = TRUE;
+            pobj->oMario->area->camera->mode = CAMERA_MODE_NEWCAM;
+            gLakituState.mode = CAMERA_MODE_NEWCAM;
+        }
+#endif
+    }
+}
+
+void smo_capture_reset_camera(struct PObject *pobj) {
+    if (pobj->oMario->area->camera->mode == CAMERA_MODE_BEHIND_MARIO) {
+#ifndef BETTERCAMERA
+        set_camera_mode(pobj->oMario->area->camera, pobj->oMario->area->camera->defMode, 1);
+#else
+        if (newcam_active == 0) {
+            set_camera_mode(pobj->oMario->area->camera, pobj->oMario->area->camera->defMode, 1);
+        } else {
+            pobj->oCameraBehindMario = FALSE;
+            pobj->oMario->area->camera->mode = CAMERA_MODE_NEWCAM;
+            gLakituState.mode = CAMERA_MODE_NEWCAM;
+        }
+#endif
+    }
+}
+
+//
+// Capture
+//
+
+const struct SmoCaptureData *cappy_capture(struct Object *obj) {
+    const BehaviorScript *behavior = obj->behavior;
+	for (u32 i = 0; i != sSmoCaptureBindCount; ++i) {
+        if (behavior == sSmoCaptureBinds[i].behavior) {
+            for (u32 j = 0; j != sSmoCaptureDataCount; ++j) {
+                if (strcmp(sSmoCaptureBinds[i].id, sSmoCaptureData[j].id) == 0) {
+                    return &sSmoCaptureData[j];
+                }
+            }
+            return NULL; // Uh oh, looks like I forgot an Id
+        }
+	}
+    return NULL;
+}
+
diff --git a/data/smo/capture/capture_all.h b/data/smo/capture/capture_all.h
new file mode 100644
index 0000000..63aa5f6
--- /dev/null
+++ b/data/smo/capture/capture_all.h
@@ -0,0 +1,185 @@
+#ifndef CAPTURE_ALL_H
+#define CAPTURE_ALL_H
+
+#include "types.h"
+
+/* Possessed Object type */
+#define PObject Object
+
+// Init function
+// Called before trying to possess the object.
+// Returns TRUE if the object can be possessed.
+typedef s32 (*PObjInitFunc)(struct Object *);
+
+// Main loop entry point
+// A list of this type of function is used as the behavior
+// of the possessed object. Always ends with NULL.
+typedef void (*PObjMainLoopFunc)(struct PObject *);
+
+// End function
+// Called after "resetting" the object, i.e. after restoring his
+// object fields to their values before the possession.
+// SMO fields are not deallocated yet, and can be still accessed.
+typedef void (*PObjEndFunc)(struct Object *);
+
+// Get top of object function
+// Used as a y offset for both animations of Mario
+// entering the object and leaving the object
+typedef f32 (*PObjGetTopFunc)(struct Object *);
+
+/* Possessed object constants */
+#define POBJ_FLOOR_TYPE_NONE	0
+#define POBJ_FLOOR_TYPE_GROUND	1
+#define POBJ_FLOOR_TYPE_WATER	2
+#define POBJ_FLOOR_TYPE_LAVA	3
+
+/* Possessed object stuff */
+void pobj_decelerate(struct PObject *pobj);
+void pobj_apply_gravity(struct PObject *pobj);
+void pobj_handle_special_floors(struct PObject *pobj);
+s32  pobj_process_interaction(struct PObject *pobj, struct Object *obj, u32 interactType);
+
+/* Dialog */
+s32 dialog_start(s16 dialogId);
+s32 dialog_update(); // Returns TRUE if the dialog is finished
+s32 cutscene_start(u8 cutsceneId, struct Object *obj);
+s32 cutscene_update(); // Returns TRUE if the cutscene is finished
+
+/* Camera */
+void smo_capture_set_camera_behind_mario(struct PObject *pobj);
+void smo_capture_reset_camera(struct PObject *pobj);
+
+/* Interaction macros */
+// Only for use inside the cappy_***_process_interactions functions
+// Make sure to replace these monstruosities by lambdas if it's ported to C++
+#define POBJ_INTERACTIONS_BEGIN \
+    for (u32 objType = OBJ_LIST_DESTRUCTIVE; objType <= OBJ_LIST_POLELIKE; ++objType) { \
+        struct ObjectNode *list = &gObjectLists[objType]; \
+        struct Object *obj = obj_get_first(list); \
+        while (obj != NULL) { \
+            if (obj != pobj) {
+
+#define POBJ_INTERACTIONS_END \
+                u32 interactType = obj->oInteractType; \
+                if (!(obj->oInteractStatus & INT_STATUS_INTERACTED)) { \
+                    pobj_process_interaction(pobj, obj, interactType); \
+                } \
+            } \
+            obj = obj_get_next(list, obj); \
+        } \
+    }
+
+/* Capture data */
+struct SmoCaptureData {
+    const char *id;
+    const PObjInitFunc init;
+    const PObjEndFunc end;
+    const PObjGetTopFunc gettop;
+    const PObjMainLoopFunc *mloop;
+    f32 walkSpeed;
+    f32 runSpeed;
+    f32 dashSpeed;
+    f32 jumpVelocity;
+    f32 terminalVelocity;
+    f32 gravity;
+    f32 hitboxRadius;
+    f32 hitboxHeight;
+    f32 hitboxDownOffset;
+    f32 wallHitboxRadius;
+};
+
+/* Cappy Capture */
+const struct SmoCaptureData *cappy_capture(struct Object *obj);
+
+#define CAPTURE_BEHAVIOR(name)							\
+extern const PObjMainLoopFunc cappy_##name##_mloop[];	\
+s32 cappy_##name##_init(struct Object *obj);			\
+void cappy_##name##_end(struct Object *obj);			\
+f32 cappy_##name##_get_top(struct Object *obj)
+
+/* Bob-omb Battlefield */
+CAPTURE_BEHAVIOR(goomba);				// bhvGoomba
+CAPTURE_BEHAVIOR(koopa);				// bhvKoopa
+CAPTURE_BEHAVIOR(bobomb);				// bhvBobomb
+CAPTURE_BEHAVIOR(bobomb_buddy);			// bhvBobombBuddy, bhvBobombBuddyOpensCannon
+CAPTURE_BEHAVIOR(bobomb_king);			// bhvKingBobomb
+CAPTURE_BEHAVIOR(chain_chomp);			// bhvChainChomp, bhvChainChompFreed
+
+/* Whomp Fortress */
+CAPTURE_BEHAVIOR(bullet_bill);			// bhvBulletBill
+CAPTURE_BEHAVIOR(hoot);					// bhvHoot
+CAPTURE_BEHAVIOR(whomp);				// bhvSmallWhomp
+CAPTURE_BEHAVIOR(whomp_king);			// bhvWhompKingBoss
+
+/* Jolly Roger Bay */
+
+/* Cool, Cool Mountain */
+CAPTURE_BEHAVIOR(spindrift);			// bhvSpindrift
+CAPTURE_BEHAVIOR(tuxies_mother);		// bhvTuxiesMother
+CAPTURE_BEHAVIOR(penguin_small);		// bhvPenguinBaby, bhvSmallPenguin
+CAPTURE_BEHAVIOR(snowmans_head);		// bhvSnowmansHead
+CAPTURE_BEHAVIOR(snowmans_body);		// bhvSnowmansBottom
+CAPTURE_BEHAVIOR(snowman_big);			// bhvBigSnowmanWhole
+
+/* Big Boo's Haunt */
+CAPTURE_BEHAVIOR(boo);					// bhvBoo, bhvBooInCastle, bhvBooWithCage, bhvGhostHuntBoo, bhvMerryGoRoundBoo
+CAPTURE_BEHAVIOR(big_boo);				// bhvGhostHuntBigBoo, bhvBalconyBigBoo, bhvMerryGoRoundBigBoo
+CAPTURE_BEHAVIOR(crazy_box);			// bhvJumpingBox
+CAPTURE_BEHAVIOR(scuttlebug);			// bhvScuttlebug
+CAPTURE_BEHAVIOR(mad_piano);			// bhvMadPiano
+
+/* Hazy Maze Cave */
+CAPTURE_BEHAVIOR(swoop);				// bhvSwoop
+CAPTURE_BEHAVIOR(snufit);				// bhvSnufit
+CAPTURE_BEHAVIOR(dorrie);				// bhvDorrie
+
+/* Lethal Lava Land */
+CAPTURE_BEHAVIOR(bully);				// bhvSmallBully
+CAPTURE_BEHAVIOR(big_bully);			// bhvBigBully, bhvBigBullyWithMinions
+
+/* Shifting Sand Land */
+CAPTURE_BEHAVIOR(fly_guy);				// bhvFlyGuy
+CAPTURE_BEHAVIOR(pokey);				// bhvPokey, bhvPokeyBodyPart
+CAPTURE_BEHAVIOR(amp);					// bhvHomingAmp, bhvCirclingAmp
+CAPTURE_BEHAVIOR(klepto);				// bhvKlepto
+CAPTURE_BEHAVIOR(eyerock);				// bhvEyerokBoss, bhvEyerokHand
+
+/* Dire, Dire Docks */
+CAPTURE_BEHAVIOR(fire_spitter);			// bhvFireSpitter
+CAPTURE_BEHAVIOR(sushi_shark);			// bhvSushiShark
+
+/* Snowman's Land */
+CAPTURE_BEHAVIOR(moneybag);				// bhvMoneybag, bhvMoneybagHidden
+CAPTURE_BEHAVIOR(big_chill_bully);		// bhvBigChillBully
+CAPTURE_BEHAVIOR(sl_walking_penguin);	// bhvSLWalkingPenguin
+
+/* Wet-Dry World */
+CAPTURE_BEHAVIOR(skeeter);              // bhvSkeeter
+CAPTURE_BEHAVIOR(heave_ho);             // bhvHeaveHo
+CAPTURE_BEHAVIOR(chuckya);              // bhvChuckya
+
+/* Tall, Tall Mountain */
+CAPTURE_BEHAVIOR(ukiki);                // bhvUkiki, bhvMacroUkiki
+//extern const BehaviorScript bhvCloud[];
+//extern const BehaviorScript bhvCloudPart[];
+
+/* Tiny-Huge Island */
+CAPTURE_BEHAVIOR(enemy_lakitu);         // bhvEnemyLakitu
+CAPTURE_BEHAVIOR(spiny);                // bhvSpiny
+CAPTURE_BEHAVIOR(wiggler);              // bhvWigglerHead, bhvWigglerBody
+
+/* Tick Tock Clock */
+
+/* Rainbow Ride */
+
+/* Misc */
+CAPTURE_BEHAVIOR(bowser);               // bhvBowser
+CAPTURE_BEHAVIOR(toad);                 // bhvToadMessage
+CAPTURE_BEHAVIOR(mips);                 // bhvMips
+CAPTURE_BEHAVIOR(yoshi);                // bhvYoshi
+
+/* New behaviors */
+extern const BehaviorScript bhvChainChompFreed[];
+
+#undef CAPTURE_BEHAVIOR
+#endif // CAPTURE_ALL_H
diff --git a/data/smo/capture/capture_bobomb.c b/data/smo/capture/capture_bobomb.c
new file mode 100644
index 0000000..3f54bbd
--- /dev/null
+++ b/data/smo/capture/capture_bobomb.c
@@ -0,0 +1,225 @@
+#include "../smo_c_includes.h"
+
+//
+// Possessed Bobomb explosion
+//
+
+static void cappy_bobomb_explosion_attack(struct Object *this) {
+    for (u32 objType = OBJ_LIST_DESTRUCTIVE; objType <= OBJ_LIST_POLELIKE; ++objType) {
+        struct ObjectNode *list = &gObjectLists[objType];
+        struct Object *obj = obj_get_first(list);
+        while (obj != NULL) {
+            if (obj != this) {
+                if (obj_detect_overlap(this, obj, OBJ_OVERLAP_FLAG_HITBOX, OBJ_OVERLAP_FLAG_HITBOX)) {
+                    switch (obj->oInteractType) {
+                        case INTERACT_KOOPA:
+                        case INTERACT_BOUNCE_TOP:
+                        case INTERACT_BOUNCE_TOP2:
+                        case INTERACT_HIT_FROM_BELOW: {
+                            obj->oInteractStatus = (0x02 | INT_STATUS_INTERACTED | INT_STATUS_WAS_ATTACKED);
+                        } break;
+
+                        case INTERACT_BULLY: {
+                            f32 knockback = 3600.f / obj->hitboxRadius;
+                            s16 angle = obj_get_object1_angle_yaw_to_object2(this, obj);
+                            obj->oFaceAngleYaw = angle + 0x8000;
+                            obj->oMoveAngleYaw = angle;
+                            obj->oForwardVel = knockback;
+                            obj->oInteractStatus = (0x02 | INT_STATUS_INTERACTED | INT_STATUS_WAS_ATTACKED);
+                            play_sound(SOUND_OBJ_BULLY_METAL, obj->header.gfx.cameraToObject);
+                        } break;
+
+                        case INTERACT_BREAKABLE: {
+                            obj->oInteractStatus = (0x02 | INT_STATUS_INTERACTED | INT_STATUS_WAS_ATTACKED);
+                            set_camera_shake_from_hit(SHAKE_ATTACK);
+                        } break;
+
+                        case INTERACT_GRABBABLE: {
+                            if (obj->oInteractionSubtype & INT_SUBTYPE_KICKABLE) {
+                                obj->oInteractStatus = (0x02 | INT_STATUS_INTERACTED | INT_STATUS_WAS_ATTACKED);
+                            }
+                            if (obj->behavior == bhvBreakableBoxSmall) {
+                                obj->oNumLootCoins = 3;
+                                obj_spawn_white_puff(obj, SOUND_GENERAL_BREAK_BOX);
+                                obj_spawn_triangle_break_particles(obj, 20, 138, 0.7f, 3);
+                                obj_spawn_loot_yellow_coins(obj, 3, 20.0f);
+                                obj_mark_for_deletion(obj);
+                            }
+                        } break;
+                    }
+                }
+            }
+            obj = obj_get_next(list, obj);
+        }
+    }
+}
+
+void bhv_cappy_bobomb_explosion_loop(void) {
+    if (gCurrentObject->oTimer >= 10) {
+        spawn_object(gCurrentObject, MODEL_SMOKE, bhvBobombBullyDeathSmoke);
+        obj_mark_for_deletion(gCurrentObject);
+        return;
+    }
+
+    f32 scale = (f32) gCurrentObject->oTimer / 3.f + 1.0f;
+    gCurrentObject->header.gfx.scale[0] = scale;
+    gCurrentObject->header.gfx.scale[1] = scale;
+    gCurrentObject->header.gfx.scale[2] = scale;
+    gCurrentObject->hitboxRadius = 360.f;
+    gCurrentObject->hitboxHeight = 360.f;
+    gCurrentObject->hitboxDownOffset = 0.f;
+    gCurrentObject->oOpacity = MAX(0, 0xFF - (0x1C * gCurrentObject->oTimer));
+    gCurrentObject->oAnimState++;
+    gCurrentObject->oIntangibleTimer = 0;
+    cappy_bobomb_explosion_attack(gCurrentObject);
+}
+
+const BehaviorScript bhvCappyBobombExplosion[] = {
+    0x00020000,
+    0x110100C1,
+    0x21000000,
+    0x08000000,
+    0x0C000000, (uintptr_t) (bhv_cappy_bobomb_explosion_loop),
+    0x09000000, 
+};
+
+//
+// Possessed Bobomb
+//
+
+static void cappy_bobomb_set_properties(struct PObject *pobj) {
+    pobj->hitboxRadius = pobj->cdHitboxRadius;
+    pobj->hitboxHeight = pobj->cdHitboxHeight;
+    pobj->hitboxDownOffset = pobj->cdHitboxDownOffset;
+    pobj->oWallHitboxRadius = pobj->cdWallHitboxRadius;
+    pobj->oProperties = 0;
+    pobj->oProperties |= POBJ_PROP_ABOVE_WATER;
+}
+
+static void cappy_bobomb_process_inputs(struct PObject *pobj) {
+    pobj_decelerate(pobj);
+    pobj_apply_gravity(pobj);
+
+    // Inputs
+    if (pobj->oUnresponsiveTimer == 0) {
+
+        // Walk
+        f32 hvel = pobj->cdWalkSpeed;
+        if (pobj->oStickMag > 0) {
+            s32 faceYaw = pobj->oStickYaw - approach_s32((s16)(pobj->oStickYaw - pobj->oFaceAngleYaw), 0, 0x1000, 0x1000);
+            obj_set_forward_vel(pobj, faceYaw, pobj->oStickMag, hvel);
+            pobj->oFaceAngleYaw = faceYaw;
+            pobj->oFaceAnglePitch = 0;
+            pobj->oFaceAngleRoll = 0;
+            pobj->oMoveAngleYaw = faceYaw;
+            pobj->oMoveAnglePitch = 0;
+            pobj->oMoveAngleRoll = 0;
+        }
+
+        // Jump
+        if ((pobj->oButtonPressed & A_BUTTON) && obj_is_on_ground(pobj)) {
+            pobj->oVelY = pobj->cdJumpVelocity;
+            pobj->oFloor = NULL;
+            play_sound(SOUND_OBJ_GOOMBA_ALERT, pobj->header.gfx.cameraToObject);
+        }
+
+        // Explosion
+        if ((pobj->oButtonPressed & B_BUTTON) && pobj->oCappyBobombExplosionTimer == 0) {
+            struct Object* explosion = spawn_object(pobj, MODEL_EXPLOSION, bhvCappyBobombExplosion);
+            if (explosion != NULL) {
+                explosion->oFlags |= OBJ_FLAG_UPDATE_GFX_POS_AND_ANGLE;
+                explosion->oAnimState = -1;
+                explosion->oGraphYOffset += 100.0f;
+                explosion->oOpacity = 255;
+                explosion->oIntangibleTimer = 0;
+                create_sound_spawner(SOUND_GENERAL2_BOBOMB_EXPLOSION);
+                set_environmental_camera_shake(SHAKE_ENV_EXPLOSION);
+
+                // Make the bob-omb bloat after each explosion
+                pobj->oScaleX *= 1.2f;
+                pobj->oScaleY *= 1.2f;
+                pobj->oScaleZ *= 1.2f;
+                pobj->oCappyBobombExplosionTimer = 30;
+                pobj->oCappyBobombExplosionCount++;
+                
+                // If used three times in a row, removes the bob-omb
+                if (pobj->oCappyBobombExplosionCount == 3) {
+                    mario_unpossess_object(pobj->oMario, MARIO_UNPOSSESS_ACT_JUMP_OUT, FALSE, 0);
+                    obj_instant_death(pobj);
+                }
+            }
+        }
+    } else {
+        pobj->oUnresponsiveTimer--;
+    }
+
+    if (pobj->oCappyBobombExplosionTimer > 0) {
+        pobj->oCappyBobombExplosionTimer--;
+    }
+}
+
+static void cappy_bobomb_update_pos(struct PObject *pobj) {
+    obj_update_pos_and_vel(pobj, pobj->oProperties & POBJ_PROP_MOVE_THROUGH_VC_WALLS, obj_is_on_ground(pobj), &pobj->oSquishedTimer);
+    pobj_handle_special_floors(pobj);
+}
+
+static void cappy_bobomb_process_interactions(struct PObject *pobj) {
+    POBJ_INTERACTIONS_BEGIN;
+
+    // Possessed bobomb explosion
+    if (obj->behavior == bhvCappyBobombExplosion) {
+        obj->oInteractStatus = INT_STATUS_INTERACTED;
+    }
+
+    POBJ_INTERACTIONS_END;
+}
+
+static void cappy_bobomb_update_animation_and_sound(struct PObject *pobj) {
+    obj_set_animation_with_accel(pobj, 0, (pobj->oVelY <= 0.f) * MAX(1.f, pobj->oForwardVel * (2.f / (pobj->cdWalkSpeed))));
+    obj_random_blink(pobj, &pobj->oBobombBlinkTimer);
+    if (obj_is_on_ground(pobj)) {
+        obj_make_step_sound_and_particle(pobj, &pobj->oWalkDistance, pobj->cdWalkSpeed * 12, pobj->oForwardVel, SOUND_OBJ_BOBOMB_WALK, OBJ_STEP_PARTICLE_NONE);
+    }
+}
+
+static void cappy_bobomb_set_cappy_values(struct PObject *pobj) {
+    pobj->oCappyVerticalDist = 94.f;
+    pobj->oCappyInitialScale = 120;
+}
+
+//
+// Main loop
+//
+
+const PObjMainLoopFunc cappy_bobomb_mloop[] = {
+    cappy_bobomb_set_properties,
+    cappy_bobomb_process_inputs,
+    cappy_bobomb_update_pos,
+    cappy_bobomb_process_interactions,
+    obj_update_gfx,
+    cappy_bobomb_update_animation_and_sound,
+    cappy_bobomb_set_cappy_values,
+    NULL
+};
+
+//
+// Init
+//
+
+s32 cappy_bobomb_init(struct Object* obj) {
+    obj->oCappyBobombExplosionTimer = 0;
+    obj->oCappyBobombExplosionCount = 0;
+    obj->oScaleX = 1.f;
+    obj->oScaleY = 1.f;
+    obj->oScaleZ = 1.f;
+    return TRUE;
+}
+
+void cappy_bobomb_end(struct Object *obj) {
+    obj->header.gfx.unk38.curAnim = NULL;
+    obj_set_animation_with_accel(obj, 0, 1.f);
+}
+
+f32 cappy_bobomb_get_top(struct Object *obj) {
+    return 94.f * obj->oScaleY;
+}
\ No newline at end of file
diff --git a/data/smo/capture/capture_bobomb_buddy.c b/data/smo/capture/capture_bobomb_buddy.c
new file mode 100644
index 0000000..8e1bea5
--- /dev/null
+++ b/data/smo/capture/capture_bobomb_buddy.c
@@ -0,0 +1,163 @@
+#include "../smo_c_includes.h"
+
+//
+// Possessed Bob-omb buddy
+//
+
+static void cappy_bobomb_buddy_advice_update(struct PObject *pobj) {
+    // Delay
+    if (pobj->oCappyBobombBuddyTimer > 0) {
+        pobj->oCappyBobombBuddyTimer--;
+        return;
+    }
+
+    switch (pobj->oCappyBobombBuddyState) {
+        case 0: // Start dialog
+            if (mario_lock(pobj->oMario) && dialog_start(pobj->oBehParams2ndByte)) {
+                pobj->oCappyBobombBuddyState = 1;
+            }
+            break;
+
+        case 1: // Wait for the dialog to end
+            if (dialog_update()) {
+                pobj->oCappyBobombBuddyState = 2;
+                pobj->oCappyBobombBuddyTimer = 5;
+            }
+            break;
+
+        case 2: // Release Mario
+            if (mario_unlock(pobj->oMario)) {
+                mario_unpossess_object(pobj->oMario, MARIO_UNPOSSESS_ACT_JUMP_OUT, FALSE, 6);
+                pobj->oCappyBobombBuddyState = 3;
+            }
+            break;
+    }
+}
+
+static void cappy_bobomb_buddy_cannon_update(struct PObject *pobj) {
+    // Delay
+    if (pobj->oCappyBobombBuddyTimer > 0) {
+        pobj->oCappyBobombBuddyTimer--;
+        return;
+    }
+
+    // Dialog ids
+    s16 dialog1Id;
+    s16 dialog2Id;
+    if (gCurrCourseNum == COURSE_BOB) {
+        dialog1Id = DIALOG_004;
+        dialog2Id = DIALOG_105;
+    } else {
+        dialog1Id = DIALOG_047;
+        dialog2Id = DIALOG_106;
+    }
+
+    switch (pobj->oCappyBobombBuddyState) {
+        case 0: // Check if cannon is opened
+            if (mario_lock(pobj->oMario)) {
+                if (cur_obj_nearest_object_with_behavior(bhvCannonClosed) != NULL) {
+                    pobj->oCappyBobombBuddyState = 1;
+                } else {
+                    pobj->oCappyBobombBuddyState = 5;
+                }
+            }
+            break;
+
+        case 1: // Start dialog 1
+            if (dialog_start(dialog1Id)) {
+                pobj->oCappyBobombBuddyState = 2;
+            }
+            break;
+
+        case 2: // Wait for the dialog 1 to end
+            if (dialog_update()) {
+                pobj->oCappyBobombBuddyState = 3;
+                pobj->oCappyBobombBuddyTimer = 5;
+            }
+            break;
+
+        case 3: // Start cannon opening cutscene
+            if (cutscene_start(CUTSCENE_PREPARE_CANNON, cur_obj_nearest_object_with_behavior(bhvCannonClosed))) {
+                save_file_set_cannon_unlocked();
+                pobj->oCappyBobombBuddyState = 4;
+            }
+            break;
+
+        case 4: // Wait for the cannon cutscene to end
+            if (cutscene_update()) {
+                pobj->oCappyBobombBuddyState = 5;
+                pobj->oCappyBobombBuddyTimer = 10;
+            }
+            break;
+
+        case 5: // Start dialog 2
+            if (dialog_start(dialog2Id)) {
+                pobj->oCappyBobombBuddyState = 6;
+            }
+            break;
+
+        case 6: // Wait for the dialog 2 to end
+            if (dialog_update()) {
+                pobj->oCappyBobombBuddyState = 7;
+                pobj->oCappyBobombBuddyTimer = 5;
+            }
+            break;
+
+        case 7: // Release Mario
+            if (mario_unlock(pobj->oMario)) {
+                mario_unpossess_object(pobj->oMario, MARIO_UNPOSSESS_ACT_JUMP_OUT, FALSE, 6);
+                pobj->oCappyBobombBuddyState = 8;
+            }
+            break;
+    }
+}
+
+static void cappy_bobomb_buddy_update(struct PObject *pobj) {
+    switch (pobj->oBobombBuddyRole) {
+        case BOBOMB_BUDDY_ROLE_ADVICE:
+            cappy_bobomb_buddy_advice_update(pobj);
+            break;
+        
+        case BOBOMB_BUDDY_ROLE_CANNON:
+            cappy_bobomb_buddy_cannon_update(pobj);
+            break;
+    }
+}
+
+static void cappy_bobomb_buddy_update_animation_and_sound(struct PObject *pobj) {
+    obj_random_blink(pobj, &pobj->oBobombBuddyBlinkTimer);
+}
+
+static void cappy_bobomb_buddy_set_cappy_values(struct PObject *pobj) {
+    pobj->oCappyVerticalDist = 94.f;
+    pobj->oCappyInitialScale = 120;
+}
+
+//
+// Main loop
+//
+
+const PObjMainLoopFunc cappy_bobomb_buddy_mloop[] = {
+    cappy_bobomb_buddy_update,
+    obj_update_gfx,
+    cappy_bobomb_buddy_update_animation_and_sound,
+    cappy_bobomb_buddy_set_cappy_values,
+    NULL
+};
+
+//
+// Init
+//
+
+s32 cappy_bobomb_buddy_init(struct Object *obj) {
+    obj->oCappyBobombBuddyState = 0;
+    obj->oCappyBobombBuddyTimer = 15;
+    return TRUE;
+}
+
+void cappy_bobomb_buddy_end(UNUSED struct Object *obj) {
+}
+
+f32 cappy_bobomb_buddy_get_top(struct Object *obj) {
+    return 94.f * obj->oScaleY;
+}
\ No newline at end of file
diff --git a/data/smo/capture/capture_bobomb_king.c b/data/smo/capture/capture_bobomb_king.c
new file mode 100644
index 0000000..4ba76f9
--- /dev/null
+++ b/data/smo/capture/capture_bobomb_king.c
@@ -0,0 +1,88 @@
+#include "../smo_c_includes.h"
+
+//
+// Possessed Bob-omb King
+//
+
+static void cappy_bobomb_king_update(struct PObject *pobj) {
+    // Delay
+    if (pobj->oCappyBobombKingTimer > 0) {
+        pobj->oCappyBobombKingTimer--;
+        return;
+    }
+
+    switch (pobj->oCappyBobombKingState) {
+        case 0: // Start dialog
+            if (mario_lock(pobj->oMario) && dialog_start(DIALOG_SMO_KING_BOBOMB)) {
+                play_sound(SOUND_OBJ_KING_BOBOMB_TALK, pobj->header.gfx.cameraToObject);
+                pobj->oCappyBobombKingState = 1;
+            }
+            break;
+
+        case 1: // Wait for the dialog to end
+            if (dialog_update()) {
+                pobj->oCappyBobombKingState = 2;
+                pobj->oCappyBobombKingTimer = 5;
+            }
+            break;
+
+        case 2: // Release Mario
+            if (mario_unlock(pobj->oMario)) {
+                pobj->oCappyBobombKingState = 3;
+                play_sound(SOUND_MARIO_OOOF, pobj->oMarioObj->header.gfx.cameraToObject);
+                mario_unpossess_object(pobj->oMario, MARIO_UNPOSSESS_ACT_GRABBED, FALSE, 15);
+            }
+            break;
+    }
+}
+
+static void cappy_bobomb_king_update_animation_and_sound(struct PObject *pobj) {
+    obj_set_animation_with_accel(pobj, 5, 1.f);
+}
+
+static void cappy_bobomb_king_set_cappy_values(struct PObject *pobj) {
+    pobj->oCappyVerticalDist = 260.f;
+    pobj->oCappyInitialScale = 250;
+}
+
+//
+// Main loop
+//
+
+const PObjMainLoopFunc cappy_bobomb_king_mloop[] = {
+    cappy_bobomb_king_update,
+    obj_update_gfx,
+    cappy_bobomb_king_update_animation_and_sound,
+    cappy_bobomb_king_set_cappy_values,
+    NULL
+};
+
+//
+// Init
+//
+
+s32 cappy_bobomb_king_init(struct Object *obj) {
+    if (obj->oAction != 1 && obj->oAction != 2) {
+        return FALSE;
+    }
+
+    obj->oCappyBobombKingState = 0;
+    obj->oCappyBobombKingTimer = 10;
+    return TRUE;
+}
+
+void cappy_bobomb_king_end(struct Object *obj) {
+    if (obj->oCappyBobombKingState == 3) {
+        obj->oInteractStatus = INT_STATUS_INTERACTED | INT_STATUS_GRABBED_MARIO;
+        obj->oKingBobombUnk88 = 1;
+        obj->oIntangibleTimer = -1;
+        obj->oAction = 3;
+        obj->oSubAction = 0;
+        obj->oMario->interactObj = obj;
+        obj->oMario->usedObj = obj;
+    }
+}
+
+f32 cappy_bobomb_king_get_top(struct Object *obj) {
+    return 260.f * obj->oScaleY;
+}
\ No newline at end of file
diff --git a/data/smo/capture/capture_bullet_bill.c b/data/smo/capture/capture_bullet_bill.c
new file mode 100644
index 0000000..ae432c9
--- /dev/null
+++ b/data/smo/capture/capture_bullet_bill.c
@@ -0,0 +1,261 @@
+#include "../smo_c_includes.h"
+
+//
+// Possessed Bullet Bill explosion
+//
+
+static void cappy_bullet_bill_explosion_attack(struct Object *this) {
+    for (u32 objType = OBJ_LIST_DESTRUCTIVE; objType <= OBJ_LIST_POLELIKE; ++objType) {
+        struct ObjectNode *list = &gObjectLists[objType];
+        struct Object *obj = obj_get_first(list);
+        while (obj != NULL) {
+            if (obj != this) {
+                if (obj_detect_overlap(this, obj, OBJ_OVERLAP_FLAG_HITBOX, OBJ_OVERLAP_FLAG_HITBOX)) {
+                    switch (obj->oInteractType) {
+                        case INTERACT_KOOPA:
+                        case INTERACT_BOUNCE_TOP:
+                        case INTERACT_BOUNCE_TOP2:
+                        case INTERACT_HIT_FROM_BELOW: {
+                            obj->oInteractStatus = (0x02 | INT_STATUS_INTERACTED | INT_STATUS_WAS_ATTACKED);
+                        } break;
+
+                        case INTERACT_BULLY: {
+                            f32 knockback = 3600.f / obj->hitboxRadius;
+                            s16 angle = obj_get_object1_angle_yaw_to_object2(this, obj);
+                            obj->oFaceAngleYaw = angle + 0x8000;
+                            obj->oMoveAngleYaw = angle;
+                            obj->oForwardVel = knockback;
+                            obj->oInteractStatus = (0x02 | INT_STATUS_INTERACTED | INT_STATUS_WAS_ATTACKED);
+                            play_sound(SOUND_OBJ_BULLY_METAL, obj->header.gfx.cameraToObject);
+                        } break;
+
+                        case INTERACT_BREAKABLE: {
+                            obj->oInteractStatus = (0x02 | INT_STATUS_INTERACTED | INT_STATUS_WAS_ATTACKED);
+                            set_camera_shake_from_hit(SHAKE_ATTACK);
+                        } break;
+
+                        case INTERACT_GRABBABLE: {
+                            if (obj->oInteractionSubtype & INT_SUBTYPE_KICKABLE) {
+                                obj->oInteractStatus = (0x02 | INT_STATUS_INTERACTED | INT_STATUS_WAS_ATTACKED);
+                            }
+                            if (obj->behavior == bhvBreakableBoxSmall) {
+                                obj->oNumLootCoins = 3;
+                                obj_spawn_white_puff(obj, SOUND_GENERAL_BREAK_BOX);
+                                obj_spawn_triangle_break_particles(obj, 20, 138, 0.7f, 3);
+                                obj_spawn_loot_yellow_coins(obj, 3, 20.0f);
+                                obj_mark_for_deletion(obj);
+                            }
+                        } break;
+                    }
+                }
+            }
+            obj = obj_get_next(list, obj);
+        }
+    }
+}
+
+void bhv_cappy_bullet_bill_explosion_loop(void) {
+    if (gCurrentObject->oTimer >= 9) {
+        spawn_object(gCurrentObject, MODEL_SMOKE, bhvBobombBullyDeathSmoke);
+        obj_mark_for_deletion(gCurrentObject);
+        return;
+    }
+
+    f32 scale = (f32) gCurrentObject->oTimer / 4.f + 1.0f;
+    gCurrentObject->header.gfx.scale[0] = scale;
+    gCurrentObject->header.gfx.scale[1] = scale;
+    gCurrentObject->header.gfx.scale[2] = scale;
+    gCurrentObject->hitboxRadius = 250.f;
+    gCurrentObject->hitboxHeight = 250.f;
+    gCurrentObject->hitboxDownOffset = 0.f;
+    gCurrentObject->oOpacity = MAX(0, 0xFF - (0x1C * gCurrentObject->oTimer));
+    gCurrentObject->oAnimState++;
+    gCurrentObject->oIntangibleTimer = 0;
+    cappy_bullet_bill_explosion_attack(gCurrentObject);
+}
+
+const BehaviorScript bhvCappyBulletBillExplosion[] = {
+    0x00020000,
+    0x110100C1,
+    0x21000000,
+    0x08000000,
+    0x0C000000, (uintptr_t) (bhv_cappy_bullet_bill_explosion_loop),
+    0x09000000, 
+};
+
+//
+// Possessed Bullet bill
+//
+
+static void cappy_bullet_bill_set_properties(struct PObject *pobj) {
+    pobj->hitboxRadius = pobj->cdHitboxRadius;
+    pobj->hitboxHeight = pobj->cdHitboxHeight;
+    pobj->hitboxDownOffset = pobj->cdHitboxDownOffset;
+    pobj->oWallHitboxRadius = pobj->cdWallHitboxRadius;
+    pobj->oProperties = 0;
+    pobj->oProperties |= POBJ_PROP_ABOVE_WATER;
+    pobj->oProperties |= POBJ_PROP_INVULNERABLE;
+    pobj->oProperties |= POBJ_PROP_IMMUNE_TO_FIRE;
+    pobj->oProperties |= POBJ_PROP_IMMUNE_TO_LAVA;
+    pobj->oProperties |= POBJ_PROP_IMMUNE_TO_QUICKSANDS;
+    pobj->oProperties |= POBJ_PROP_RESIST_STRONG_WINDS;
+    pobj->oProperties |= POBJ_PROP_ATTACK;
+}
+
+static void cappy_bullet_bill_process_inputs(struct PObject *pobj) {
+    smo_capture_set_camera_behind_mario(pobj);
+
+    // Inputs
+    if (pobj->oUnresponsiveTimer == 0) {
+        s32 pitch = (s32)(pobj->oStickY * 0x3000);
+        s32 yaw = (s32)(pobj->oStickX * 0x200);
+        s32 facePitch = pitch - approach_s32((s16)(pitch - pobj->oFaceAnglePitch), 0, 0x200, 0x200);
+        s32 faceYaw = pobj->oFaceAngleYaw - yaw;
+        f32 fvel = (pobj->oButtonDown & B_BUTTON ? pobj->cdDashSpeed : pobj->cdWalkSpeed);
+
+        pobj->oVelX = coss(facePitch) * sins(faceYaw) * fvel;
+        pobj->oVelY = -sins(facePitch) * fvel;
+        pobj->oVelZ = coss(facePitch) * coss(faceYaw) * fvel;
+        pobj->oFaceAngleYaw = faceYaw;
+        pobj->oFaceAnglePitch = facePitch;
+        pobj->oFaceAngleRoll = 0;
+        pobj->oMoveAngleYaw = faceYaw;
+        pobj->oMoveAnglePitch = facePitch;
+        pobj->oMoveAngleRoll = 0;
+        if (pobj->oButtonDown & B_BUTTON) {
+            pobj->oProperties |= POBJ_PROP_STRONG_ATTACK;
+        }
+    } else {
+        pobj->oUnresponsiveTimer--;
+    }
+}
+
+static void cappy_bullet_bill_update_pos(struct PObject *pobj) {
+    obj_update_pos_and_vel(pobj, pobj->oProperties & POBJ_PROP_MOVE_THROUGH_VC_WALLS, obj_is_on_ground(pobj),  &pobj->oSquishedTimer);
+    pobj_handle_special_floors(pobj);
+}
+
+static void cappy_bullet_bill_process_interactions(struct PObject *pobj) {
+    POBJ_INTERACTIONS_BEGIN;
+    POBJ_INTERACTIONS_END;
+}
+
+static void cappy_bullet_bill_check_wall_hit(struct PObject *pobj) {
+    if (pobj->oWall) {
+
+        // Bullet dash
+        if (pobj->oProperties & POBJ_PROP_STRONG_ATTACK) {
+        
+            // Dynamic wall
+            struct Object *obj = pobj->oWall->object;
+            if (obj) {
+                
+                // Wall behind WF tower
+                if (obj->behavior == bhvTowerDoor) {
+                    obj_explode(obj, SOUND_GENERAL_WALL_EXPLOSION);
+                    obj->oInteractStatus = INT_STATUS_INTERACTED;
+                }
+
+                // Kickable board
+                if (obj->behavior == bhvKickableBoard) {
+                    obj->oAction = 2;
+                    obj->oInteractStatus = INT_STATUS_INTERACTED;
+                }
+
+                // WF coin cannon wall
+                if (obj->behavior == bhvWfBreakableWallLeft) {
+                    obj->oNumLootCoins = 1;
+                    obj_explode(obj, SOUND_GENERAL_WALL_EXPLOSION);
+                    obj->oInteractStatus = INT_STATUS_INTERACTED;
+                }
+
+                // WF star cannon wall
+                if (obj->behavior == bhvWfBreakableWallRight) {
+                    play_puzzle_jingle();
+                    obj_explode(obj, SOUND_GENERAL_WALL_EXPLOSION);
+                    obj->oInteractStatus = INT_STATUS_INTERACTED;
+                }
+            }
+
+            // BOOM
+            set_environmental_camera_shake(SHAKE_ENV_EXPLOSION);
+            struct Object *explosion = spawn_object(pobj, MODEL_EXPLOSION, bhvCappyBulletBillExplosion);
+            explosion->oFlags |= OBJ_FLAG_UPDATE_GFX_POS_AND_ANGLE;
+            explosion->oAnimState = -1;
+            explosion->oGraphYOffset += 100.0f;
+            explosion->oOpacity = 255;
+            explosion->oIntangibleTimer = 0;
+            set_environmental_camera_shake(SHAKE_ENV_EXPLOSION);
+        } else {
+        
+            // Poof
+            obj_spawn_white_puff(pobj, 0);
+        }
+
+        create_sound_spawner(SOUND_GENERAL2_BOBOMB_EXPLOSION);
+        pobj->oCappyBulletBillDestroyed = TRUE;
+        mario_unpossess_object(pobj->oMario, MARIO_UNPOSSESS_ACT_JUMP_OUT, FALSE, 6);
+    }
+}
+
+static void cappy_bullet_bill_update_animation_and_sound(struct PObject *pobj) {
+    if (pobj->oProperties & POBJ_PROP_STRONG_ATTACK) {
+        obj_make_step_sound_and_particle(pobj, &pobj->oWalkDistance, 0.f, 0.f, -1, OBJ_STEP_PARTICLE_FIRE);
+    } else {
+        obj_make_step_sound_and_particle(pobj, &pobj->oWalkDistance, 0.f, 0.f, -1, OBJ_STEP_PARTICLE_SMOKE);
+    }
+}
+
+static void cappy_bullet_bill_set_cappy_values(struct PObject *pobj) {
+    pobj->oCappyForwardDist  = 50.f;
+    pobj->oCappyVerticalDist = 200.f;
+    pobj->oCappyInitialScale = 400;
+}
+
+//
+// Main loop
+//
+
+const PObjMainLoopFunc cappy_bullet_bill_mloop[] = {
+    cappy_bullet_bill_set_properties,
+    cappy_bullet_bill_process_inputs,
+    cappy_bullet_bill_update_pos,
+    cappy_bullet_bill_process_interactions,
+    cappy_bullet_bill_check_wall_hit,
+    obj_update_gfx,
+    cappy_bullet_bill_update_animation_and_sound,
+    cappy_bullet_bill_set_cappy_values,
+    NULL
+};
+
+//
+// Init
+//
+
+s32 cappy_bullet_bill_init(struct Object *obj) {
+    if (obj->oAction != 2 || obj->oTimer < 50) {
+        return FALSE;
+    }
+
+    obj->oCappyBulletBillInitialHomeX = obj->oHomeX; 
+    obj->oCappyBulletBillInitialHomeY = obj->oHomeY; 
+    obj->oCappyBulletBillInitialHomeZ = obj->oHomeZ;
+    obj->oCappyBulletBillDestroyed = FALSE;
+    return TRUE;
+}
+
+void cappy_bullet_bill_end(struct Object *obj) {
+    if (obj->oCappyBulletBillDestroyed) {
+        obj->oAction = 0;
+        obj->oTimer = 0;
+    }
+    obj->oHomeX = obj->oCappyBulletBillInitialHomeX;
+    obj->oHomeY = obj->oCappyBulletBillInitialHomeY;
+    obj->oHomeZ = obj->oCappyBulletBillInitialHomeZ;
+    obj->oFaceAnglePitch = 0;
+    obj->oMoveAnglePitch = 0;
+}
+
+f32 cappy_bullet_bill_get_top(struct Object *obj) {
+    return 200.f * obj->oScaleY;
+}
\ No newline at end of file
diff --git a/data/smo/capture/capture_chain_chomp.c b/data/smo/capture/capture_chain_chomp.c
new file mode 100644
index 0000000..64f60f1
--- /dev/null
+++ b/data/smo/capture/capture_chain_chomp.c
@@ -0,0 +1,451 @@
+#include "../smo_c_includes.h"
+#include "actors/group14.h"
+
+//
+// Chain Chomp parts
+// (Code from chain_chomp.inc.c, adapted to the situation)
+//
+
+static void chain_chomp_update_chain_parts(struct Object* obj, s32 isFreed) {
+    struct Object *pivot = obj->parentObj;
+
+    // Segment 0 connects the pivot to the chain chomp itself
+    struct ChainSegment *seg0 = &obj->oChainChompSegments[0];
+    seg0->posX = obj->oPosX - pivot->oPosX;
+    seg0->posY = obj->oPosY - pivot->oPosY;
+    seg0->posZ = obj->oPosZ - pivot->oPosZ;
+    obj->oChainChompDistToPivot = sqrtf(sqr(seg0->posX) + sqr(seg0->posY) + sqr(seg0->posZ));
+
+    // If the chain is fully stretched
+    f32 maxDistToPivot = obj->oChainChompMaxDistFromPivotPerChainPart * 5.f;
+    if (obj->oChainChompDistToPivot > maxDistToPivot) {
+        f32 ratio = maxDistToPivot / obj->oChainChompDistToPivot;
+        obj->oChainChompDistToPivot = maxDistToPivot;
+        seg0->posX *= ratio;
+        seg0->posY *= ratio;
+        seg0->posZ *= ratio;
+
+        // If freed, move pivot like the chain chomp is pulling it along
+        if (isFreed) {
+            pivot->oVelY -= 4.f;
+            pivot->oPosX = obj->oPosX - seg0->posX;
+            pivot->oPosZ = obj->oPosZ - seg0->posZ;
+            pivot->oPosY += pivot->oVelY;
+            struct Surface *floor = NULL;
+            f32 floorY = find_floor(pivot->oPosX, pivot->oPosY, pivot->oPosZ, &floor);
+            if (floor != NULL) {
+                if (pivot->oPosY <= floorY) {
+                    pivot->oPosY = floorY;
+                    pivot->oVelY = 0.f;
+                }
+            } else {
+                pivot->oPosY = obj->oPosY;
+                pivot->oVelY = 0.f;
+            }
+        }
+    }
+
+    // Segments 1+ connect the pivot to chain part i
+    // 1 is closest to the chain chomp
+    // 4 is closest to the pivot
+    for (s32 i = 1; i <= 4; i++) {
+        struct ChainSegment *prevSegment = &obj->oChainChompSegments[i - 1];
+        struct ChainSegment *segment = &obj->oChainChompSegments[i];
+
+        // Apply gravity (using pitch for velY)
+        segment->pitch -= 4.f;
+        segment->posY += segment->pitch;
+        f32 sx = segment->posX + pivot->oPosX;
+        f32 sy = segment->posY + pivot->oPosY;
+        f32 sz = segment->posZ + pivot->oPosZ;
+        struct Surface *floor = NULL;
+        f32 floorY = find_floor(sx, sy, sz, &floor);
+        if (floor != NULL) {
+            if (sy <= floorY) {
+                segment->posY = floorY - pivot->oPosY;
+                segment->pitch = 0;
+            }
+        } else {
+            floorY = find_floor(sx, pivot->oPosY, sz, &floor);
+            if (floor != NULL) {
+                if (sy <= floorY) {
+                    segment->posY = floorY - pivot->oPosY;
+                    segment->pitch = 0;
+                }
+            } else {
+                segment->posY = 0;
+                segment->pitch = 0;
+            }
+        }
+
+        // Distance to previous chain part (so that the tail follows the chomp)
+        f32 offsetX = segment->posX - prevSegment->posX;
+        f32 offsetY = segment->posY - prevSegment->posY;
+        f32 offsetZ = segment->posZ - prevSegment->posZ;
+        f32 offset = sqrtf(sqr(offsetX) + sqr(offsetY) + sqr(offsetZ));
+        if (offset > obj->oChainChompMaxDistFromPivotPerChainPart) {
+            offset = obj->oChainChompMaxDistFromPivotPerChainPart / offset;
+            offsetX *= offset;
+            offsetY *= offset;
+            offsetZ *= offset;
+        }
+
+        // Distance to pivot (so that it stretches when the chomp moves far from the wooden post)
+        offsetX += prevSegment->posX;
+        offsetY += prevSegment->posY;
+        offsetZ += prevSegment->posZ;
+        offset = sqrtf(sqr(offsetX) + sqr(offsetY) + sqr(offsetZ));
+        f32 maxTotalOffset = obj->oChainChompMaxDistFromPivotPerChainPart * (5 - i);
+        if (offset > maxTotalOffset) {
+            offset = maxTotalOffset / offset;
+            offsetX *= offset;
+            offsetY *= offset;
+            offsetZ *= offset;
+        }
+
+        // Segment final pos
+        segment->posX = offsetX;
+        segment->posY = offsetY;
+        segment->posZ = offsetZ;
+    }
+}
+
+//
+// Freed Chain Chomp
+//
+
+enum {
+    CHAIN_CHOMP_FREED_STATE_WANDERING,
+    CHAIN_CHOMP_FREED_STATE_CHASING_MARIO,
+};
+
+static struct ObjectHitbox sChainChompFreedHitbox = {
+    /* interactType: */ INTERACT_MR_BLIZZARD,
+    /* downOffset: */ 0,
+    /* damageOrCoinValue: */ 4,
+    /* health: */ 1,
+    /* numLootCoins: */ 0,
+    /* radius: */ 80,
+    /* height: */ 160,
+    /* hurtboxRadius: */ 80,
+    /* hurtboxHeight: */ 160,
+};
+
+static void bhv_chain_chomp_freed_init() {
+    gCurrentObject->oFlags = (OBJ_FLAG_COMPUTE_ANGLE_TO_MARIO | OBJ_FLAG_ACTIVE_FROM_AFAR | OBJ_FLAG_COMPUTE_DIST_TO_MARIO | OBJ_FLAG_SET_FACE_YAW_TO_MOVE_YAW | OBJ_FLAG_UPDATE_GFX_POS_AND_ANGLE);
+    gCurrentObject->oGraphYOffset = 240.f;
+    gCurrentObject->oWallHitboxRadius = 120.f;
+    gCurrentObject->oGravity = -4.f;
+    gCurrentObject->oBounciness = -0.5f;
+    gCurrentObject->oFriction = 10.f;
+    gCurrentObject->oBuoyancy = 2.f;
+    gCurrentObject->oChainChompMaxDistFromPivotPerChainPart = 750.f / 5.f;
+    gCurrentObject->oChainChompFreedState = CHAIN_CHOMP_FREED_STATE_WANDERING;
+    gCurrentObject->oChainChompFreedTimer = 0;
+    gCurrentObject->oChainChompFreedAngle = 0;
+    gCurrentObject->header.gfx.scale[0] = 2.f;
+    gCurrentObject->header.gfx.scale[1] = 2.f;
+    gCurrentObject->header.gfx.scale[2] = 2.f;
+    obj_set_hitbox(gCurrentObject, &sChainChompFreedHitbox);
+    cur_obj_set_pos_to_home();
+}
+
+static s32 chain_chomp_freed_is_ready(struct Object *obj) {
+    if (obj->oChainChompFreedTimer > 0) {
+        obj->oVelX *= 0.90f;
+        obj->oVelZ *= 0.90f;
+        obj->oChainChompFreedTimer--;
+        return FALSE;
+    }
+    return TRUE;
+}
+
+static void bhv_chain_chomp_freed_wander(struct Object* obj) {
+    if (!chain_chomp_freed_is_ready(obj)) {
+        return;
+    }
+
+    if (obj_is_on_ground(obj)) {
+        if (obj->oDistanceToMario <= 1000.f) {
+
+            // Start chasing Mario
+            obj->oVelX = 0;
+            obj->oVelY = 48.f;
+            obj->oVelZ = 0;
+            obj->oForwardVel = 0;
+            obj->oFaceAngleYaw = obj->oAngleToMario;
+            obj->oMoveAngleYaw = obj->oAngleToMario;
+            obj->oFloor = NULL;
+            obj->oChainChompFreedTimer = 45;
+            obj->oChainChompFreedState = CHAIN_CHOMP_FREED_STATE_CHASING_MARIO;
+            play_sound(SOUND_GENERAL_CHAIN_CHOMP2, obj->header.gfx.cameraToObject);
+        } else {
+
+            // Make a small hop
+            s16 nextAngle = (s16)(obj->oChainChompFreedAngle + (random_u16() & 0x3FFF) - 0x2000);
+            obj_set_forward_vel(obj, nextAngle, 1.f, 12.f);
+            obj->oVelY = 36.f;
+            obj->oFloor = NULL;
+            obj->oFaceAngleYaw = nextAngle;
+            obj->oMoveAngleYaw = nextAngle;
+            obj->oChainChompFreedAngle = nextAngle;
+            play_sound(SOUND_GENERAL_CHAIN_CHOMP1, obj->header.gfx.cameraToObject);
+        }
+    }
+}
+
+static void bhv_chain_chomp_freed_chase(struct Object *obj) {
+    obj->oFaceAngleYaw = obj->oAngleToMario;
+    obj->oMoveAngleYaw = obj->oAngleToMario;
+
+    if (obj_is_on_ground(obj)) {
+        if (obj->oDistanceToMario > 1500.f) {
+
+            // Stop chasing Mario
+            obj->oChainChompFreedTimer = 30;
+            obj->oChainChompFreedState = CHAIN_CHOMP_FREED_STATE_WANDERING;
+        } else {
+
+            // Make a fast hop
+            obj_set_forward_vel(obj, obj->oAngleToMario, 1.f, 28.f);
+            obj->oVelY = 20.f;
+            obj->oFloor = NULL;
+            obj->oChainChompFreedAngle = obj->oAngleToMario;
+            play_sound(SOUND_GENERAL_CHAIN_CHOMP1, obj->header.gfx.cameraToObject);
+        }
+    }
+}
+
+static void bhv_chain_chomp_freed_update() {
+    switch (gCurrentObject->oChainChompFreedState) {
+        case CHAIN_CHOMP_FREED_STATE_WANDERING:
+            bhv_chain_chomp_freed_wander(gCurrentObject);
+            break;
+
+        case CHAIN_CHOMP_FREED_STATE_CHASING_MARIO:
+            bhv_chain_chomp_freed_chase(gCurrentObject);
+            break;
+    }
+
+    if (gCurrentObject->oInteractStatus & (INT_STATUS_INTERACTED | INT_STATUS_ATTACKED_MARIO)) {
+        gCurrentObject->oChainChompFreedTimer = 90;
+        gCurrentObject->oChainChompFreedState = CHAIN_CHOMP_FREED_STATE_WANDERING;
+        gCurrentObject->oInteractStatus = 0;
+    }
+
+    gCurrentObject->oVelY = MAX(gCurrentObject->oVelY + gCurrentObject->oGravity, -75.f);
+    obj_update_pos_and_vel(gCurrentObject, FALSE, obj_is_on_ground(gCurrentObject), NULL);
+    obj_set_animation_with_accel(gCurrentObject, 0, 1.f);
+    chain_chomp_update_chain_parts(gCurrentObject, TRUE);
+}
+
+const BehaviorScript bhvChainChompFreed[] = {
+    0x00040000,
+    0x1E000000,
+    0x27260000,
+    (uintptr_t) chain_chomp_seg6_anims_06025178,
+    0x28000000,
+    0x2D000000,
+    0x0C000000,
+    (uintptr_t) bhv_chain_chomp_freed_init,
+    0x08000000,
+    0x0C000000,
+    (uintptr_t) bhv_chain_chomp_freed_update,
+    0x09000000,
+};
+
+//
+// Possessed Chain Chomp
+//
+
+static void cappy_chain_chomp_set_properties(struct PObject *pobj) {
+    pobj->hitboxRadius = pobj->cdHitboxRadius;
+    pobj->hitboxHeight = pobj->cdHitboxHeight;
+    pobj->hitboxDownOffset = pobj->cdHitboxDownOffset;
+    pobj->oWallHitboxRadius = pobj->cdWallHitboxRadius;
+    pobj->oProperties = 0;
+    pobj->oProperties |= POBJ_PROP_ABOVE_WATER;
+    pobj->oProperties |= POBJ_PROP_INVULNERABLE;
+    pobj->oProperties |= POBJ_PROP_UNPUSHABLE;
+    pobj->oProperties |= POBJ_PROP_IMMUNE_TO_FIRE;
+    pobj->oProperties |= POBJ_PROP_IMMUNE_TO_LAVA;
+    pobj->oProperties |= POBJ_PROP_IMMUNE_TO_QUICKSANDS;
+    pobj->oProperties |= POBJ_PROP_RESIST_STRONG_WINDS;
+    pobj->oProperties |= POBJ_PROP_ATTACK;
+    if (pobj->oCappyChainChompIsBiting) {
+        pobj->oProperties |= POBJ_PROP_STRONG_ATTACK;
+    }
+}
+
+static void cappy_chain_chomp_process_inputs(struct PObject *pobj) {
+    pobj_decelerate(pobj);
+    pobj_apply_gravity(pobj);
+
+    // Inputs
+    if (pobj->oUnresponsiveTimer == 0) {
+        pobj->oCappyChainChompIsBiting = FALSE;
+
+        // Walk
+        f32 hvel = pobj->cdWalkSpeed;
+        if (pobj->oStickMag > 0) {
+            s32 faceYaw = pobj->oStickYaw - approach_s32((s16)(pobj->oStickYaw - pobj->oFaceAngleYaw), 0, 0x1000, 0x1000);
+            obj_set_forward_vel(pobj, faceYaw, pobj->oStickMag, hvel);
+            pobj->oFaceAngleYaw = faceYaw;
+            pobj->oFaceAnglePitch = 0;
+            pobj->oFaceAngleRoll = 0;
+            pobj->oMoveAngleYaw = faceYaw;
+            pobj->oMoveAnglePitch = 0;
+            pobj->oMoveAngleRoll = 0;
+        }
+
+        // Jump
+        if (obj_is_on_ground(pobj)) {
+            if (pobj->oButtonDown & A_BUTTON) {
+                pobj->oVelY = pobj->cdJumpVelocity * 1.5f;
+                pobj->oFloor = NULL;
+                play_sound(SOUND_OBJ_GOOMBA_ALERT, pobj->header.gfx.cameraToObject);
+                play_sound(SOUND_GENERAL_CHAIN_CHOMP1, pobj->header.gfx.cameraToObject);
+            } else if (pobj->oForwardVel > pobj->cdWalkSpeed / 4.f) {
+                pobj->oVelY = pobj->cdJumpVelocity;
+                pobj->oFloor = NULL;
+                play_sound(SOUND_GENERAL_CHAIN_CHOMP1, pobj->header.gfx.cameraToObject);
+            }
+        }
+
+        // Bite
+        if (pobj->oButtonPressed & B_BUTTON) {
+            obj_set_forward_vel(pobj, pobj->oFaceAngleYaw, 1.f, pobj->cdDashSpeed);
+            pobj->oUnresponsiveTimer = 30;
+            play_sound(SOUND_GENERAL_CHAIN_CHOMP2, pobj->header.gfx.cameraToObject);
+            pobj->oCappyChainChompIsBiting = TRUE;
+        }
+    } else {
+        pobj->oUnresponsiveTimer--;
+    }
+}
+
+struct Object *get_chain_chomp_wooden_post(struct PObject *pobj) {
+    struct ObjectNode *list = &gObjectLists[OBJ_LIST_SURFACE];
+    struct Object *obj = obj_get_first(list);
+    while (obj != NULL) {
+        if (obj->behavior == bhvWoodenPost && obj->parentObj == pobj) {
+            return obj;
+        }
+        obj = obj_get_next(list, obj);
+    }
+    return NULL;
+}
+
+static void cappy_chain_chomp_break_free(struct PObject *pobj) {
+    struct Object *obj = get_chain_chomp_wooden_post(pobj);
+    if (obj != NULL) {
+        set_camera_shake_from_point(SHAKE_POS_SMALL, pobj->oPosX, pobj->oPosY, pobj->oPosZ);
+        obj_spawn_white_puff(obj, SOUND_GENERAL_WALL_EXPLOSION);
+        obj_spawn_triangle_break_particles(obj, 24, 0x8A, 2.0f, 4);
+        obj_mark_for_deletion(obj);
+        pobj->oCappyChainChompIsFreed = TRUE;
+    }
+}
+
+static void cappy_chain_chomp_update_pos(struct PObject *pobj) {
+    obj_update_pos_and_vel(pobj, pobj->oProperties & POBJ_PROP_MOVE_THROUGH_VC_WALLS, obj_is_on_ground(pobj), &pobj->oSquishedTimer);
+    pobj_handle_special_floors(pobj);
+
+    // If not freed, restrict position
+    if (!pobj->oCappyChainChompIsFreed) {
+        f32 dx = pobj->oPosX - pobj->oCappyChainChompPivotX;
+        f32 dz = pobj->oPosZ - pobj->oCappyChainChompPivotZ;
+        f32 dist = sqrtf(sqr(dx) + sqr(dz));
+        if (dist > 750.f) {
+
+            // Break free if enough speed
+            if (pobj->oForwardVel > 60.f) { 
+                cappy_chain_chomp_break_free(pobj);
+            } else {
+                dx *= (750.f / dist);
+                dz *= (750.f / dist);
+                pobj->oPosX = pobj->oCappyChainChompPivotX + dx;
+                pobj->oPosZ = pobj->oCappyChainChompPivotZ + dz;
+                pobj->oHomeX = pobj->oPosX;
+                pobj->oHomeZ = pobj->oPosZ;
+            }
+        }
+    }
+
+    // Break chain chomp gate if hit strong enough
+    if (pobj->oProperties & POBJ_PROP_STRONG_ATTACK) {
+        if (pobj->oWall && pobj->oWall->object && pobj->oWall->object->behavior == bhvChainChompGate) {
+            pobj->oChainChompHitGate = TRUE;
+            play_puzzle_jingle();
+        }
+    }
+}
+
+static void cappy_chain_chomp_process_interactions(struct PObject *pobj) {
+    POBJ_INTERACTIONS_BEGIN;
+    POBJ_INTERACTIONS_END;
+}
+
+static void cappy_chain_chomp_update_animation_and_sound(struct PObject *pobj) {
+    obj_set_animation_with_accel(pobj, 0, (pobj->oCappyChainChompIsBiting ? 2.f : 1.f));
+}
+
+static void cappy_chain_chomp_update_chain_parts(struct PObject *pobj) {
+    chain_chomp_update_chain_parts(pobj, pobj->oCappyChainChompIsFreed);
+}
+
+static void cappy_chain_chomp_set_cappy_values(struct PObject *pobj) {
+    pobj->oCappyVerticalDist = 245.f;
+    pobj->oCappyInitialScale = 200;
+}
+
+//
+// Main loop
+//
+
+const PObjMainLoopFunc cappy_chain_chomp_mloop[] = {
+    cappy_chain_chomp_process_inputs,
+    cappy_chain_chomp_set_properties,
+    cappy_chain_chomp_update_pos,
+    cappy_chain_chomp_process_interactions,
+    obj_update_gfx,
+    cappy_chain_chomp_update_animation_and_sound,
+    cappy_chain_chomp_update_chain_parts,
+    cappy_chain_chomp_set_cappy_values,
+    NULL
+};
+
+//
+// Init
+//
+
+s32 cappy_chain_chomp_init(struct Object* obj) {
+    if (obj->behavior == bhvChainChomp) {
+        obj->oCappyChainChompPivotX = obj->oHomeX;
+        obj->oCappyChainChompPivotZ = obj->oHomeZ;
+        obj->oCappyChainChompIsFreed = FALSE;
+    } else { // Freed
+        obj->oCappyChainChompIsFreed = TRUE;
+    }
+    obj->oCappyChainChompIsBiting = FALSE;
+    obj->oChainChompMaxDistFromPivotPerChainPart = 750.f / 5.f;
+    return TRUE;
+}
+
+void cappy_chain_chomp_end(struct Object *obj) {
+    if (obj->behavior == bhvChainChomp) { 
+        if (obj->oCappyChainChompIsFreed) { // If freed, sets up a new behavior
+            obj->behavior = bhvChainChompFreed;
+            obj->curBhvCommand = bhvChainChompFreed;
+            obj->bhvStackIndex = 0;
+        } else {
+            obj->oHomeX = obj->oCappyChainChompPivotX;
+            obj->oHomeZ = obj->oCappyChainChompPivotZ;
+        }
+    }
+    obj->oWallHitboxRadius = 0.f;
+}
+
+f32 cappy_chain_chomp_get_top(struct Object *obj) {
+    return 245.f * obj->oScaleY;
+}
diff --git a/data/smo/capture/capture_goomba.c b/data/smo/capture/capture_goomba.c
new file mode 100644
index 0000000..00270bc
--- /dev/null
+++ b/data/smo/capture/capture_goomba.c
@@ -0,0 +1,190 @@
+#include "../smo_c_includes.h"
+
+//
+// Goomba stack
+//
+
+#define CAPPY_GOOMBA_STACK_MAX_COUNT    7
+
+static const uintptr_t bhvGoombaStack[] = {
+    0x08000000, 
+    0x09000000
+};
+
+static void goomba_fix(struct Object *obj) {
+
+    // Goomba triplet spawner
+    if (obj->parentObj != obj) {
+
+        // Mark the goomba as dead inside the triplet
+        set_object_respawn_info_bits(obj->parentObj, (obj->oBehParams2ndByte & GOOMBA_BP_TRIPLET_FLAG_MASK) >> 2);
+        obj->parentObj->oBehParams = obj->parentObj->oBehParams | (obj->oBehParams2ndByte & GOOMBA_BP_TRIPLET_FLAG_MASK) << 6;
+
+        // Set the goomba as a standalone goomba
+        obj->oBehParams = (obj->oGoombaSize & GOOMBA_BP_SIZE_MASK) << 16;
+        obj->oBehParams2ndByte = (obj->oGoombaSize & GOOMBA_BP_SIZE_MASK);
+        obj->parentObj = obj;
+        obj->prevObj = NULL;
+    }
+}
+
+static void add_goomba_to_stack(struct PObject* pobj, struct Object *obj) {
+    s32 i = pobj->oCappyGoombaStackCount;
+    pobj->oCappyGoombaStackCurOffset(i) = (s16)((s64)(obj->curBhvCommand) - (s64)(bhvGoomba));
+    pobj->oCappyGoombaStackStkIndex(i) = (s16)(obj->bhvStackIndex);
+    pobj->oCappyGoombaStackObject(i) = obj;
+    pobj->oCappyGoombaStackCount++;
+
+    obj->behavior = bhvGoombaStack;
+    obj->curBhvCommand = bhvGoombaStack;
+    goomba_fix(obj);
+}
+
+void cappy_goomba_update_goomba_stack(struct PObject *pobj) {
+    for (s32 i = 0; i != pobj->oCappyGoombaStackCount; ++i) {
+        struct Object *obj = pobj->oCappyGoombaStackObject(i);
+        obj->oPosX = pobj->oPosX;
+        obj->oPosY = pobj->oPosY + pobj->cdHitboxHeight * (i + 1);
+        obj->oPosZ = pobj->oPosZ;
+        obj->oHomeX = pobj->oPosX;
+        obj->oHomeY = pobj->oPosY;
+        obj->oHomeZ = pobj->oPosZ;
+        obj->oFaceAnglePitch = pobj->oFaceAnglePitch;
+        obj->oFaceAngleYaw = pobj->oFaceAngleYaw;
+        obj->oFaceAngleRoll = pobj->oFaceAngleRoll;
+        obj->oMoveAnglePitch = pobj->oMoveAnglePitch;
+        obj->oMoveAngleYaw = pobj->oMoveAngleYaw;
+        obj->oMoveAngleRoll = pobj->oMoveAngleRoll;
+        obj->header.gfx.pos[0] = obj->oPosX;
+        obj->header.gfx.pos[1] = obj->oPosY; 
+        obj->header.gfx.pos[2] = obj->oPosZ;
+        obj->header.gfx.angle[0] = obj->oFaceAnglePitch;
+        obj->header.gfx.angle[1] = obj->oFaceAngleYaw;
+        obj->header.gfx.angle[2] = obj->oFaceAngleRoll;
+        obj->header.gfx.scale[0] = pobj->header.gfx.scale[0];
+        obj->header.gfx.scale[1] = pobj->header.gfx.scale[1];
+        obj->header.gfx.scale[2] = pobj->header.gfx.scale[2];
+        obj_set_animation_with_accel(obj, 0, 1.f);
+        obj_update_blink_state(obj, &obj->oGoombaBlinkTimer, 30, 50, 5);
+    }
+}
+
+//
+// Possessed Goomba
+//
+
+static void cappy_goomba_set_properties(struct PObject *pobj) {
+    pobj->hitboxRadius = pobj->cdHitboxRadius;
+    pobj->hitboxHeight = pobj->cdHitboxHeight * (pobj->oCappyGoombaStackCount + 1);
+    pobj->hurtboxRadius = 0;
+    pobj->hurtboxHeight = 0;
+    pobj->hitboxDownOffset = pobj->cdHitboxDownOffset;
+    pobj->oWallHitboxRadius = pobj->cdWallHitboxRadius;
+    pobj->oProperties = 0;
+    pobj->oProperties |= POBJ_PROP_ABOVE_WATER;
+}
+
+static void cappy_goomba_process_inputs(struct PObject *pobj) {
+    pobj_decelerate(pobj);
+    pobj_apply_gravity(pobj);
+
+    // Inputs
+    if (pobj->oUnresponsiveTimer == 0) {
+
+        // Walk
+        f32 hvel = ((pobj->oButtonDown & B_BUTTON) ? pobj->cdRunSpeed : pobj->cdWalkSpeed);
+        if (pobj->oStickMag > 0) {
+            s32 faceYaw = pobj->oStickYaw - approach_s32((s16)(pobj->oStickYaw - pobj->oFaceAngleYaw), 0, 0x1000, 0x1000);
+            obj_set_forward_vel(pobj, faceYaw, pobj->oStickMag, hvel);
+            pobj->oFaceAngleYaw = faceYaw;
+            pobj->oFaceAnglePitch = 0;
+            pobj->oFaceAngleRoll = 0;
+            pobj->oMoveAngleYaw = faceYaw;
+            pobj->oMoveAnglePitch = 0;
+            pobj->oMoveAngleRoll = 0;
+        }
+
+        // Jump
+        if ((pobj->oButtonPressed & A_BUTTON) && obj_is_on_ground(pobj)) {
+            pobj->oVelY = pobj->cdJumpVelocity;
+            pobj->oFloor = NULL;
+            play_sound(SOUND_OBJ_GOOMBA_ALERT, pobj->header.gfx.cameraToObject);
+        }
+    } else {
+        pobj->oUnresponsiveTimer--;
+    }
+}
+
+static void cappy_goomba_update_pos(struct PObject *pobj) {
+    obj_update_pos_and_vel(pobj, pobj->oProperties & POBJ_PROP_MOVE_THROUGH_VC_WALLS, obj_is_on_ground(pobj), &pobj->oSquishedTimer);
+    pobj_handle_special_floors(pobj);
+}
+
+static void cappy_goomba_process_interactions(struct PObject *pobj) {
+    POBJ_INTERACTIONS_BEGIN;
+
+    // Goomba stack
+    if (pobj->oCappyGoombaStackCount < CAPPY_GOOMBA_STACK_MAX_COUNT && obj->behavior == bhvGoomba) {
+        if (obj_detect_overlap(pobj, obj, OBJ_OVERLAP_FLAG_HITBOX, OBJ_OVERLAP_FLAG_HITBOX)) {
+            if (obj_is_object2_hit_from_above(pobj, obj)) {
+                add_goomba_to_stack(pobj, obj);
+                obj_spawn_white_puff(obj, SOUND_OBJ_DEFAULT_DEATH);
+                obj->oInteractStatus = INT_STATUS_INTERACTED;
+            }
+        }
+    }
+    
+    POBJ_INTERACTIONS_END;
+}
+
+static void cappy_goomba_update_animation_and_sound(struct PObject *pobj) {
+    obj_set_animation_with_accel(pobj, 0, (pobj->oVelY <= 0.f) * MAX(1.f, pobj->oForwardVel * 2.f / (pobj->cdWalkSpeed)));
+    obj_update_blink_state(pobj, &pobj->oGoombaBlinkTimer, 30, 50, 5);
+    if (obj_is_on_ground(pobj)) {
+        obj_make_step_sound_and_particle(pobj, &pobj->oWalkDistance, pobj->cdWalkSpeed * 8, pobj->oForwardVel, SOUND_OBJ_GOOMBA_WALK, OBJ_STEP_PARTICLE_NONE);
+    }
+}
+
+static void cappy_goomba_set_cappy_values(struct PObject *pobj) {
+    pobj->oCappyVerticalDist = (pobj->cdHitboxHeight / pobj->header.gfx.scale[1]) * (1 + pobj->oCappyGoombaStackCount);
+    pobj->oCappyInitialScale = 80;
+}
+
+//
+// Main loop
+//
+
+const PObjMainLoopFunc cappy_goomba_mloop[] = {
+    cappy_goomba_set_properties,
+    cappy_goomba_process_inputs,
+    cappy_goomba_update_pos,
+    cappy_goomba_process_interactions,
+    obj_update_gfx,
+    cappy_goomba_update_animation_and_sound,
+    cappy_goomba_update_goomba_stack,
+    cappy_goomba_set_cappy_values,
+    NULL
+};
+
+//
+// Init
+//
+
+s32 cappy_goomba_init(struct Object* obj) {
+    goomba_fix(obj);
+    obj->oCappyGoombaStackCount = 0;
+    return TRUE;
+}
+
+void cappy_goomba_end(struct Object *obj) {
+    for (s32 i = 0; i != obj->oCappyGoombaStackCount; ++i) {
+        struct Object *o = obj->oCappyGoombaStackObject(i);
+        o->behavior      = bhvGoomba;
+        o->curBhvCommand = (const BehaviorScript *)((s64)(bhvGoomba) + (s64)(obj->oCappyGoombaStackCurOffset(i)));
+        o->bhvStackIndex = (u32)(obj->oCappyGoombaStackStkIndex(i));
+    }
+}
+
+f32 cappy_goomba_get_top(struct Object *pobj) {
+    return pobj->cdHitboxHeight * (1 + pobj->oCappyGoombaStackCount);
+}
diff --git a/data/smo/capture/capture_hoot.c b/data/smo/capture/capture_hoot.c
new file mode 100644
index 0000000..f519671
--- /dev/null
+++ b/data/smo/capture/capture_hoot.c
@@ -0,0 +1,115 @@
+#include "../smo_c_includes.h"
+
+//
+// Possessed Hoot
+//
+
+static void cappy_hoot_set_properties(struct PObject *pobj) {
+    pobj->hitboxRadius = pobj->cdHitboxRadius;
+    pobj->hitboxHeight = pobj->cdHitboxHeight;
+    pobj->hurtboxRadius = 0;
+    pobj->hurtboxHeight = 0;
+    pobj->hitboxDownOffset = pobj->cdHitboxDownOffset;
+    pobj->oWallHitboxRadius = pobj->cdWallHitboxRadius;
+    pobj->oProperties = 0;
+    pobj->oProperties |= POBJ_PROP_ABOVE_WATER;
+    pobj->oProperties |= POBJ_PROP_UNDERWATER;
+}
+
+static void cappy_hoot_process_inputs(struct PObject *pobj) {
+    pobj_decelerate(pobj);
+    pobj_apply_gravity(pobj);
+
+    // Inputs
+    if (pobj->oUnresponsiveTimer == 0) {
+
+        // Move
+        f32 hvel = ((pobj->oButtonDown & B_BUTTON) ? pobj->cdRunSpeed : pobj->cdWalkSpeed);
+        if (pobj->oStickMag > 0) {
+            s32 faceYaw = pobj->oStickYaw - approach_s32((s16)(pobj->oStickYaw - pobj->oFaceAngleYaw), 0, 0x1000, 0x1000);
+            obj_set_forward_vel(pobj, faceYaw, pobj->oStickMag, hvel);
+            pobj->oFaceAngleYaw = faceYaw;
+            pobj->oFaceAnglePitch = 0;
+            pobj->oFaceAngleRoll = 0;
+            pobj->oMoveAngleYaw = faceYaw;
+            pobj->oMoveAnglePitch = 0;
+            pobj->oMoveAngleRoll = 0;
+        }
+
+        // Fly
+        if (pobj->oButtonPressed & A_BUTTON) {
+            pobj->oVelY = pobj->cdJumpVelocity;
+            pobj->oFloor = NULL;
+            pobj->header.gfx.unk38.curAnim = NULL;
+            play_sound(SOUND_GENERAL_SWISH_WATER, pobj->header.gfx.cameraToObject);
+        }
+    } else {
+        pobj->oUnresponsiveTimer--;
+    }
+}
+
+static void cappy_hoot_update_pos(struct PObject *pobj) {
+    obj_update_pos_and_vel(pobj, pobj->oProperties & POBJ_PROP_MOVE_THROUGH_VC_WALLS, obj_is_on_ground(pobj), &pobj->oSquishedTimer);
+    pobj_handle_special_floors(pobj);
+}
+
+static void cappy_hoot_process_interactions(struct PObject *pobj) {
+    POBJ_INTERACTIONS_BEGIN;
+    POBJ_INTERACTIONS_END;
+}
+
+static void cappy_hoot_update_animation_and_sound(struct PObject *pobj) {
+    if (pobj->oVelY > 0.f) {
+        obj_set_animation_with_accel(pobj, 0, 2.f);
+    } else {
+        obj_set_animation_with_accel(pobj, 0, 1.f);
+    }
+}
+
+static void cappy_hoot_set_cappy_values(struct PObject *pobj) {
+    pobj->oCappyForwardDist  = 26.f;
+    pobj->oCappyVerticalDist = 100.f;
+    pobj->oCappyInitialScale = 80;
+}
+
+//
+// Main loop
+//
+
+const PObjMainLoopFunc cappy_hoot_mloop[] = {
+    cappy_hoot_set_properties,
+    cappy_hoot_process_inputs,
+    cappy_hoot_update_pos,
+    cappy_hoot_process_interactions,
+    obj_update_gfx,
+    cappy_hoot_update_animation_and_sound,
+    cappy_hoot_set_cappy_values,
+    NULL
+};
+
+//
+// Init
+//
+
+s32 cappy_hoot_init(struct Object* obj) {
+    if (obj->oHootAvailability != HOOT_AVAIL_READY_TO_FLY) {
+        return FALSE;
+    }
+
+    obj->oCappyHootInitialHomeX = obj->oHomeX;
+    obj->oCappyHootInitialHomeY = obj->oHomeY;
+    obj->oCappyHootInitialHomeZ = obj->oHomeZ;
+    return TRUE;
+}
+
+void cappy_hoot_end(struct Object *obj) {
+    obj->oHomeX = obj->oCappyHootInitialHomeX;
+    obj->oHomeY = obj->oCappyHootInitialHomeY;
+    obj->oHomeZ = obj->oCappyHootInitialHomeZ;
+    obj->header.gfx.unk38.curAnim = NULL;
+    obj_set_animation_with_accel(obj, 0, 1.f);
+}
+
+f32 cappy_hoot_get_top(struct Object *obj) {
+    return 100.f * obj->oScaleY;
+}
diff --git a/data/smo/capture/capture_koopa.c b/data/smo/capture/capture_koopa.c
new file mode 100644
index 0000000..ba55fc7
--- /dev/null
+++ b/data/smo/capture/capture_koopa.c
@@ -0,0 +1,252 @@
+#include "../smo_c_includes.h"
+
+enum {
+    CAPPY_KOOPA_STATE_SHELLED_IDLE,
+    CAPPY_KOOPA_STATE_SHELLED_WALKING,
+    CAPPY_KOOPA_STATE_SHELLED_SLIDING,
+    CAPPY_KOOPA_STATE_SHELLED_JUMPING,
+    CAPPY_KOOPA_STATE_UNSHELLED_IDLE,
+    CAPPY_KOOPA_STATE_UNSHELLED_WALKING,
+    CAPPY_KOOPA_STATE_UNSHELLED_RUNNING,
+    CAPPY_KOOPA_STATE_UNSHELLED_JUMPING,
+};
+
+/* AnimIndex, Accel, Sfx, Model */
+static s32 sCappyKoopaStateData[][4] = {
+    {  7,   0, 0, MODEL_KOOPA_WITH_SHELL    },
+    {  9,   1, 1, MODEL_KOOPA_WITH_SHELL    },
+    {  0,   0, 2, MODEL_KOOPA_SHELL         },
+    { 12, 100, 0, MODEL_KOOPA_WITH_SHELL    },
+    {  7,   0, 0, MODEL_KOOPA_WITHOUT_SHELL },
+    {  9,   1, 1, MODEL_KOOPA_WITHOUT_SHELL },
+    {  3,   0, 1, MODEL_KOOPA_WITHOUT_SHELL },
+    { 12, 100, 0, MODEL_KOOPA_WITHOUT_SHELL }
+};
+
+/* fdist, ldist, vdist, pitch, yaw, roll, scale */
+static s32 sCappyKoopaCappyParams[][7] = {
+    { 33, 0, 68, 0xE000, 0x0000, 0x0000, 65 },
+    { 26, 0, 74, 0xDC00, 0x0000, 0x0000, 65 },
+    {  0, 0,  0, 0x0000, 0x0000, 0x0000,  0 },
+    {  6, 0, 70, 0xB400, 0x0000, 0x0000, 65 },
+    { 33, 0, 68, 0xE000, 0x0000, 0x0000, 65 },
+    { 26, 0, 74, 0xDC00, 0x0000, 0x0000, 65 },
+    { -4, 0, 82, 0xD400, 0x0000, 0x0000, 65 },
+    {  6, 0, 70, 0xB400, 0x0000, 0x0000, 65 },
+};
+
+//
+// Possessed Koopa
+//
+
+static void cappy_koopa_process_inputs(struct PObject *pobj) {
+    obj_scale(pobj, pobj->smoData->objData.gfxScaleY);
+    pobj_decelerate(pobj);
+    pobj_apply_gravity(pobj);
+
+    // Inputs
+    if (pobj->oUnresponsiveTimer == 0) {
+
+        // Walk
+        f32 hvel = pobj->cdWalkSpeed;
+        if (pobj->oButtonDown & B_BUTTON) {
+            if (pobj->oKoopaMovementType != KOOPA_BP_UNSHELLED) {
+                hvel = pobj->cdDashSpeed;
+            } else {
+                hvel = pobj->cdRunSpeed;
+            }
+        }
+        if (pobj->oStickMag > 0) {
+            s32 faceYaw = pobj->oStickYaw - approach_s32((s16)(pobj->oStickYaw - pobj->oFaceAngleYaw), 0, 0x1000, 0x1000);
+            obj_set_forward_vel(pobj, faceYaw, pobj->oStickMag, hvel);
+            pobj->oFaceAngleYaw = faceYaw;
+            pobj->oFaceAnglePitch = 0;
+            pobj->oFaceAngleRoll = 0;
+            pobj->oMoveAngleYaw = faceYaw;
+            pobj->oMoveAnglePitch = 0;
+            pobj->oMoveAngleRoll = 0;
+        }
+
+        // Jump
+        if ((pobj->oButtonPressed & A_BUTTON) && obj_is_on_ground(pobj)) {
+            pobj->oVelY = pobj->cdJumpVelocity;
+            pobj->oFloor = NULL;
+            play_sound(SOUND_OBJ_GOOMBA_ALERT, pobj->header.gfx.cameraToObject);
+        }
+    } else {
+        pobj->oUnresponsiveTimer--;
+    }
+}
+
+static void cappy_koopa_update_state(struct PObject *pobj) {
+    if (pobj->oKoopaMovementType != KOOPA_BP_UNSHELLED) {
+        if (pobj->oButtonDown & B_BUTTON) {
+            pobj->oCappyKoopaState = CAPPY_KOOPA_STATE_SHELLED_SLIDING;
+        } else if (obj_is_on_ground(pobj)) {
+            if (pobj->oForwardVel > 1.f) {
+                pobj->oCappyKoopaState = CAPPY_KOOPA_STATE_SHELLED_WALKING;
+            } else {
+                pobj->oCappyKoopaState = CAPPY_KOOPA_STATE_SHELLED_IDLE;
+            }
+        } else {
+            pobj->oCappyKoopaState = CAPPY_KOOPA_STATE_SHELLED_JUMPING;
+        }
+    } else {
+        if (obj_is_on_ground(pobj)) {
+            if (pobj->oForwardVel > pobj->cdWalkSpeed) {
+                pobj->oCappyKoopaState = CAPPY_KOOPA_STATE_UNSHELLED_RUNNING;
+            } else if (pobj->oForwardVel > 1.f) {
+                pobj->oCappyKoopaState = CAPPY_KOOPA_STATE_UNSHELLED_WALKING;
+            } else {
+                pobj->oCappyKoopaState = CAPPY_KOOPA_STATE_UNSHELLED_IDLE;
+            }
+        } else {
+            pobj->oCappyKoopaState = CAPPY_KOOPA_STATE_UNSHELLED_JUMPING;
+        }
+    }
+}
+
+static void cappy_koopa_set_properties(struct PObject *pobj) {
+    pobj->hitboxRadius = pobj->cdHitboxRadius;
+    pobj->hitboxHeight = pobj->cdHitboxHeight;
+    pobj->hitboxDownOffset = pobj->cdHitboxDownOffset;
+    pobj->oWallHitboxRadius = pobj->cdWallHitboxRadius;
+    pobj->oProperties = 0;
+    pobj->oProperties |= POBJ_PROP_ABOVE_WATER;
+    if (pobj->oCappyKoopaState == CAPPY_KOOPA_STATE_SHELLED_SLIDING) {
+        pobj->oProperties |= POBJ_PROP_ATTACK;
+        pobj->oProperties |= POBJ_PROP_IMMUNE_TO_FIRE;
+        pobj->oProperties |= POBJ_PROP_IMMUNE_TO_LAVA;
+        pobj->oProperties |= POBJ_PROP_IMMUNE_TO_QUICKSANDS;
+        pobj->oProperties |= POBJ_PROP_WALK_ON_WATER;
+    }
+}
+
+static void cappy_koopa_update_pos(struct PObject *pobj) {
+    obj_update_pos_and_vel(pobj, pobj->oProperties & POBJ_PROP_MOVE_THROUGH_VC_WALLS, obj_is_on_ground(pobj), &pobj->oSquishedTimer);
+    pobj_handle_special_floors(pobj);
+}
+
+static void cappy_koopa_process_interactions(struct PObject *pobj) {
+    POBJ_INTERACTIONS_BEGIN;
+
+    // Koopa shell
+    if (obj->behavior == bhvKoopaShell && pobj->oKoopaMovementType == KOOPA_BP_UNSHELLED) {
+        if (obj_detect_overlap(pobj, obj, OBJ_OVERLAP_FLAG_HITBOX, OBJ_OVERLAP_FLAG_HITBOX)) {
+            pobj->oKoopaMovementType = KOOPA_BP_NORMAL;
+            obj_spawn_white_puff(obj, SOUND_MENU_STAR_SOUND);
+            obj_mark_for_deletion(obj);
+            obj->oInteractStatus = INT_STATUS_INTERACTED;
+        }
+    }
+
+    POBJ_INTERACTIONS_END;
+}
+
+static void cappy_koopa_update_animation_and_sound(struct PObject *pobj) {
+
+    // Animation
+    s32 *animData = sCappyKoopaStateData[pobj->oCappyKoopaState];
+    pobj->header.gfx.sharedChild = gLoadedGraphNodes[animData[3]];
+    obj_set_animation_with_accel(pobj, animData[0], MAX(1.f, animData[1] * MAX(1.f, pobj->oForwardVel * 2.f / (pobj->cdWalkSpeed))));
+    obj_update_blink_state(pobj, &pobj->oKoopaBlinkTimer, 20, 50, 4);
+
+    if (pobj->oCappyKoopaState == CAPPY_KOOPA_STATE_SHELLED_SLIDING) {
+        obj_scale(pobj, pobj->smoData->objData.gfxScaleY / 1.5f);
+        pobj->header.gfx.angle[0] = 0;
+        pobj->header.gfx.angle[1] = pobj->oTimer * 0x2000;
+        pobj->header.gfx.angle[2] = 0;
+    } else {
+        obj_scale(pobj, pobj->smoData->objData.gfxScaleY);
+    }
+
+    // Sound effect
+    switch (animData[2]) {
+        case 1:
+            if (obj_is_on_ground(pobj)) {
+                obj_make_step_sound_and_particle(pobj, &pobj->oWalkDistance, pobj->cdWalkSpeed * 8, pobj->oForwardVel, SOUND_OBJ_KOOPA_WALK, OBJ_STEP_PARTICLE_NONE);
+            }
+            break;
+
+        case 2:
+            switch (pobj->oFloorType) {
+                case POBJ_FLOOR_TYPE_GROUND:
+                    obj_make_step_sound_and_particle(pobj,
+                        &pobj->oWalkDistance, 0.f, 0.f,
+                        SOUND_MOVING_TERRAIN_RIDING_SHELL + pobj->oMario->terrainSoundAddend,
+                        OBJ_STEP_PARTICLE_MIST);
+                    break;
+
+                case POBJ_FLOOR_TYPE_WATER:
+                    obj_make_step_sound_and_particle(pobj,
+                        &pobj->oWalkDistance, 0.f, 0.f,
+                        SOUND_MOVING_TERRAIN_RIDING_SHELL + SOUND_TERRAIN_WATER,
+                        OBJ_STEP_PARTICLE_WATER_TRAIL | OBJ_STEP_PARTICLE_WATER_DROPLET);
+                    break;
+
+                case POBJ_FLOOR_TYPE_LAVA:
+                    obj_make_step_sound_and_particle(pobj,
+                        &pobj->oWalkDistance, 0.f, 0.f,
+                        SOUND_MOVING_RIDING_SHELL_LAVA,
+                        OBJ_STEP_PARTICLE_FLAME);
+                    break;
+            }
+            break;
+    }
+}
+
+static void cappy_koopa_set_cappy_values(struct PObject *pobj) {
+    s32 *cappyParams = sCappyKoopaCappyParams[pobj->oCappyKoopaState];
+    pobj->oCappyForwardDist  = (f32) cappyParams[0];
+    pobj->oCappyLateralDist  = (f32) cappyParams[1];
+    pobj->oCappyVerticalDist = (f32) cappyParams[2];
+    pobj->oCappyInitialPitch = (s16) cappyParams[3];
+    pobj->oCappyInitialYaw   = (s16) cappyParams[4];
+    pobj->oCappyInitialRoll  = (s16) cappyParams[5];
+    pobj->oCappyInitialScale = (s16) cappyParams[6];
+}
+
+//
+// Main loop
+//
+
+const PObjMainLoopFunc cappy_koopa_mloop[] = {
+    cappy_koopa_process_inputs,
+    cappy_koopa_update_state,
+    cappy_koopa_set_properties,
+    cappy_koopa_update_pos,
+    cappy_koopa_process_interactions,
+    obj_update_gfx,
+    cappy_koopa_update_animation_and_sound,
+    cappy_koopa_set_cappy_values,
+    NULL
+};
+
+//
+// Init
+//
+
+s32 cappy_koopa_init(struct Object* obj) {
+
+    // Can't possess KTQ
+    if (obj->oBehParams2ndByte == KOOPA_BP_KOOPA_THE_QUICK_BOB ||
+        obj->oBehParams2ndByte == KOOPA_BP_KOOPA_THE_QUICK_THI) {
+        return FALSE;
+    }
+
+    return TRUE;
+}
+
+void cappy_koopa_end(struct Object *obj) {
+    if (obj->oCappyKoopaState < CAPPY_KOOPA_STATE_UNSHELLED_IDLE) {
+        obj->oKoopaMovementType = KOOPA_BP_NORMAL;
+        obj->header.gfx.sharedChild = gLoadedGraphNodes[MODEL_KOOPA_WITH_SHELL];
+    } else {
+        obj->oKoopaMovementType = KOOPA_BP_UNSHELLED;
+        obj->header.gfx.sharedChild = gLoadedGraphNodes[MODEL_KOOPA_WITHOUT_SHELL];
+    }
+}
+
+f32 cappy_koopa_get_top(struct Object *obj) {
+    return 70.f * obj->oScaleY;
+}
\ No newline at end of file
diff --git a/data/smo/capture/capture_whomp.c b/data/smo/capture/capture_whomp.c
new file mode 100644
index 0000000..02f877d
--- /dev/null
+++ b/data/smo/capture/capture_whomp.c
@@ -0,0 +1,321 @@
+#include "../smo_c_includes.h"
+
+//
+// Attack
+//
+
+static void cappy_whomp_shock_wave_attack(struct Object *this) {
+
+    // Surfaces
+    f32 dy = this->hitboxHeight / 8;
+    for (s32 i = 0; i <= 8; ++i) {
+        struct WallCollisionData hitbox;
+        hitbox.x = this->oPosX;
+        hitbox.y = this->oPosY;
+        hitbox.z = this->oPosZ;
+        hitbox.offsetY = (dy * i) - this->hitboxDownOffset;
+        hitbox.radius = this->hitboxRadius;
+        if (find_wall_collisions(&hitbox) != 0) {
+            for (s16 j = 0; j != hitbox.numWalls; ++j) {
+                struct Object *obj = hitbox.walls[j]->object;
+                if (obj && !(obj->oInteractStatus & INT_STATUS_INTERACTED)) {
+
+                    // Lying Whomp
+                    if (obj->behavior == bhvSmallWhomp && obj->oAction == 6) {
+                        obj->oNumLootCoins = 5;
+                        obj_explode(obj, SOUND_OBJ_THWOMP);
+                        obj->oInteractStatus = INT_STATUS_INTERACTED;
+                    }
+
+                    // Wall behind WF tower
+                    if (obj->behavior == bhvTowerDoor) {
+                        obj_explode(obj, SOUND_GENERAL_WALL_EXPLOSION);
+                        obj->oInteractStatus = INT_STATUS_INTERACTED;
+                    }
+
+                    // Kickable board
+                    if (obj->behavior == bhvKickableBoard) {
+                        obj->oAction = 2;
+                        obj->oInteractStatus = INT_STATUS_INTERACTED;
+                    }
+
+                    // WF coin cannon wall
+                    if (obj->behavior == bhvWfBreakableWallLeft) {
+                        obj->oNumLootCoins = 1;
+                        obj_explode(obj, SOUND_GENERAL_WALL_EXPLOSION);
+                        obj->oInteractStatus = INT_STATUS_INTERACTED;
+                    }
+
+                    // WF star cannon wall
+                    if (obj->behavior == bhvWfBreakableWallRight) {
+                        play_puzzle_jingle();
+                        obj_explode(obj, SOUND_GENERAL_WALL_EXPLOSION);
+                        obj->oInteractStatus = INT_STATUS_INTERACTED;
+                    }
+                }
+            }
+        }
+    }
+
+    // Objects
+    for (u32 objType = OBJ_LIST_DESTRUCTIVE; objType <= OBJ_LIST_POLELIKE; ++objType) {
+        struct ObjectNode *list = &gObjectLists[objType];
+        struct Object *obj = obj_get_first(list);
+        while (obj != NULL) {
+            if (obj != this) {
+                if (obj_detect_overlap(this, obj, OBJ_OVERLAP_FLAG_HITBOX, OBJ_OVERLAP_FLAG_HITBOX)) {
+                    switch (obj->oInteractType) {
+                        case INTERACT_KOOPA:
+                        case INTERACT_BOUNCE_TOP:
+                        case INTERACT_BOUNCE_TOP2:
+                        case INTERACT_HIT_FROM_BELOW: {
+                            obj->oInteractStatus = (0x02 | INT_STATUS_INTERACTED | INT_STATUS_WAS_ATTACKED);
+                        } break;
+
+                        case INTERACT_BULLY: {
+                            f32 knockback = 3600.f / obj->hitboxRadius;
+                            s16 angle = obj_get_object1_angle_yaw_to_object2(this, obj);
+                            obj->oFaceAngleYaw = angle + 0x8000;
+                            obj->oMoveAngleYaw = angle;
+                            obj->oForwardVel = knockback;
+                            obj->oInteractStatus = (0x02 | INT_STATUS_INTERACTED | INT_STATUS_WAS_ATTACKED);
+                            play_sound(SOUND_OBJ_BULLY_METAL, obj->header.gfx.cameraToObject);
+                        } break;
+
+                        case INTERACT_BREAKABLE: {
+                            obj->oInteractStatus = (0x02 | INT_STATUS_INTERACTED | INT_STATUS_WAS_ATTACKED);
+                            set_camera_shake_from_hit(SHAKE_ATTACK);
+                        } break;
+
+                        case INTERACT_GRABBABLE: {
+                            if (obj->oInteractionSubtype & INT_SUBTYPE_KICKABLE) {
+                                obj->oInteractStatus = (0x02 | INT_STATUS_INTERACTED | INT_STATUS_WAS_ATTACKED);
+                            }
+                            if (obj->behavior == bhvBreakableBoxSmall) {
+                                obj->oNumLootCoins = 3;
+                                obj_spawn_white_puff(obj, SOUND_GENERAL_BREAK_BOX);
+                                obj_spawn_triangle_break_particles(obj, 20, 138, 0.7f, 3);
+                                obj_spawn_loot_yellow_coins(obj, 3, 20.0f);
+                                obj_mark_for_deletion(obj);
+                            }
+                        } break;
+                    }
+                }
+            }
+            obj = obj_get_next(list, obj);
+        }
+    }
+}
+
+#define CAPPY_WHOMP_SHOCK_WAVE_MAX_DURATION  30
+
+void bhv_cappy_whomp_shock_wave_loop(void) {
+    f32 t = (f32) gCurrentObject->oTimer / (f32) CAPPY_WHOMP_SHOCK_WAVE_MAX_DURATION;
+    if (t >= 1.f) {
+        obj_mark_for_deletion(gCurrentObject);
+        return;
+    }
+
+    f32 scale = 30.f + 120.f * t;
+    gCurrentObject->header.gfx.scale[0] = scale;
+    gCurrentObject->header.gfx.scale[1] = scale;
+    gCurrentObject->header.gfx.scale[2] = scale;
+    gCurrentObject->hitboxRadius = 5.f * scale;
+    gCurrentObject->hitboxHeight = 80.f;
+    gCurrentObject->hitboxDownOffset = 40.f;
+    gCurrentObject->oOpacity = MIN(255, 510 * (1.f - t));
+    gCurrentObject->oIntangibleTimer = 0;
+    cappy_whomp_shock_wave_attack(gCurrentObject);
+}
+
+const BehaviorScript bhvCappyWhompShockWave[] = {
+    0x00020000,
+    0x110100C1,
+    0x08000000,
+    0x0C000000, (uintptr_t) (bhv_cappy_whomp_shock_wave_loop),
+    0x09000000, 
+};
+
+//
+// Possessed Whomp
+//
+
+enum {
+    CAPPY_WHOMP_ACTION_DEFAULT = 0,
+    CAPPY_WHOMP_ACTION_BEGIN_ATTACK,
+    CAPPY_WHOMP_ACTION_ATTACK,
+    CAPPY_WHOMP_ACTION_FALLING,
+    CAPPY_WHOMP_ACTION_LAND,
+    CAPPY_WHOMP_ACTION_END_ATTACK
+};
+
+static void cappy_whomp_process_inputs(struct PObject *pobj) {
+    pobj_decelerate(pobj);
+    pobj_apply_gravity(pobj);
+
+    // Inputs
+    if (pobj->oUnresponsiveTimer == 0) {
+
+        // Walk
+        if (pobj->oStickMag > 0) {
+            s32 faceYaw = pobj->oStickYaw - approach_s32((s16)(pobj->oStickYaw - pobj->oFaceAngleYaw), 0, 0x1000, 0x1000);
+            obj_set_forward_vel(pobj, faceYaw, pobj->oStickMag, pobj->cdWalkSpeed);
+            pobj->oFaceAngleYaw = faceYaw;
+            pobj->oFaceAngleRoll = 0;
+            pobj->oMoveAngleYaw = faceYaw;
+            pobj->oMoveAngleRoll = 0;
+        }
+
+        // Jump
+        if ((pobj->oButtonPressed & A_BUTTON) && obj_is_on_ground(pobj)) {
+            pobj->oVelY = pobj->cdJumpVelocity;
+            pobj->oFloor = NULL;
+            play_sound(SOUND_OBJ_GOOMBA_ALERT, pobj->header.gfx.cameraToObject);
+        }
+
+        // Body slam
+        if (pobj->oButtonPressed & B_BUTTON) {
+            pobj->oCappyWhompActionState = CAPPY_WHOMP_ACTION_BEGIN_ATTACK;
+        }
+    } else {
+        pobj->oUnresponsiveTimer--;
+    }
+}
+
+static void cappy_whomp_set_properties(struct PObject *pobj) {
+    pobj->hitboxRadius = pobj->cdHitboxRadius;
+    pobj->hitboxHeight = pobj->cdHitboxHeight;
+    pobj->hitboxDownOffset = pobj->cdHitboxDownOffset;
+    pobj->oWallHitboxRadius = pobj->cdWallHitboxRadius;
+    pobj->oProperties = 0;
+    pobj->oProperties |= POBJ_PROP_ABOVE_WATER;
+
+    // Body slam
+    if (pobj->oCappyWhompActionState != CAPPY_WHOMP_ACTION_DEFAULT) {
+        pobj->hitboxHeight *= 0.25f;
+        pobj->oProperties |= POBJ_PROP_UNPUSHABLE;
+        pobj->oProperties |= POBJ_PROP_INVULNERABLE;
+    }
+}
+
+static void cappy_whomp_update_pos(struct PObject *pobj) {
+    obj_update_pos_and_vel(pobj, pobj->oProperties & POBJ_PROP_MOVE_THROUGH_VC_WALLS, obj_is_on_ground(pobj), &pobj->oSquishedTimer);
+    pobj_handle_special_floors(pobj);
+}
+
+static void cappy_whomp_process_interactions(struct PObject *pobj) {
+    POBJ_INTERACTIONS_BEGIN;
+    POBJ_INTERACTIONS_END;
+}
+
+static void cappy_whomp_update_action_state(struct PObject *pobj) {
+    switch (pobj->oCappyWhompActionState) {
+        case CAPPY_WHOMP_ACTION_BEGIN_ATTACK:
+            mario_lock(pobj->oMario);
+            obj_set_animation_with_accel(pobj, 1, 2.0f);
+            if (obj_check_if_near_animation_end(pobj)) {
+                pobj->oVelY = 40.0f;
+                pobj->oCappyWhompActionState = CAPPY_WHOMP_ACTION_ATTACK;
+            }
+            break;
+
+        case CAPPY_WHOMP_ACTION_ATTACK:
+            mario_lock(pobj->oMario);
+            if (pobj->oFaceAnglePitch < 0x4000) {
+                pobj->oFaceAnglePitch += 0x400;
+            } else {
+                pobj->oCappyWhompActionState = CAPPY_WHOMP_ACTION_FALLING;
+            }
+            break;
+
+        case CAPPY_WHOMP_ACTION_FALLING:
+            mario_lock(pobj->oMario);
+            if (obj_is_on_ground(pobj)) {
+                f32 x = pobj->oPosX + sins(pobj->oFaceAngleYaw) * pobj->cdHitboxHeight / 2.f;
+                f32 y = pobj->oPosY;
+                f32 z = pobj->oPosZ + coss(pobj->oFaceAngleYaw) * pobj->cdHitboxHeight / 2.f;
+                obj_spawn_white_puff_at(x, y, z, SOUND_OBJ_WHOMP_LOWPRIO);
+                cur_obj_shake_screen(SHAKE_POS_LARGE);
+                pobj->oCappyWhompActionState = CAPPY_WHOMP_ACTION_LAND;
+                pobj->oCappyWhompActionTimer = 0;
+                spawn_object_abs_with_rot(pobj, 0, MODEL_SHOCK_WAVE, bhvCappyWhompShockWave, x, y + 5, z, 0, 0, 0);
+            }
+            break;
+
+        case CAPPY_WHOMP_ACTION_LAND:
+            mario_lock(pobj->oMario);
+            if (pobj->oCappyWhompActionTimer < 30) {
+                pobj->oCappyWhompActionTimer++;
+            } else {
+                pobj->oCappyWhompActionState = CAPPY_WHOMP_ACTION_END_ATTACK;
+            }
+            break;
+
+        case CAPPY_WHOMP_ACTION_END_ATTACK:
+            mario_lock(pobj->oMario);
+            if (pobj->oFaceAnglePitch > 0) {
+                pobj->oFaceAnglePitch -= 0x200;
+            } else {
+                pobj->oCappyWhompActionState = CAPPY_WHOMP_ACTION_DEFAULT;
+            }
+            break;
+
+        default:
+            mario_unlock(pobj->oMario);
+            obj_set_animation_with_accel(pobj, 0, (pobj->oVelY <= 0.f) * MAX(1.f, pobj->oForwardVel * 3.f / (pobj->cdWalkSpeed)));
+            if (obj_is_on_ground(pobj)) {
+                obj_make_step_sound_and_particle(pobj, &pobj->oWalkDistance, pobj->cdWalkSpeed * 8, pobj->oForwardVel, SOUND_OBJ_POUNDING1, OBJ_STEP_PARTICLE_NONE);
+            }
+            break;
+    }
+}
+
+static void cappy_whomp_set_cappy_values(struct PObject *pobj) {
+    pobj->oCappyForwardDist  = -45.f;
+    pobj->oCappyVerticalDist = 430.f;
+    pobj->oCappyInitialScale = 150;
+}
+
+//
+// Main loop
+//
+
+const PObjMainLoopFunc cappy_whomp_mloop[] = {
+    cappy_whomp_process_inputs,
+    cappy_whomp_set_properties,
+    cappy_whomp_update_pos,
+    cappy_whomp_process_interactions,
+    cappy_whomp_update_action_state,
+    obj_update_gfx,
+    cappy_whomp_set_cappy_values,
+    NULL
+};
+
+//
+// Init
+//
+
+s32 cappy_whomp_init(struct Object* obj) {
+    if (!(obj->oAction == 1 || obj->oAction == 2 || obj->oAction == 3 || obj->oAction == 6 || obj->oAction == 7)) {
+        return FALSE;
+    }
+
+    if (obj->oAction == 6) {
+        obj->oCappyWhompActionState = CAPPY_WHOMP_ACTION_END_ATTACK;
+    } else {
+        obj->oCappyWhompActionState = CAPPY_WHOMP_ACTION_DEFAULT;
+    }
+    obj->oCappyWhompActionTimer = 0;
+    return TRUE;
+}
+
+void cappy_whomp_end(struct Object *obj) {
+    obj->oAction = 1;
+    obj->oSubAction = 0;
+    obj->oTimer = 0;
+    obj->oFaceAnglePitch = 0;
+}
+
+f32 cappy_whomp_get_top(struct Object *obj) {
+    return 430.f * obj->oScaleY;
+}
diff --git a/data/smo/capture/capture_whomp_king.c b/data/smo/capture/capture_whomp_king.c
new file mode 100644
index 0000000..cd91810
--- /dev/null
+++ b/data/smo/capture/capture_whomp_king.c
@@ -0,0 +1,90 @@
+#include "../smo_c_includes.h"
+
+//
+// Possessed Whomp King
+//
+
+static void cappy_whomp_king_update(struct PObject *pobj) {
+    // Standing up
+    if (pobj->oFaceAnglePitch > 0) {
+        pobj->oFaceAnglePitch = MAX(0, pobj->oFaceAnglePitch - 0x200);
+        return;
+    }
+
+    // Delay
+    if (pobj->oCappyWhompKingTimer > 0) {
+        pobj->oCappyWhompKingTimer--;
+        return;
+    }
+
+    switch (pobj->oCappyWhompKingState) {
+        case 0: // Start dialog
+            if (mario_lock(pobj->oMario) && dialog_start(DIALOG_SMO_KING_WHOMP)) {
+                play_sound(SOUND_OBJ2_BOSS_DIALOG_GRUNT, pobj->header.gfx.cameraToObject);
+                pobj->oCappyWhompKingState = 1;
+            }
+            break;
+
+        case 1: // Wait for the dialog to end
+            if (dialog_update()) {
+                pobj->oCappyWhompKingState = 2;
+                pobj->oCappyWhompKingTimer = 5;
+            }
+            break;
+
+        case 2: // Release Mario
+            if (mario_unlock(pobj->oMario)) {
+                pobj->oCappyWhompKingState = 3;
+                pobj->oMario->faceAngle[1] = pobj->oFaceAngleYaw;
+                pobj->oMarioObj->oFaceAngleYaw = pobj->oFaceAngleYaw;
+                mario_unpossess_object(pobj->oMario, MARIO_UNPOSSESS_ACT_KNOCKED_OUT_OF_KING_WHOMP, FALSE, 15);
+            }
+            break;
+    }
+}
+
+static void cappy_whomp_king_update_animation_and_sound(struct PObject *pobj) {
+    obj_set_animation_with_accel(pobj, 0, 1.f);
+}
+
+static void cappy_whomp_king_set_cappy_values(struct PObject *pobj) {
+    pobj->oCappyForwardDist  = -45.f;
+    pobj->oCappyVerticalDist = 430.f;
+    pobj->oCappyInitialScale = 150;
+}
+
+//
+// Main loop
+//
+
+const PObjMainLoopFunc cappy_whomp_king_mloop[] = {
+    cappy_whomp_king_update,
+    obj_update_gfx,
+    cappy_whomp_king_update_animation_and_sound,
+    cappy_whomp_king_set_cappy_values,
+    NULL
+};
+
+//
+// Init
+//
+
+s32 cappy_whomp_king_init(struct Object *obj) {
+    if (!(obj->oAction == 1 || obj->oAction == 2 || obj->oAction == 3 || obj->oAction == 6 || obj->oAction == 7)) {
+        return FALSE;
+    }
+
+    obj->oCappyWhompKingState = 0;
+    obj->oCappyWhompKingTimer = 10;
+    return TRUE;
+}
+
+void cappy_whomp_king_end(struct Object *obj) {
+    obj->oAction = 3;
+    obj->oSubAction = 0;
+    obj->oTimer = 0;
+}
+
+f32 cappy_whomp_king_get_top(struct Object *obj) {
+    return 430.f * obj->oScaleY;
+}
diff --git a/data/smo/debug/smo_debug.c b/data/smo/debug/smo_debug.c
new file mode 100644
index 0000000..5a60435
--- /dev/null
+++ b/data/smo/debug/smo_debug.c
@@ -0,0 +1,10 @@
+#include "../smo_c_includes.h"
+#include "geo_commands.h"
+#include <stdarg.h>
+#include "smo_debug_obj.inl"
+#include "smo_debug_text.inl"
+
+void smo_debug_update() {
+    smo_debug_display_objects_hitbox();
+    smo_debug_display_text();
+}
diff --git a/data/smo/debug/smo_debug.h b/data/smo/debug/smo_debug.h
new file mode 100644
index 0000000..8c5ca60
--- /dev/null
+++ b/data/smo/debug/smo_debug.h
@@ -0,0 +1,25 @@
+#ifndef SMO_DEBUG_H
+#define SMO_DEBUG_H
+
+#include "types.h"
+
+/* Debug stuff */
+/* Compile with DEBUG=1 to use the DEBUG_ONLY code */
+
+#ifdef DEBUG
+#define DEBUG_ONLY(...) __VA_ARGS__
+#else
+#define DEBUG_ONLY(...) 
+#endif
+
+/* Debug display */
+extern const GeoLayout dbg_cylinder_hitbox_geo[];
+extern const GeoLayout dbg_cylinder_hurtbox_geo[];
+
+/* Debug text */
+void smo_debug_add_string(s32 x, s32 y, u32 rgbaFront, u32 rgbaBack, const char *fmt, ...);
+
+/* Debug mode */
+void smo_debug_update();
+
+#endif // SMO_DEBUG_H
diff --git a/data/smo/debug/smo_debug_obj.inl b/data/smo/debug/smo_debug_obj.inl
new file mode 100644
index 0000000..1e396e2
--- /dev/null
+++ b/data/smo/debug/smo_debug_obj.inl
@@ -0,0 +1,321 @@
+//
+// Debug Cylinder data
+//
+
+static Vtx dbg_cylinder_vertex[80];
+
+static const Gfx dbg_cylinder_vertex_dl[] = {
+    // Upper first-half
+    gsSPVertex(dbg_cylinder_vertex + 0, 10, 0),
+    gsSP2Triangles(0, 2, 1, 0x0, 0, 3, 2, 0x0),
+    gsSP2Triangles(0, 4, 3, 0x0, 0, 5, 4, 0x0),
+    gsSP2Triangles(0, 6, 5, 0x0, 0, 7, 6, 0x0),
+    gsSP2Triangles(0, 8, 7, 0x0, 0, 9, 8, 0x0),
+
+    // Upper second-half
+    gsSPVertex(dbg_cylinder_vertex + 10, 10, 0),
+    gsSP2Triangles(0, 2, 1, 0x0, 0, 3, 2, 0x0),
+    gsSP2Triangles(0, 4, 3, 0x0, 0, 5, 4, 0x0),
+    gsSP2Triangles(0, 6, 5, 0x0, 0, 7, 6, 0x0),
+    gsSP2Triangles(0, 8, 7, 0x0, 0, 9, 8, 0x0),
+
+    // Lower first-half
+    gsSPVertex(dbg_cylinder_vertex + 20, 10, 0),
+    gsSP2Triangles(0, 1, 2, 0x0, 0, 2, 3, 0x0),
+    gsSP2Triangles(0, 3, 4, 0x0, 0, 4, 5, 0x0),
+    gsSP2Triangles(0, 5, 6, 0x0, 0, 6, 7, 0x0),
+    gsSP2Triangles(0, 7, 8, 0x0, 0, 8, 9, 0x0),
+
+    // Lower second-half
+    gsSPVertex(dbg_cylinder_vertex + 30, 10, 0),
+    gsSP2Triangles(0, 1, 2, 0x0, 0, 2, 3, 0x0),
+    gsSP2Triangles(0, 3, 4, 0x0, 0, 4, 5, 0x0),
+    gsSP2Triangles(0, 5, 6, 0x0, 0, 6, 7, 0x0),
+    gsSP2Triangles(0, 7, 8, 0x0, 0, 8, 9, 0x0),
+
+    // First wall
+    gsSPVertex(dbg_cylinder_vertex + 40, 10, 0),
+    gsSP2Triangles(0, 2, 1, 0x0, 1, 2, 3, 0x0),
+    gsSP2Triangles(2, 4, 3, 0x0, 3, 4, 5, 0x0),
+    gsSP2Triangles(4, 6, 5, 0x0, 5, 6, 7, 0x0),
+    gsSP2Triangles(6, 8, 7, 0x0, 7, 8, 9, 0x0),
+
+    // Second wall
+    gsSPVertex(dbg_cylinder_vertex + 50, 10, 0),
+    gsSP2Triangles(0, 2, 1, 0x0, 1, 2, 3, 0x0),
+    gsSP2Triangles(2, 4, 3, 0x0, 3, 4, 5, 0x0),
+    gsSP2Triangles(4, 6, 5, 0x0, 5, 6, 7, 0x0),
+    gsSP2Triangles(6, 8, 7, 0x0, 7, 8, 9, 0x0),
+
+    // Third wall
+    gsSPVertex(dbg_cylinder_vertex + 60, 10, 0),
+    gsSP2Triangles(0, 2, 1, 0x0, 1, 2, 3, 0x0),
+    gsSP2Triangles(2, 4, 3, 0x0, 3, 4, 5, 0x0),
+    gsSP2Triangles(4, 6, 5, 0x0, 5, 6, 7, 0x0),
+    gsSP2Triangles(6, 8, 7, 0x0, 7, 8, 9, 0x0),
+
+    // Fourth wall
+    gsSPVertex(dbg_cylinder_vertex + 70, 10, 0),
+    gsSP2Triangles(0, 2, 1, 0x0, 1, 2, 3, 0x0),
+    gsSP2Triangles(2, 4, 3, 0x0, 3, 4, 5, 0x0),
+    gsSP2Triangles(4, 6, 5, 0x0, 5, 6, 7, 0x0),
+    gsSP2Triangles(6, 8, 7, 0x0, 7, 8, 9, 0x0),
+
+    gsSPEndDisplayList(),
+};
+
+static inline Vtx get_center(f32 y) {
+    Vtx v = { { { 0, 100.f * y, 0 }, 0, { 0, 0 }, { 0xff, 0xff, 0xff, 0xff } } };
+    return v;
+}
+
+static inline Vtx get_point(s16 a, f32 y) {
+    Vtx v = { { { 100.f * coss(a), 100.f * y, 100.f * sins(a) }, 0, { 0, 0 }, { 0xff, 0xff, 0xff, 0xff } } };
+    return v;
+}
+
+static void smo_debug_set_vertex_data() {
+    // Upper first-half
+    dbg_cylinder_vertex[0] = get_center(1);
+    dbg_cylinder_vertex[1] = get_point(0x0000, 1);
+    dbg_cylinder_vertex[2] = get_point(0x1000, 1);
+    dbg_cylinder_vertex[3] = get_point(0x2000, 1);
+    dbg_cylinder_vertex[4] = get_point(0x3000, 1);
+    dbg_cylinder_vertex[5] = get_point(0x4000, 1);
+    dbg_cylinder_vertex[6] = get_point(0x5000, 1);
+    dbg_cylinder_vertex[7] = get_point(0x6000, 1);
+    dbg_cylinder_vertex[8] = get_point(0x7000, 1);
+    dbg_cylinder_vertex[9] = get_point(0x8000, 1);
+
+    // Upper second-half
+    dbg_cylinder_vertex[10] = get_center(1);
+    dbg_cylinder_vertex[11] = get_point(0x8000, 1);
+    dbg_cylinder_vertex[12] = get_point(0x9000, 1);
+    dbg_cylinder_vertex[13] = get_point(0xA000, 1);
+    dbg_cylinder_vertex[14] = get_point(0xB000, 1);
+    dbg_cylinder_vertex[15] = get_point(0xC000, 1);
+    dbg_cylinder_vertex[16] = get_point(0xD000, 1);
+    dbg_cylinder_vertex[17] = get_point(0xE000, 1);
+    dbg_cylinder_vertex[18] = get_point(0xF000, 1);
+    dbg_cylinder_vertex[19] = get_point(0x0000, 1);
+
+    // Lower first-half
+    dbg_cylinder_vertex[20] = get_center(0);
+    dbg_cylinder_vertex[21] = get_point(0x0000, 0);
+    dbg_cylinder_vertex[22] = get_point(0x1000, 0);
+    dbg_cylinder_vertex[23] = get_point(0x2000, 0);
+    dbg_cylinder_vertex[24] = get_point(0x3000, 0);
+    dbg_cylinder_vertex[25] = get_point(0x4000, 0);
+    dbg_cylinder_vertex[26] = get_point(0x5000, 0);
+    dbg_cylinder_vertex[27] = get_point(0x6000, 0);
+    dbg_cylinder_vertex[28] = get_point(0x7000, 0);
+    dbg_cylinder_vertex[29] = get_point(0x8000, 0);
+
+    // Lower second-half
+    dbg_cylinder_vertex[30] = get_center(0);
+    dbg_cylinder_vertex[31] = get_point(0x8000, 0);
+    dbg_cylinder_vertex[32] = get_point(0x9000, 0);
+    dbg_cylinder_vertex[33] = get_point(0xA000, 0);
+    dbg_cylinder_vertex[34] = get_point(0xB000, 0);
+    dbg_cylinder_vertex[35] = get_point(0xC000, 0);
+    dbg_cylinder_vertex[36] = get_point(0xD000, 0);
+    dbg_cylinder_vertex[37] = get_point(0xE000, 0);
+    dbg_cylinder_vertex[38] = get_point(0xF000, 0);
+    dbg_cylinder_vertex[39] = get_point(0x0000, 0);
+
+    // First wall
+    dbg_cylinder_vertex[40] = get_point(0x0000, 1);
+    dbg_cylinder_vertex[41] = get_point(0x0000, 0);
+    dbg_cylinder_vertex[42] = get_point(0x1000, 1);
+    dbg_cylinder_vertex[43] = get_point(0x1000, 0);
+    dbg_cylinder_vertex[44] = get_point(0x2000, 1);
+    dbg_cylinder_vertex[45] = get_point(0x2000, 0);
+    dbg_cylinder_vertex[46] = get_point(0x3000, 1);
+    dbg_cylinder_vertex[47] = get_point(0x3000, 0);
+    dbg_cylinder_vertex[48] = get_point(0x4000, 1);
+    dbg_cylinder_vertex[49] = get_point(0x4000, 0);
+
+    // Second wall
+    dbg_cylinder_vertex[50] = get_point(0x4000, 1);
+    dbg_cylinder_vertex[51] = get_point(0x4000, 0);
+    dbg_cylinder_vertex[52] = get_point(0x5000, 1);
+    dbg_cylinder_vertex[53] = get_point(0x5000, 0);
+    dbg_cylinder_vertex[54] = get_point(0x6000, 1);
+    dbg_cylinder_vertex[55] = get_point(0x6000, 0);
+    dbg_cylinder_vertex[56] = get_point(0x7000, 1);
+    dbg_cylinder_vertex[57] = get_point(0x7000, 0);
+    dbg_cylinder_vertex[58] = get_point(0x8000, 1);
+    dbg_cylinder_vertex[59] = get_point(0x8000, 0);
+
+    // Third wall
+    dbg_cylinder_vertex[60] = get_point(0x8000, 1);
+    dbg_cylinder_vertex[61] = get_point(0x8000, 0);
+    dbg_cylinder_vertex[62] = get_point(0x9000, 1);
+    dbg_cylinder_vertex[63] = get_point(0x9000, 0);
+    dbg_cylinder_vertex[64] = get_point(0xA000, 1);
+    dbg_cylinder_vertex[65] = get_point(0xA000, 0);
+    dbg_cylinder_vertex[66] = get_point(0xB000, 1);
+    dbg_cylinder_vertex[67] = get_point(0xB000, 0);
+    dbg_cylinder_vertex[68] = get_point(0xC000, 1);
+    dbg_cylinder_vertex[69] = get_point(0xC000, 0);
+
+    // Fourth wall
+    dbg_cylinder_vertex[70] = get_point(0xC000, 1);
+    dbg_cylinder_vertex[71] = get_point(0xC000, 0);
+    dbg_cylinder_vertex[72] = get_point(0xD000, 1);
+    dbg_cylinder_vertex[73] = get_point(0xD000, 0);
+    dbg_cylinder_vertex[74] = get_point(0xE000, 1);
+    dbg_cylinder_vertex[75] = get_point(0xE000, 0);
+    dbg_cylinder_vertex[76] = get_point(0xF000, 1);
+    dbg_cylinder_vertex[77] = get_point(0xF000, 0);
+    dbg_cylinder_vertex[78] = get_point(0x0000, 1);
+    dbg_cylinder_vertex[79] = get_point(0x0000, 0);
+}
+
+//
+// Debug Hitbox
+//
+
+static const Lights1 dbg_cylinder_hitbox_light = gdSPDefLights1(
+    0x40, 0xc0, 0xff,
+    0x40, 0xc0, 0xff,
+    0x28, 0x28, 0x28
+);
+
+static const Gfx dbg_cylinder_hitbox_dl[] = {
+    gsDPPipeSync(),
+    gsDPSetCombineMode(G_CC_SHADEFADEA, G_CC_SHADEFADEA),
+    gsDPSetEnvColor(255, 255, 255, 120),
+    gsSPLight(&dbg_cylinder_hitbox_light.l, 1),
+    gsSPLight(&dbg_cylinder_hitbox_light.a, 2),
+    gsSPDisplayList(dbg_cylinder_vertex_dl),
+    gsDPSetEnvColor(255, 255, 255, 255),
+    gsDPSetCombineMode(G_CC_SHADE, G_CC_SHADE),
+    gsSPEndDisplayList(),
+};
+
+const GeoLayout dbg_cylinder_hitbox_geo[] = {
+    GEO_SHADOW(SHADOW_CIRCLE_4_VERTS, 0x9B, 0),
+    GEO_OPEN_NODE(),
+        GEO_DISPLAY_LIST(LAYER_TRANSPARENT, dbg_cylinder_hitbox_dl),
+    GEO_CLOSE_NODE(),
+    GEO_END(),
+};
+
+static void bhv_smo_debug_hitbox() {
+    if (gCurrentObject->parentObj == NULL) {
+        obj_mark_for_deletion(gCurrentObject);
+    } else {
+        gCurrentObject->oPosX = gCurrentObject->parentObj->oPosX;
+        gCurrentObject->oPosZ = gCurrentObject->parentObj->oPosZ;
+        gCurrentObject->header.gfx.pos[0] = gCurrentObject->parentObj->oPosX;
+        gCurrentObject->header.gfx.pos[2] = gCurrentObject->parentObj->oPosZ;
+        if (gMarioObject && gCurrentObject->parentObj == gMarioState->oPossessedObject) {
+            gCurrentObject->oPosY = gCurrentObject->parentObj->oPosY - gCurrentObject->parentObj->oStickMag;
+            gCurrentObject->header.gfx.pos[1] = gCurrentObject->parentObj->oPosY - gCurrentObject->parentObj->oStickMag;
+            gCurrentObject->header.gfx.scale[0] = gCurrentObject->parentObj->oStickX / 100.f;
+            gCurrentObject->header.gfx.scale[1] = gCurrentObject->parentObj->oStickY / 100.f;
+            gCurrentObject->header.gfx.scale[2] = gCurrentObject->parentObj->oStickX / 100.f;
+        } else {
+            gCurrentObject->oPosY = gCurrentObject->parentObj->oPosY - gCurrentObject->parentObj->hitboxDownOffset;
+            gCurrentObject->header.gfx.pos[1] = gCurrentObject->parentObj->oPosY - gCurrentObject->parentObj->hitboxDownOffset;
+            gCurrentObject->header.gfx.scale[0] = gCurrentObject->parentObj->hitboxRadius / 100.f;
+            gCurrentObject->header.gfx.scale[1] = gCurrentObject->parentObj->hitboxHeight / 100.f;
+            gCurrentObject->header.gfx.scale[2] = gCurrentObject->parentObj->hitboxRadius / 100.f;
+        }
+        gCurrentObject->parentObj = NULL;
+    }
+}
+
+static const BehaviorScript bhvSmoDebugHitbox[] = {
+    0x000C0000,
+    0x08000000,
+    0x0C000000, (uintptr_t) bhv_smo_debug_hitbox,
+    0x09000000,
+};
+
+//
+// Debug Hurtbox
+//
+
+static const Lights1 dbg_cylinder_hurtbox_light = gdSPDefLights1(
+    0xff, 0x40, 0x40,
+    0xff, 0x40, 0x40,
+    0x28, 0x28, 0x28
+);
+
+static const Gfx dbg_cylinder_hurtbox_dl[] = {
+    gsDPPipeSync(),
+    gsDPSetCombineMode(G_CC_SHADEFADEA, G_CC_SHADEFADEA),
+    gsDPSetEnvColor(255, 255, 255, 120),
+    gsSPLight(&dbg_cylinder_hurtbox_light.l, 1),
+    gsSPLight(&dbg_cylinder_hurtbox_light.a, 2),
+    gsSPDisplayList(dbg_cylinder_vertex_dl),
+    gsDPSetEnvColor(255, 255, 255, 255),
+    gsDPSetCombineMode(G_CC_SHADE, G_CC_SHADE),
+    gsSPEndDisplayList(),
+};
+
+const GeoLayout dbg_cylinder_hurtbox_geo[] = {
+    GEO_SHADOW(SHADOW_CIRCLE_4_VERTS, 0x9B, 0),
+    GEO_OPEN_NODE(),
+        GEO_DISPLAY_LIST(LAYER_TRANSPARENT, dbg_cylinder_hurtbox_dl),
+    GEO_CLOSE_NODE(),
+    GEO_END(),
+};
+
+static void bhv_smo_debug_hurtbox() {
+    if (gCurrentObject->parentObj == NULL) {
+        obj_mark_for_deletion(gCurrentObject);
+    } else {
+        gCurrentObject->oPosX = gCurrentObject->parentObj->oPosX;
+        gCurrentObject->oPosY = gCurrentObject->parentObj->oPosY - gCurrentObject->parentObj->hitboxDownOffset;
+        gCurrentObject->oPosZ = gCurrentObject->parentObj->oPosZ;
+        gCurrentObject->header.gfx.pos[0] = gCurrentObject->parentObj->oPosX;
+        gCurrentObject->header.gfx.pos[1] = gCurrentObject->parentObj->oPosY - gCurrentObject->parentObj->hitboxDownOffset;
+        gCurrentObject->header.gfx.pos[2] = gCurrentObject->parentObj->oPosZ;
+        gCurrentObject->header.gfx.scale[0] = gCurrentObject->parentObj->hurtboxRadius / 100.f;
+        gCurrentObject->header.gfx.scale[1] = gCurrentObject->parentObj->hurtboxHeight / 100.f;
+        gCurrentObject->header.gfx.scale[2] = gCurrentObject->parentObj->hurtboxRadius / 100.f;
+        gCurrentObject->parentObj = NULL;
+    }
+}
+
+static const BehaviorScript bhvSmoDebugHurtbox[] = {
+    0x000C0000,
+    0x08000000,
+    0x0C000000, (uintptr_t) bhv_smo_debug_hurtbox,
+    0x09000000,
+};
+
+//
+// Debug Object
+//
+
+static void smo_debug_display_objects_hitbox_from_list(s8 type) {
+    struct ObjectNode *list = &gObjectLists[type];
+    struct Object *next = obj_get_first(list);
+    while (next != NULL) {
+        struct Object *obj = next;
+        if (obj == gMarioObject && gMarioState->action == ACT_SMO_POSSESSION) {
+            obj = gMarioState->oPossessedObject;
+        }
+        if (obj_get_first_child_with_behavior(obj, bhvSmoDebugHitbox)  == NULL &&
+            obj_get_first_child_with_behavior(obj, bhvSmoDebugHurtbox) == NULL) {
+            spawn_object(obj, MODEL_DBG_CYLINDER_HITBOX, bhvSmoDebugHitbox);
+            spawn_object(obj, MODEL_DBG_CYLINDER_HURTBOX, bhvSmoDebugHurtbox);
+        }
+        next = obj_get_next(list, next);
+    }
+}
+
+static void smo_debug_display_objects_hitbox() {
+    smo_debug_set_vertex_data();
+    smo_debug_display_objects_hitbox_from_list(OBJ_LIST_SURFACE);
+    smo_debug_display_objects_hitbox_from_list(OBJ_LIST_POLELIKE);
+    smo_debug_display_objects_hitbox_from_list(OBJ_LIST_PLAYER);
+    smo_debug_display_objects_hitbox_from_list(OBJ_LIST_PUSHABLE);
+    smo_debug_display_objects_hitbox_from_list(OBJ_LIST_GENACTOR);
+    smo_debug_display_objects_hitbox_from_list(OBJ_LIST_DESTRUCTIVE);
+    smo_debug_display_objects_hitbox_from_list(OBJ_LIST_LEVEL);
+}
diff --git a/data/smo/debug/smo_debug_text.inl b/data/smo/debug/smo_debug_text.inl
new file mode 100644
index 0000000..22b9512
--- /dev/null
+++ b/data/smo/debug/smo_debug_text.inl
@@ -0,0 +1,106 @@
+//
+// Debug String
+//
+
+#define DEBUG_CHAR_WIDTH        7
+#define DEBUG_LINE_HEIGHT       14
+#define DEBUG_STRING_MAX_LENGTH 256
+#define DEBUG_MAX_STRINGS       64
+
+struct DebugString {
+    u8 str[DEBUG_STRING_MAX_LENGTH];
+    s32 x;
+    s32 y;
+    u32 rgbaFront;
+    u32 rgbaBack;
+};
+static struct DebugString sDebugStrings[DEBUG_MAX_STRINGS];
+static u32 sDebugStringCount = 0;
+
+static void smo_debug_render_string(s16 x, s16 y, const u8 *str) {
+    create_dl_translation_matrix(MENU_MTX_PUSH, x, y, 0.0f);
+    for (; *str != DIALOG_CHAR_TERMINATOR; ++str) {
+        if (*str != DIALOG_CHAR_SPACE) {
+            void **fontLUT = segmented_to_virtual(main_font_lut);
+            void *packedTexture = segmented_to_virtual(fontLUT[*str]);
+            gDPPipeSync(gDisplayListHead++);
+            gDPSetTextureImage(gDisplayListHead++, G_IM_FMT_IA, G_IM_SIZ_16b, 1, VIRTUAL_TO_PHYSICAL(packedTexture));
+            gSPDisplayList(gDisplayListHead++, dl_ia_text_tex_settings);
+        }
+        create_dl_translation_matrix(MENU_MTX_NOPUSH, DEBUG_CHAR_WIDTH, 0.0f, 0.0f);
+    }
+    gSPPopMatrix(gDisplayListHead++, G_MTX_MODELVIEW);
+}
+
+static void smo_debug_print_string(u32 i) {
+    struct DebugString *dbgStr = &sDebugStrings[i];
+    s32 x0 = GFX_DIMENSIONS_FROM_LEFT_EDGE(dbgStr->x);
+    s32 y0 = dbgStr->y;
+
+    // Background
+    if ((dbgStr->rgbaBack && 0xFF) != 0) {
+        gDPSetEnvColor(gDisplayListHead++, ((dbgStr->rgbaBack >> 24) & 0xFF), ((dbgStr->rgbaBack >> 16) & 0xFF), ((dbgStr->rgbaBack >> 8) & 0xFF), ((dbgStr->rgbaBack >> 0) & 0xFF));
+        smo_debug_render_string(x0 + 1, y0 - 1, dbgStr->str);
+    }
+
+    // Foreground
+    if ((dbgStr->rgbaFront && 0xFF) != 0) {
+        gDPSetEnvColor(gDisplayListHead++, ((dbgStr->rgbaFront >> 24) & 0xFF), ((dbgStr->rgbaFront >> 16) & 0xFF), ((dbgStr->rgbaFront >> 8) & 0xFF), ((dbgStr->rgbaFront >> 0) & 0xFF));
+        smo_debug_render_string(x0, y0, dbgStr->str);
+    }
+}
+
+//
+// Debug Text
+//
+
+void smo_debug_add_string(s32 x, s32 y, u32 rgbaFront, u32 rgbaBack, const char *fmt, ...) {
+    if (!fmt || sDebugStringCount == DEBUG_MAX_STRINGS) {
+        return;
+    }
+
+    char str[1024];
+    va_list arg;
+    va_start(arg, fmt);
+    s32 len = vsprintf(str, fmt, arg);
+    va_end(arg);
+    len = MAX(0, MIN(DEBUG_STRING_MAX_LENGTH - 1, len));
+    if (len == 0) {
+        return;
+    }
+
+    struct DebugString *dbgStr = &sDebugStrings[sDebugStringCount++];
+    for (s32 i = 0; i != len; ++i) {
+        char c = str[i];
+        if (c >= '0' && c <= '9') {
+            dbgStr->str[i] = (u8)(c - '0');
+        } else if (c >= 'A' && c <= 'Z') {
+            dbgStr->str[i] = (u8)(c - 'A' + 10);
+        } else if (c >= 'a' && c <= 'z') {
+            dbgStr->str[i] = (u8)(c - 'a' + 36);
+        } else if (c == '\'') {
+            dbgStr->str[i] = 62;
+        } else if (c == '.') {
+            dbgStr->str[i] = 63;
+        } else if (c == '-') {
+            dbgStr->str[i] = 159;
+        } else {
+            dbgStr->str[i] = DIALOG_CHAR_SPACE;
+        }
+    }
+    dbgStr->str[len] = DIALOG_CHAR_TERMINATOR;
+    dbgStr->x = x;
+    dbgStr->y = y;
+    dbgStr->rgbaFront = rgbaFront;
+    dbgStr->rgbaBack = rgbaBack;
+}
+
+static void smo_debug_display_text() {
+    gSPDisplayList(gDisplayListHead++, dl_ia_text_begin);
+    gDPSetScissor(gDisplayListHead++, G_SC_NON_INTERLACE, 0, 80, SCREEN_WIDTH, SCREEN_HEIGHT);
+    for (u32 i = 0; i != sDebugStringCount; ++i) smo_debug_print_string(i);
+    gDPSetScissor(gDisplayListHead++, G_SC_NON_INTERLACE, 0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
+    gSPDisplayList(gDisplayListHead++, dl_ia_text_end);
+    gDPSetEnvColor(gDisplayListHead++, 255, 255, 255, 255);
+    sDebugStringCount = 0;
+}
diff --git a/data/smo/mario/smo_mario.h b/data/smo/mario/smo_mario.h
new file mode 100644
index 0000000..794b272
--- /dev/null
+++ b/data/smo/mario/smo_mario.h
@@ -0,0 +1,48 @@
+#ifndef SMO_MARIO_H
+#define SMO_MARIO_H
+
+#include "types.h"
+
+/* Actions */
+enum {
+    ACTION_RESULT_BREAK,
+    ACTION_RESULT_CANCEL,
+    ACTION_RESULT_CONTINUE
+};
+
+#define RETURN_CANCEL_IF_ACTION_SET(action, flag)    { if ((flag) && mario_set_smo_action(m, action)) { return ACTION_RESULT_CANCEL; } }
+s32 mario_set_smo_action(struct MarioState *m, u32 action);
+s32 mario_check_wall_slide(struct MarioState *m);
+void update_mario_throw_anim(struct MarioState *m, u32 actEnd);
+
+/* Checks */
+s32 mario_check_smo_stationary_action(struct MarioState *m);
+s32 mario_check_smo_moving_action(struct MarioState *m);
+s32 mario_check_smo_airborne_action(struct MarioState *m);
+s32 mario_check_smo_submerged_action(struct MarioState *m);
+s32 mario_check_smo_cutscene_action(struct MarioState *m);
+
+/* Execution */
+void mario_execute_action(struct MarioState *m);
+
+/* Capture */
+enum {
+    MARIO_UNPOSSESS_ACT_JUMP_OUT,
+    MARIO_UNPOSSESS_ACT_KNOCKED_BACK,
+    MARIO_UNPOSSESS_ACT_KNOCKED_OUT_OF_KING_WHOMP,
+    MARIO_UNPOSSESS_ACT_BURNT,
+    MARIO_UNPOSSESS_ACT_GRABBED,
+    MARIO_UNPOSSESS_ACT_EATEN,
+    MARIO_UNPOSSESS_ACT_BLOWN,
+    MARIO_UNPOSSESS_ACT_TORNADO,
+    MARIO_UNPOSSESS_ACT_COUNT
+};
+
+s32 mario_possess_object(struct MarioState *m, struct Object *obj);
+s32 mario_unpossess_object(struct MarioState *m, u8 unpossessAct, s32 isBackwards, u32 objIntangibleFrames);
+
+s32 mario_lock(struct MarioState *m);
+s32 mario_unlock(struct MarioState *m);
+s32 smo_act_possession(struct MarioState *m);
+
+#endif // SMO_MARIO_H
diff --git a/data/smo/mario/smo_mario_actions.c b/data/smo/mario/smo_mario_actions.c
new file mode 100644
index 0000000..50ff789
--- /dev/null
+++ b/data/smo/mario/smo_mario_actions.c
@@ -0,0 +1,294 @@
+#include "../smo_c_includes.h"
+
+static s32 mario_throw_cappy(struct MarioState *m, u32 action) {
+    u32 throwType;
+    switch (action) {
+        case ACT_SMO_CAPPY_THROW_GROUND:
+            throwType = mario_spawn_cappy(m, CAPPY_ACT_FLAG_GROUND);
+            if (throwType) {
+                set_mario_action(m, ACT_SMO_CAPPY_THROW_GROUND, throwType);
+                m->faceAngle[1] = m->intendedYaw;
+                return TRUE;
+            }
+            break;
+
+        case ACT_SMO_CAPPY_THROW_AIRBORNE:
+            throwType = mario_spawn_cappy(m, CAPPY_ACT_FLAG_AIRBORNE);
+            if (throwType) {
+                set_mario_action(m, ACT_SMO_CAPPY_THROW_AIRBORNE, throwType);
+                mario_set_forward_vel(m, MIN(m->forwardVel, 8.f));
+                m->vel[1] = 16.f;
+                m->faceAngle[1] = m->intendedYaw;
+                return TRUE;
+            }
+            break;
+
+        case ACT_SMO_CAPPY_THROW_WATER:
+            throwType = mario_spawn_cappy(m, CAPPY_ACT_FLAG_WATER);
+            if (throwType) {
+                set_mario_action(m, ACT_SMO_CAPPY_THROW_WATER, throwType);
+                return TRUE;
+            }
+            break;
+
+        case ACT_SMO_CAPPY_THROW_METAL_WATER_FLOOR:
+            throwType = mario_spawn_cappy(m, CAPPY_ACT_FLAG_METAL_WATER);
+            if (throwType) {
+                set_mario_action(m, ACT_SMO_CAPPY_THROW_METAL_WATER_FLOOR, throwType);
+                m->faceAngle[1] = m->intendedYaw;
+                return TRUE;
+            }
+            break;
+
+        case ACT_SMO_CAPPY_THROW_METAL_WATER_AIR:
+            throwType = mario_spawn_cappy(m, CAPPY_ACT_FLAG_METAL_WATER);
+            if (throwType) {
+                set_mario_action(m, ACT_SMO_CAPPY_THROW_METAL_WATER_AIR, throwType);
+                mario_set_forward_vel(m, MIN(m->forwardVel, 8.f));
+                m->vel[1] = 16.f;
+                m->faceAngle[1] = m->intendedYaw;
+                return TRUE;
+            }
+            break;
+    }
+    return FALSE;
+}
+
+s32 mario_set_smo_action(struct MarioState *m, u32 action) {
+    switch (action) {
+    
+        /* Cappy throws */
+        case ACT_SMO_CAPPY_THROW_GROUND:
+        case ACT_SMO_CAPPY_THROW_AIRBORNE:
+        case ACT_SMO_CAPPY_THROW_WATER:
+        case ACT_SMO_CAPPY_THROW_METAL_WATER_FLOOR:
+        case ACT_SMO_CAPPY_THROW_METAL_WATER_AIR:
+            if (m->controller->buttonPressed & SMO_CAPPY_BUTTON) {
+                if (mario_throw_cappy(m, action)) {
+                    return TRUE;
+                }
+            }
+            break;
+
+        /* Roll */
+        case ACT_SMO_ROLLING:
+            if (m->input & INPUT_B_PRESSED) {
+                set_mario_action(m, ACT_SMO_ROLLING, 0);
+                set_mario_animation(m, MARIO_ANIM_FORWARD_SPINNING);
+                mario_set_forward_vel(m, 56.f);
+                m->particleFlags |= PARTICLE_HORIZONTAL_STAR;
+                return TRUE;
+            }
+            break;
+
+        /* Ground pound jump */
+        case ACT_SMO_GROUND_POUND_JUMP:
+            if (m->input & INPUT_A_PRESSED) {
+                set_mario_action(m, ACT_SMO_GROUND_POUND_JUMP, 0);
+                m->vel[1] = 66.f;
+                return TRUE;
+            }
+            break;
+
+        /* Moving punch */
+        case ACT_MOVE_PUNCHING:
+            if (m->input & INPUT_B_PRESSED) {
+                set_mario_action(m, ACT_MOVE_PUNCHING, 0);
+                return TRUE;
+            }
+            break;
+
+        /* Air dive */
+        case ACT_DIVE:
+            if ((m->input & INPUT_B_PRESSED) && ((m->input & INPUT_Z_PRESSED) || (m->action == ACT_GROUND_POUND))) {
+                set_mario_action(m, ACT_DIVE, 0);
+                mario_set_forward_vel(m, 32.f);
+                m->vel[1] = 40.f;
+                m->particleFlags |= PARTICLE_MIST_CIRCLE;
+                return TRUE;
+            }
+            break;
+
+        /* Jump kick */
+        case ACT_JUMP_KICK:
+            if (m->input & INPUT_B_PRESSED) {
+                set_mario_action(m, ACT_JUMP_KICK, 0);
+                return TRUE;
+            }
+            break;
+
+        /* Ground pound */
+        case ACT_GROUND_POUND:
+            if (m->input & INPUT_Z_PRESSED) {
+                set_mario_action(m, ACT_GROUND_POUND, 0);
+                return TRUE;
+            }
+            break;
+
+        /* Water descent */
+        case ACT_SMO_WATER_DESCENT:
+            if (m->input & INPUT_Z_PRESSED) {
+                set_mario_action(m, ACT_SMO_WATER_DESCENT, 0);
+                return TRUE;
+            }
+            break;
+
+
+        /* Water dash */
+        case ACT_SMO_WATER_DASH:
+            if ((m->input & INPUT_B_PRESSED) && ((m->input & INPUT_Z_PRESSED) || (m->action == ACT_SMO_WATER_DESCENT))) {
+                set_mario_action(m, ACT_SMO_WATER_DASH, 0);
+                return TRUE;
+            }
+            break;
+
+        /* Metal water punch */
+        case ACT_SMO_METAL_WATER_PUNCH:
+            if (m->input & INPUT_B_PRESSED) {
+                set_mario_action(m, ACT_SMO_METAL_WATER_PUNCH, 0);
+                play_sound(SOUND_MARIO_PUNCH_YAH, m->marioObj->header.gfx.cameraToObject);
+                m->marioObj->header.gfx.unk38.animID = -1;
+                set_mario_animation(m, MARIO_ANIM_FIRST_PUNCH);
+                return TRUE;
+            }
+            break;
+
+        /* Metal water kick */
+        case ACT_SMO_METAL_WATER_KICK:
+            if (m->input & INPUT_B_PRESSED) {
+                set_mario_action(m, ACT_SMO_METAL_WATER_KICK, 0);
+                play_sound_if_no_flag(m, SOUND_MARIO_PUNCH_HOO, MARIO_ACTION_SOUND_PLAYED);
+                m->marioObj->header.gfx.unk38.animID = -1;
+                set_mario_animation(m, MARIO_ANIM_AIR_KICK);
+                m->vel[1] = 16.f;
+                return TRUE;
+            }
+            break;
+    }
+    return FALSE;
+}
+
+s32 mario_check_wall_slide(struct MarioState *m) {
+    // Wall slide available
+    if (SMO_MARIO == 0 || !m->oWallSlide) {
+        return FALSE;
+    }
+
+    // There must be a wall
+    if (m->wall == NULL) {
+        return FALSE;
+    }
+
+    // Not a painting
+    s16 stype = m->wall->type;
+    if (stype >= SURFACE_PAINTING_WOBBLE_A6 && stype <= SURFACE_WOBBLING_WARP) {
+        return FALSE;
+    }
+
+    // Mario must not be holding something
+    if (m->heldObj != NULL) {
+        return FALSE;
+    }
+
+    return TRUE;
+}
+
+static const s32 sThrowSounds[] = {
+    SOUND_MARIO_PUNCH_YAH,
+    SOUND_MARIO_PUNCH_WAH,
+    SOUND_MARIO_PUNCH_HOO,
+    SOUND_MARIO_YAHOO_WAHA_YIPPEE + (0 << 16),  // Yahoo
+    SOUND_MARIO_YAHOO_WAHA_YIPPEE + (3 << 16),  // Waha
+    SOUND_MARIO_YAHOO_WAHA_YIPPEE + (4 << 16),  // Yippee
+};
+
+void update_mario_throw_anim(struct MarioState *m, u32 actEnd) {
+    switch (m->actionArg) {
+
+        // Cappy normal throw
+        case 1:
+            m->marioObj->header.gfx.unk38.animID = -1;
+            play_sound(sThrowSounds[random_u16() % 3], m->marioObj->header.gfx.cameraToObject);
+            set_mario_anim_with_accel(m, MARIO_ANIM_GROUND_THROW, 0x18000);
+            // Fall-through:
+        case 3:
+            m->actionArg = 3;
+            if (is_anim_past_end(m)) {
+                set_mario_action(m, actEnd, 0);
+            }
+            break;
+
+        // Cappy spin throw
+        case 2:
+            m->marioObj->header.gfx.unk38.animID = -1;
+            play_sound(sThrowSounds[3 + (random_u16() % 3)], m->marioObj->header.gfx.cameraToObject);
+            set_mario_animation(m, MARIO_ANIM_STAR_DANCE);
+            m->marioObj->header.gfx.unk38.animFrame = 4;
+            // Fall-through:
+        case 4:
+            m->actionArg = 4;
+            if (m->marioObj->header.gfx.unk38.animFrame >= 20) {
+                set_mario_action(m, actEnd, 0);
+            }
+            break;
+    }
+}
+
+//
+// Execution
+//
+
+#include "game/mario_actions_stationary.h"
+#include "game/mario_actions_moving.h"
+#include "game/mario_actions_airborne.h"
+#include "game/mario_actions_submerged.h"
+#include "game/mario_actions_cutscene.h"
+#include "game/mario_actions_automatic.h"
+#include "game/mario_actions_object.h"
+
+static s32 (*sCheckActionFunction[])(struct MarioState *) = {
+    mario_check_smo_stationary_action,
+    mario_check_smo_moving_action,
+    mario_check_smo_airborne_action,
+    mario_check_smo_submerged_action,
+    mario_check_smo_cutscene_action,
+    NULL,
+    NULL
+};
+
+static s32 (*sExecuteActionFunction[])(struct MarioState *) = {
+    mario_execute_stationary_action,
+    mario_execute_moving_action,
+    mario_execute_airborne_action,
+    mario_execute_submerged_action,
+    mario_execute_cutscene_action,
+    mario_execute_automatic_action,
+    mario_execute_object_action,
+};
+
+void mario_execute_action(struct MarioState *m) {
+    for (;;) {
+        s32 group = ((m->action & ACT_GROUP_MASK) >> 6);
+        s32 actResult = ACTION_RESULT_CONTINUE;
+        s32 (*check)(struct MarioState *) = sCheckActionFunction[group];
+        s32 (*exec)(struct MarioState *) = sExecuteActionFunction[group];
+
+        // Check SMO actions
+        if (check != NULL) {
+            actResult = check(m);
+        }
+
+        // Execute SM64 actions
+        if (actResult == ACTION_RESULT_CONTINUE) {
+            actResult = exec(m);
+        }
+        
+        // Cancel? -> loop again
+        // Break? -> end loop
+        if (actResult == ACTION_RESULT_CANCEL) {
+            continue;
+        } else if (actResult == ACTION_RESULT_BREAK) {
+            break;
+        }
+    }
+}
diff --git a/data/smo/mario/smo_mario_actions_airborne.c b/data/smo/mario/smo_mario_actions_airborne.c
new file mode 100644
index 0000000..6fe9633
--- /dev/null
+++ b/data/smo/mario/smo_mario_actions_airborne.c
@@ -0,0 +1,345 @@
+#include "../smo_c_includes.h"
+#include "game/mario_actions_airborne.h"
+
+#define MARIO_WALL_SLIDE_SPEED -16.f
+
+static void smo_lava_boost_on_wall(struct MarioState *m) {
+    m->faceAngle[1] = atan2s(m->wall->normal.z, m->wall->normal.x);
+    m->forwardVel = MAX(24.f, m->forwardVel);
+    if (!(m->flags & MARIO_METAL_CAP)) {
+        m->hurtCounter += (m->flags & MARIO_CAP_ON_HEAD) ? 12 : 18;
+    }
+
+    play_sound(SOUND_MARIO_ON_FIRE, m->marioObj->header.gfx.cameraToObject);
+    update_mario_sound_and_camera(m);
+    drop_and_set_mario_action(m, ACT_LAVA_BOOST, 1);
+}
+
+//
+// Actions
+//
+
+static s32 smo_act_jump(struct MarioState *m) {
+    RETURN_CANCEL_IF_ACTION_SET(ACT_DIVE, SMO_MARIO == 1);
+    RETURN_CANCEL_IF_ACTION_SET(ACT_JUMP_KICK, SMO_MARIO == 1);
+    RETURN_CANCEL_IF_ACTION_SET(ACT_SMO_CAPPY_THROW_AIRBORNE, SMO_CAPPY != 0);
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_double_jump(struct MarioState *m) {
+    RETURN_CANCEL_IF_ACTION_SET(ACT_DIVE, SMO_MARIO == 1);
+    RETURN_CANCEL_IF_ACTION_SET(ACT_JUMP_KICK, SMO_MARIO == 1);
+    RETURN_CANCEL_IF_ACTION_SET(ACT_SMO_CAPPY_THROW_AIRBORNE, SMO_CAPPY != 0);
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_triple_jump(struct MarioState *m) {
+    RETURN_CANCEL_IF_ACTION_SET(ACT_DIVE, SMO_MARIO == 1);
+    RETURN_CANCEL_IF_ACTION_SET(ACT_JUMP_KICK, SMO_MARIO == 1);
+    RETURN_CANCEL_IF_ACTION_SET(ACT_SMO_CAPPY_THROW_AIRBORNE, SMO_CAPPY != 0);
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_backflip(struct MarioState *m) {
+    RETURN_CANCEL_IF_ACTION_SET(ACT_DIVE, SMO_MARIO == 1);
+    RETURN_CANCEL_IF_ACTION_SET(ACT_JUMP_KICK, SMO_MARIO == 1);
+    RETURN_CANCEL_IF_ACTION_SET(ACT_SMO_CAPPY_THROW_AIRBORNE, SMO_CAPPY != 0);
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_long_jump(struct MarioState *m) {
+    RETURN_CANCEL_IF_ACTION_SET(ACT_DIVE, SMO_MARIO == 1);
+    RETURN_CANCEL_IF_ACTION_SET(ACT_JUMP_KICK, SMO_MARIO == 1);
+    RETURN_CANCEL_IF_ACTION_SET(ACT_SMO_CAPPY_THROW_AIRBORNE, SMO_CAPPY != 0);
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_freefall(struct MarioState *m) {
+    RETURN_CANCEL_IF_ACTION_SET(ACT_DIVE, SMO_MARIO == 1);
+    RETURN_CANCEL_IF_ACTION_SET(ACT_JUMP_KICK, SMO_MARIO == 1);
+    RETURN_CANCEL_IF_ACTION_SET(ACT_SMO_CAPPY_THROW_AIRBORNE, SMO_CAPPY != 0);
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_side_flip(struct MarioState *m) {
+    RETURN_CANCEL_IF_ACTION_SET(ACT_DIVE, SMO_MARIO == 1);
+    RETURN_CANCEL_IF_ACTION_SET(ACT_JUMP_KICK, SMO_MARIO == 1);
+    RETURN_CANCEL_IF_ACTION_SET(ACT_SMO_CAPPY_THROW_AIRBORNE, SMO_CAPPY != 0);
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_wall_kick_air(struct MarioState *m) {
+    RETURN_CANCEL_IF_ACTION_SET(ACT_DIVE, SMO_MARIO == 1);
+    RETURN_CANCEL_IF_ACTION_SET(ACT_JUMP_KICK, SMO_MARIO == 1);
+    RETURN_CANCEL_IF_ACTION_SET(ACT_SMO_CAPPY_THROW_AIRBORNE, SMO_CAPPY != 0);
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_water_jump(struct MarioState *m) {
+    RETURN_CANCEL_IF_ACTION_SET(ACT_DIVE, SMO_MARIO == 1);
+    RETURN_CANCEL_IF_ACTION_SET(ACT_JUMP_KICK, SMO_MARIO == 1);
+    RETURN_CANCEL_IF_ACTION_SET(ACT_GROUND_POUND, SMO_MARIO == 1);
+    RETURN_CANCEL_IF_ACTION_SET(ACT_SMO_CAPPY_THROW_AIRBORNE, SMO_CAPPY != 0);
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_steep_jump(struct MarioState *m) {
+    RETURN_CANCEL_IF_ACTION_SET(ACT_DIVE, SMO_MARIO == 1);
+    RETURN_CANCEL_IF_ACTION_SET(ACT_JUMP_KICK, SMO_MARIO == 1);
+    RETURN_CANCEL_IF_ACTION_SET(ACT_SMO_CAPPY_THROW_AIRBORNE, SMO_CAPPY != 0);
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_ground_pound(struct MarioState *m) {
+    RETURN_CANCEL_IF_ACTION_SET(ACT_DIVE, SMO_MARIO == 1);
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_burning_jump(struct MarioState *m) {
+    if (SMO_HEALTH != 0 && m->marioObj->oMarioBurnTimer == 0) {
+        m->hurtCounter += 1;
+    }
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_burning_fall(struct MarioState *m) {
+    if (SMO_HEALTH != 0 && m->marioObj->oMarioBurnTimer == 0) {
+        m->hurtCounter += 1;
+    }
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_backward_air_kb(struct MarioState *m) {
+    if (SMO_MARIO == 1) {
+        m->input &= ~INPUT_A_PRESSED;
+    }
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_forward_air_kb(struct MarioState *m) {
+    if (SMO_MARIO == 1) {
+        m->input &= ~INPUT_A_PRESSED;
+    }
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_soft_bonk(struct MarioState *m) {
+    if (SMO_MARIO == 1) {
+        m->input &= ~INPUT_A_PRESSED;
+    }
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_air_hit_wall(struct MarioState *m) {
+    if (SMO_MARIO == 1) {
+        m->input &= ~INPUT_A_PRESSED;
+        if (mario_check_wall_slide(m)) {
+            set_mario_action(m, ACT_SMO_WALL_SLIDE, 0);
+            return ACTION_RESULT_CANCEL;
+        }
+    }
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_jump_kick(struct MarioState *m) {
+    RETURN_CANCEL_IF_ACTION_SET(ACT_DIVE, SMO_MARIO == 1);
+    RETURN_CANCEL_IF_ACTION_SET(ACT_GROUND_POUND, SMO_MARIO == 1);
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_flying(struct MarioState *m) {
+    if (SMO_CAPPY != 0 && (m->controller->buttonPressed & SMO_CAPPY_BUTTON) && (m->input & INPUT_A_PRESSED)) {
+        if (mario_spawn_cappy(m, CAPPY_ACT_FLAG_FLYING)) {
+            play_sound(SOUND_MARIO_YAHOO_WAHA_YIPPEE + ((2 + (random_u16() % 3)) << 16), m->marioObj->header.gfx.cameraToObject);
+        }
+    }
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_flying_triple_jump(struct MarioState *m) {
+    if (SMO_MARIO == 1) {
+        m->input &= ~INPUT_B_PRESSED;
+    }
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_top_of_pole_jump(struct MarioState *m) {
+    RETURN_CANCEL_IF_ACTION_SET(ACT_DIVE, SMO_MARIO == 1);
+    RETURN_CANCEL_IF_ACTION_SET(ACT_JUMP_KICK, SMO_MARIO == 1);
+    RETURN_CANCEL_IF_ACTION_SET(ACT_SMO_CAPPY_THROW_AIRBORNE, SMO_CAPPY != 0);
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_wall_slide(struct MarioState *m) {
+    mario_set_forward_vel(m, 0);
+    set_mario_animation(m, MARIO_ANIM_START_WALLKICK);
+    play_sound(SOUND_MOVING_TERRAIN_SLIDE + m->terrainSoundAddend, m->marioObj->header.gfx.cameraToObject);
+    m->vel[1] = MARIO_WALL_SLIDE_SPEED;
+    m->particleFlags |= PARTICLE_DUST;
+
+    // Wall jump
+    if (m->input & INPUT_A_PRESSED) {
+        m->vel[1] = 52.0f;
+        m->faceAngle[1] += 0x8000;
+        mario_set_forward_vel(m, 24.f);
+        set_mario_action(m, ACT_WALL_KICK_AIR, 0);
+        return ACTION_RESULT_CANCEL;
+    }
+
+    // Stop wall sliding
+    if (m->input & INPUT_Z_PRESSED) {
+        m->oWallSlide = FALSE;
+        play_sound(SOUND_MARIO_UH, m->marioObj->header.gfx.cameraToObject);
+        m->input &= (~(INPUT_Z_PRESSED | INPUT_Z_DOWN));
+        set_mario_action(m, ACT_FREEFALL, 0);
+        return ACTION_RESULT_CANCEL;
+    }
+
+    // Cling Mario to the wall before performing the air step,
+    // to avoid missing slightly slanted walls (normal.y near 0, but not 0)
+    if (m->wall) {
+        m->pos[0] -= m->wall->normal.x * 4.f;
+        m->pos[2] -= m->wall->normal.z * 4.f;
+    }
+    switch (perform_air_step(m, 0)) {
+        case AIR_STEP_LANDED:
+            set_mario_action(m, ACT_IDLE, 0);
+            return ACTION_RESULT_CANCEL;
+
+        case AIR_STEP_NONE:
+            set_mario_action(m, ACT_FREEFALL, 0);
+            return ACTION_RESULT_CANCEL;
+
+        case AIR_STEP_HIT_LAVA_WALL:
+            smo_lava_boost_on_wall(m);
+            return ACTION_RESULT_CANCEL;
+
+        case AIR_STEP_HIT_WALL:
+            if (!mario_check_wall_slide(m)) {
+                set_mario_action(m, ACT_FREEFALL, 0);
+                return ACTION_RESULT_CANCEL;
+            }
+            break;
+    }
+
+    // Turn Mario away from the wall
+    m->marioObj->header.gfx.angle[1] = m->faceAngle[1] + 0x8000;
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_cappy_jump(struct MarioState *m) {
+    RETURN_CANCEL_IF_ACTION_SET(ACT_DIVE, SMO_MARIO == 1);
+    RETURN_CANCEL_IF_ACTION_SET(ACT_JUMP_KICK, SMO_MARIO == 1);
+    RETURN_CANCEL_IF_ACTION_SET(ACT_GROUND_POUND, SMO_MARIO == 1);
+    RETURN_CANCEL_IF_ACTION_SET(ACT_SMO_CAPPY_THROW_AIRBORNE, SMO_CAPPY != 0);
+
+    play_mario_sound(m, SOUND_ACTION_TERRAIN_JUMP, SOUND_MARIO_HOOHOO);
+    common_air_action_step(m, ACT_DOUBLE_JUMP_LAND, ((m->vel[1] >= 0.0f) ? MARIO_ANIM_DOUBLE_JUMP_RISE : MARIO_ANIM_DOUBLE_JUMP_FALL), AIR_STEP_CHECK_LEDGE_GRAB | AIR_STEP_CHECK_HANG);
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_ground_pound_jump(struct MarioState *m) {
+    RETURN_CANCEL_IF_ACTION_SET(ACT_DIVE, SMO_MARIO == 1);
+    RETURN_CANCEL_IF_ACTION_SET(ACT_JUMP_KICK, SMO_MARIO == 1);
+    RETURN_CANCEL_IF_ACTION_SET(ACT_GROUND_POUND, SMO_MARIO == 1);
+    RETURN_CANCEL_IF_ACTION_SET(ACT_SMO_CAPPY_THROW_AIRBORNE, SMO_CAPPY != 0);
+
+    m->particleFlags |= PARTICLE_SPARKLES;
+    play_mario_sound(m, SOUND_ACTION_TERRAIN_JUMP, SOUND_MARIO_YAHOO);
+    common_air_action_step(m, ACT_JUMP_LAND, MARIO_ANIM_TRIPLE_JUMP, AIR_STEP_CHECK_LEDGE_GRAB | AIR_STEP_CHECK_HANG);
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_leave_object_jump(struct MarioState *m) {
+    RETURN_CANCEL_IF_ACTION_SET(ACT_DIVE, SMO_MARIO == 1);
+    RETURN_CANCEL_IF_ACTION_SET(ACT_JUMP_KICK, SMO_MARIO == 1);
+    RETURN_CANCEL_IF_ACTION_SET(ACT_GROUND_POUND, SMO_MARIO == 1);
+    RETURN_CANCEL_IF_ACTION_SET(ACT_SMO_CAPPY_THROW_AIRBORNE, SMO_CAPPY != 0);
+
+    m->particleFlags |= PARTICLE_SPARKLES;
+    play_mario_sound(m, SOUND_ACTION_TERRAIN_JUMP, 0);
+    common_air_action_step(m, ACT_JUMP_LAND, MARIO_ANIM_SINGLE_JUMP, AIR_STEP_CHECK_LEDGE_GRAB | AIR_STEP_CHECK_HANG);
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_cappy_throw_airborne(struct MarioState *m) {
+    RETURN_CANCEL_IF_ACTION_SET(ACT_DIVE, SMO_MARIO == 1);
+    RETURN_CANCEL_IF_ACTION_SET(ACT_JUMP_KICK, SMO_MARIO == 1);
+    RETURN_CANCEL_IF_ACTION_SET(ACT_GROUND_POUND, SMO_MARIO == 1);
+    update_mario_throw_anim(m, ACT_FREEFALL);
+    
+    // Update air movement
+    f32 sidewaysSpeed = 0.0f;
+    if (m->input & INPUT_NONZERO_ANALOG) {
+        m->forwardVel += (m->intendedMag / 32.0f) * coss(m->intendedYaw - m->faceAngle[1]) * 1.5f;
+        sidewaysSpeed  = (m->intendedMag / 32.0f) * sins(m->intendedYaw - m->faceAngle[1]) * 1.0f;
+        if (SMO_MARIO == 1) {
+            m->faceAngle[1] += (s16) (sidewaysSpeed * 1024.f);
+            sidewaysSpeed = 0;
+        }
+    }
+    m->forwardVel = approach_f32(m->forwardVel, 0.0f, 0.35f, 0.35f);
+    m->vel[0] = m->slideVelX = (m->forwardVel * sins(m->faceAngle[1])) + (sidewaysSpeed * 10.f * sins(m->faceAngle[1] + 0x4000));
+    m->vel[2] = m->slideVelZ = (m->forwardVel * coss(m->faceAngle[1])) + (sidewaysSpeed * 10.f * coss(m->faceAngle[1] + 0x4000));
+    m->vel[1] += 2.f;
+
+    // Perform air step
+    switch (perform_air_step(m, 0)) {
+        case AIR_STEP_LANDED:
+            set_mario_action(m, ACT_FREEFALL_LAND, 0);
+            break;
+
+        case AIR_STEP_HIT_WALL:
+            mario_set_forward_vel(m, 0.0f);
+            break;
+    }
+    return ACTION_RESULT_CONTINUE;
+}
+
+s32 mario_check_smo_airborne_action(struct MarioState *m) {
+
+    // Fall height
+    if (SMO_MARIO == 1) {
+        m->peakHeight = m->pos[1];
+        if (m->vel[1] >= 0.f || m->action == ACT_FLYING || m->action == ACT_TWIRLING || m->action == ACT_SMO_WALL_SLIDE) {
+            m->oPeakHeight = m->pos[1];
+        }
+        f32 fallHeight = m->oPeakHeight - m->pos[1];
+        if ((fallHeight > SMO_FALL_DAMAGE_HEIGHT) && !(m->action & ACT_FLAG_INVULNERABLE) && !(m->flags & MARIO_UNKNOWN_18)) {
+            play_sound(SOUND_MARIO_WAAAOOOW, m->marioObj->header.gfx.cameraToObject);
+            m->flags |= MARIO_UNKNOWN_18;
+        }
+        gSpecialTripleJump = FALSE;
+    }
+
+    switch (m->action) {
+        case ACT_JUMP:                      return smo_act_jump(m);
+        case ACT_DOUBLE_JUMP:               return smo_act_double_jump(m);
+        case ACT_TRIPLE_JUMP:               return smo_act_triple_jump(m);
+        case ACT_BACKFLIP:                  return smo_act_backflip(m);
+        case ACT_LONG_JUMP:                 return smo_act_long_jump(m);
+        case ACT_FREEFALL:                  return smo_act_freefall(m);
+        case ACT_SIDE_FLIP:                 return smo_act_side_flip(m);
+        case ACT_WALL_KICK_AIR:             return smo_act_wall_kick_air(m);
+        case ACT_WATER_JUMP:                return smo_act_water_jump(m);
+        case ACT_STEEP_JUMP:                return smo_act_steep_jump(m);
+        case ACT_GROUND_POUND:              return smo_act_ground_pound(m);
+        case ACT_BURNING_JUMP:              return smo_act_burning_jump(m);
+        case ACT_BURNING_FALL:              return smo_act_burning_fall(m);
+        case ACT_BACKWARD_AIR_KB:           return smo_act_backward_air_kb(m);
+        case ACT_FORWARD_AIR_KB:            return smo_act_forward_air_kb(m);
+        case ACT_SOFT_BONK:                 return smo_act_soft_bonk(m);
+        case ACT_AIR_HIT_WALL:              return smo_act_air_hit_wall(m);
+        case ACT_JUMP_KICK:                 return smo_act_jump_kick(m);
+        case ACT_FLYING:                    return smo_act_flying(m);
+        case ACT_FLYING_TRIPLE_JUMP:        return smo_act_flying_triple_jump(m);
+        case ACT_TOP_OF_POLE_JUMP:          return smo_act_top_of_pole_jump(m);
+        case ACT_SMO_WALL_SLIDE:            return smo_act_wall_slide(m);
+        case ACT_SMO_CAPPY_JUMP:            return smo_act_cappy_jump(m);
+        case ACT_SMO_GROUND_POUND_JUMP:     return smo_act_ground_pound_jump(m);
+        case ACT_SMO_LEAVE_OBJECT_JUMP:     return smo_act_leave_object_jump(m);
+        case ACT_SMO_CAPPY_THROW_AIRBORNE:  return smo_act_cappy_throw_airborne(m);
+    }
+
+    return ACTION_RESULT_CONTINUE;
+}
diff --git a/data/smo/mario/smo_mario_actions_cutscene.c b/data/smo/mario/smo_mario_actions_cutscene.c
new file mode 100644
index 0000000..83bd6eb
--- /dev/null
+++ b/data/smo/mario/smo_mario_actions_cutscene.c
@@ -0,0 +1,151 @@
+#include "../smo_c_includes.h"
+
+static s32 smo_launch_mario_until_land(struct MarioState *m, s32 endAction, s32 animation, f32 forwardVel) {
+    mario_set_forward_vel(m, forwardVel);
+    set_mario_animation(m, animation);
+    s32 airStepLanded = (perform_air_step(m, 0) == AIR_STEP_LANDED);
+    if (airStepLanded) {
+        set_mario_action(m, endAction, 0);
+    }
+    return airStepLanded;
+}
+
+//
+// Actions
+//
+
+static s32 smo_act_exit_airborne(struct MarioState *m) {
+    if (SMO_HEALTH != 0) {
+        if (15 < m->actionTimer++ && smo_launch_mario_until_land(m, ACT_EXIT_LAND_SAVE_DIALOG, MARIO_ANIM_GENERAL_FALL, -32.0f)) {
+            smo_set_mario_to_full_health(m);
+        }
+        m->marioObj->header.gfx.angle[1] += 0x8000;
+        m->particleFlags |= PARTICLE_SPARKLES;
+        return ACTION_RESULT_BREAK;
+    }
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_falling_exit_airborne(struct MarioState *m) {
+    if (SMO_HEALTH != 0) {
+        if (smo_launch_mario_until_land(m, ACT_EXIT_LAND_SAVE_DIALOG, MARIO_ANIM_GENERAL_FALL, 0.0f)) {
+            smo_set_mario_to_full_health(m);
+        }
+        m->marioObj->header.gfx.angle[1] += 0x8000;
+        m->particleFlags |= PARTICLE_SPARKLES;
+        return ACTION_RESULT_BREAK;
+    }
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_death_exit(struct MarioState *m) {
+    if (SMO_HEALTH != 0) {
+        if (15 < m->actionTimer++ && smo_launch_mario_until_land(m, ACT_DEATH_EXIT_LAND, MARIO_ANIM_GENERAL_FALL, -32.0f)) {
+#ifdef VERSION_JP
+            play_sound(SOUND_MARIO_OOOF, m->marioObj->header.gfx.cameraToObject);
+#else
+            play_sound(SOUND_MARIO_OOOF2, m->marioObj->header.gfx.cameraToObject);
+#endif
+            smo_set_mario_to_full_health(m);
+        } else {
+            m->health = 0xFF;
+            smo_set_hp_counter_to_mario_health(m);
+        }
+        return ACTION_RESULT_BREAK;
+    }
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_unused_death_exit(struct MarioState *m) {
+    if (SMO_HEALTH != 0) {
+        if (smo_launch_mario_until_land(m, ACT_FREEFALL_LAND_STOP, MARIO_ANIM_GENERAL_FALL, 0.0f)) {
+#ifdef VERSION_JP
+            play_sound(SOUND_MARIO_OOOF, m->marioObj->header.gfx.cameraToObject);
+#else
+            play_sound(SOUND_MARIO_OOOF2, m->marioObj->header.gfx.cameraToObject);
+#endif
+            smo_set_mario_to_full_health(m);
+        } else {
+            m->health = 0xFF;
+            smo_set_hp_counter_to_mario_health(m);
+        }
+        return ACTION_RESULT_BREAK;
+    }
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_falling_death_exit(struct MarioState *m) {
+    if (SMO_HEALTH != 0) {
+        if (smo_launch_mario_until_land(m, ACT_DEATH_EXIT_LAND, MARIO_ANIM_GENERAL_FALL, 0.0f)) {
+#ifdef VERSION_JP
+            play_sound(SOUND_MARIO_OOOF, m->marioObj->header.gfx.cameraToObject);
+#else
+            play_sound(SOUND_MARIO_OOOF2, m->marioObj->header.gfx.cameraToObject);
+#endif
+            smo_set_mario_to_full_health(m);
+        } else {
+            m->health = 0xFF;
+            smo_set_hp_counter_to_mario_health(m);
+        }
+        return ACTION_RESULT_BREAK;
+    }
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_special_exit_airborne(struct MarioState *m) {
+    if (SMO_HEALTH != 0) {
+        if (m->actionTimer++ < 11) {
+            m->marioObj->header.gfx.node.flags &= ~GRAPH_RENDER_ACTIVE;
+            return ACTION_RESULT_BREAK;
+        }
+
+        play_sound_if_no_flag(m, SOUND_MARIO_YAHOO, MARIO_MARIO_SOUND_PLAYED);
+        if (smo_launch_mario_until_land(m, ACT_EXIT_LAND_SAVE_DIALOG, MARIO_ANIM_SINGLE_JUMP, -24.0f)) {
+            smo_set_mario_to_full_health(m);
+            m->actionArg = 1;
+        }
+
+        m->particleFlags |= PARTICLE_SPARKLES;
+        m->marioObj->header.gfx.angle[1] += 0x8000;
+        m->marioObj->header.gfx.node.flags |= GRAPH_RENDER_ACTIVE;
+        return ACTION_RESULT_BREAK;
+    }
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_special_death_exit(struct MarioState *m) {
+    if (SMO_HEALTH != 0) {
+        if (m->actionTimer++ < 11) {
+            m->health = 0xFF;
+            smo_set_hp_counter_to_mario_health(m);
+            m->marioObj->header.gfx.node.flags &= ~GRAPH_RENDER_ACTIVE;
+            return ACTION_RESULT_BREAK;
+        }
+
+        if (smo_launch_mario_until_land(m, ACT_HARD_BACKWARD_GROUND_KB, MARIO_ANIM_BACKWARD_AIR_KB, -24.0f)) {
+            smo_set_mario_to_full_health(m);
+        }
+
+        m->marioObj->header.gfx.node.flags |= GRAPH_RENDER_ACTIVE;
+        return ACTION_RESULT_BREAK;
+    }
+    return ACTION_RESULT_CONTINUE;
+}
+
+s32 mario_check_smo_cutscene_action(struct MarioState *m) {
+    m->oCappyJumped = FALSE;
+    m->oWallSlide = TRUE;
+
+    switch (m->action) {
+        case ACT_EXIT_AIRBORNE:         return smo_act_exit_airborne(m);
+        case ACT_FALLING_EXIT_AIRBORNE: return smo_act_falling_exit_airborne(m);
+        case ACT_DEATH_EXIT:            return smo_act_death_exit(m);
+        case ACT_UNUSED_DEATH_EXIT:     return smo_act_unused_death_exit(m);
+        case ACT_FALLING_DEATH_EXIT:    return smo_act_falling_death_exit(m);
+        case ACT_SPECIAL_EXIT_AIRBORNE: return smo_act_special_exit_airborne(m);
+        case ACT_SPECIAL_DEATH_EXIT:    return smo_act_special_death_exit(m);
+        case ACT_SMO_POSSESSION:        return smo_act_possession(m);
+    }
+
+    return ACTION_RESULT_CONTINUE;
+}
diff --git a/data/smo/mario/smo_mario_actions_moving.c b/data/smo/mario/smo_mario_actions_moving.c
new file mode 100644
index 0000000..1b9a104
--- /dev/null
+++ b/data/smo/mario/smo_mario_actions_moving.c
@@ -0,0 +1,209 @@
+#include "../smo_c_includes.h"
+
+#define ROLLING_MAX_DURATION 16
+#define ROLLING_START_REPEAT 8
+
+static void smo_update_facing_yaw(struct MarioState *m) {
+    // More responsive controls
+    if (SMO_MARIO == 1) {
+        m->faceAngle[1] = m->intendedYaw - approach_s32((s16)(m->intendedYaw - m->faceAngle[1]), 0, 0x800, 0x800);
+    }
+}
+
+//
+// Actions
+//
+
+static s32 smo_act_walking(struct MarioState *m) {
+    RETURN_CANCEL_IF_ACTION_SET(ACT_MOVE_PUNCHING, SMO_MARIO == 1);
+    RETURN_CANCEL_IF_ACTION_SET(ACT_SMO_CAPPY_THROW_GROUND, SMO_CAPPY != 0);
+    smo_update_facing_yaw(m);
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_hold_walking(struct MarioState *m) {
+    smo_update_facing_yaw(m);
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_hold_heavy_walking(struct MarioState *m) {
+    smo_update_facing_yaw(m);
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_turning_around(struct MarioState *m) {
+    RETURN_CANCEL_IF_ACTION_SET(ACT_MOVE_PUNCHING, SMO_MARIO == 1);
+    RETURN_CANCEL_IF_ACTION_SET(ACT_SMO_CAPPY_THROW_GROUND, SMO_CAPPY != 0);
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_finish_turning_around(struct MarioState *m) {
+    RETURN_CANCEL_IF_ACTION_SET(ACT_SMO_CAPPY_THROW_GROUND, SMO_CAPPY != 0);
+    smo_update_facing_yaw(m);
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_braking(struct MarioState *m) {
+    RETURN_CANCEL_IF_ACTION_SET(ACT_SMO_CAPPY_THROW_GROUND, SMO_CAPPY != 0);
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_decelerating(struct MarioState *m) {
+    if (!(m->input & INPUT_FIRST_PERSON)) {
+        RETURN_CANCEL_IF_ACTION_SET(ACT_MOVE_PUNCHING, SMO_MARIO == 1);
+        RETURN_CANCEL_IF_ACTION_SET(ACT_SMO_CAPPY_THROW_GROUND, SMO_CAPPY != 0);
+    }
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_crawling(struct MarioState *m) {
+    RETURN_CANCEL_IF_ACTION_SET(ACT_SMO_ROLLING, SMO_MARIO == 1);
+    smo_update_facing_yaw(m);
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_crouch_slide(struct MarioState *m) {
+    RETURN_CANCEL_IF_ACTION_SET(ACT_SMO_ROLLING, SMO_MARIO == 1);
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_jump_land(struct MarioState *m) {
+    RETURN_CANCEL_IF_ACTION_SET(ACT_SMO_CAPPY_THROW_GROUND, SMO_CAPPY != 0);
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_freefall_land(struct MarioState *m) {
+    RETURN_CANCEL_IF_ACTION_SET(ACT_SMO_CAPPY_THROW_GROUND, SMO_CAPPY != 0);
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_double_jump_land(struct MarioState *m) {
+    RETURN_CANCEL_IF_ACTION_SET(ACT_SMO_CAPPY_THROW_GROUND, SMO_CAPPY != 0);
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_side_flip_land(struct MarioState *m) {
+    RETURN_CANCEL_IF_ACTION_SET(ACT_SMO_CAPPY_THROW_GROUND, SMO_CAPPY != 0);
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_triple_jump_land(struct MarioState *m) {
+    RETURN_CANCEL_IF_ACTION_SET(ACT_SMO_CAPPY_THROW_GROUND, SMO_CAPPY != 0);
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_backflip_land(struct MarioState *m) {
+    RETURN_CANCEL_IF_ACTION_SET(ACT_SMO_CAPPY_THROW_GROUND, SMO_CAPPY != 0);
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_quicksand_jump_land(struct MarioState *m) {
+    RETURN_CANCEL_IF_ACTION_SET(ACT_SMO_CAPPY_THROW_GROUND, SMO_CAPPY != 0);
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_long_jump_land(struct MarioState *m) {
+    RETURN_CANCEL_IF_ACTION_SET(ACT_SMO_CAPPY_THROW_GROUND, SMO_CAPPY != 0);
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_burning_ground(struct MarioState *m) {
+    if (SMO_HEALTH != 0 && m->marioObj->oMarioBurnTimer == 0) {
+        m->hurtCounter += 1;
+    }
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_rolling(struct MarioState *m) {
+
+    if (m->actionTimer >= ROLLING_MAX_DURATION) {
+        set_mario_action(m, ACT_WALKING, 0);
+        return ACTION_RESULT_CANCEL;
+    }
+
+    if (m->actionTimer >= ROLLING_START_REPEAT && (m->input & INPUT_Z_DOWN)) {
+        RETURN_CANCEL_IF_ACTION_SET(ACT_SMO_ROLLING, SMO_MARIO == 1);
+    }
+
+    if (m->input & INPUT_A_PRESSED) {
+        set_jump_from_landing(m);
+        return ACTION_RESULT_CANCEL;
+    }
+
+    if ((m->actionTimer % 8) == 0) {
+        play_sound(SOUND_ACTION_TWIRL, m->marioObj->header.gfx.cameraToObject);
+    }
+
+    m->actionTimer++;
+    set_mario_animation(m, MARIO_ANIM_FORWARD_SPINNING);
+    mario_set_forward_vel(m, 60.f);
+
+    switch (perform_ground_step(m)) {
+        case GROUND_STEP_LEFT_GROUND:
+            set_mario_animation(m, MARIO_ANIM_GENERAL_FALL);
+            set_mario_action(m, ACT_FREEFALL, 0);
+            return ACTION_RESULT_CANCEL;
+
+        case GROUND_STEP_HIT_WALL:
+            m->particleFlags |= PARTICLE_VERTICAL_STAR;
+            set_mario_action(m, ACT_BACKWARD_GROUND_KB, 0);
+            return ACTION_RESULT_CANCEL;
+    }
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_cappy_throw_ground(struct MarioState *m) {
+    update_mario_throw_anim(m, ACT_IDLE);
+    mario_set_forward_vel(m, m->forwardVel * 0.85f);
+    switch (perform_ground_step(m)) {
+        case GROUND_STEP_LEFT_GROUND:
+            set_mario_action(m, ACT_FREEFALL, 0);
+            break;
+
+        case GROUND_STEP_HIT_WALL:
+            m->forwardVel = 0;
+            break;
+    }
+    return ACTION_RESULT_CONTINUE;
+}
+
+s32 mario_check_smo_moving_action(struct MarioState *m) {
+    m->oCappyJumped = FALSE;
+    m->oWallSlide = TRUE;
+
+    // Fall damage
+    if (SMO_MARIO == 1) {
+        f32 fallHeight = m->oPeakHeight - m->pos[1];
+        m->peakHeight = m->pos[1];
+        m->oPeakHeight = m->pos[1];
+        if ((fallHeight > SMO_FALL_DAMAGE_HEIGHT) && (m->vel[1] < -50.0f) && (m->action != ACT_TWIRLING) && (m->floor->type != SURFACE_BURNING)) {
+            drop_and_set_mario_action(m, ACT_SMO_SHOCKED_FROM_HIGH_FALL, 0);
+            return ACTION_RESULT_CANCEL;
+        }
+    }
+
+    switch (m->action) {
+        case ACT_WALKING:                   return smo_act_walking(m);    
+        case ACT_HOLD_WALKING:              return smo_act_hold_walking(m);    
+        case ACT_HOLD_HEAVY_WALKING:        return smo_act_hold_heavy_walking(m);    
+        case ACT_TURNING_AROUND:            return smo_act_turning_around(m);           
+        case ACT_FINISH_TURNING_AROUND:     return smo_act_finish_turning_around(m);
+        case ACT_BRAKING:                   return smo_act_braking(m);
+        case ACT_CRAWLING:                  return smo_act_crawling(m);         
+        case ACT_DECELERATING:              return smo_act_decelerating(m);             
+        case ACT_CROUCH_SLIDE:              return smo_act_crouch_slide(m);             
+        case ACT_JUMP_LAND:                 return smo_act_jump_land(m);                
+        case ACT_FREEFALL_LAND:             return smo_act_freefall_land(m);            
+        case ACT_DOUBLE_JUMP_LAND:          return smo_act_double_jump_land(m);         
+        case ACT_SIDE_FLIP_LAND:            return smo_act_side_flip_land(m);
+        case ACT_TRIPLE_JUMP_LAND:          return smo_act_triple_jump_land(m);         
+        case ACT_BACKFLIP_LAND:             return smo_act_backflip_land(m);            
+        case ACT_QUICKSAND_JUMP_LAND:       return smo_act_quicksand_jump_land(m);
+        case ACT_LONG_JUMP_LAND:            return smo_act_long_jump_land(m);
+        case ACT_BURNING_GROUND:            return smo_act_burning_ground(m);
+        case ACT_SMO_ROLLING:               return smo_act_rolling(m);
+        case ACT_SMO_CAPPY_THROW_GROUND:    return smo_act_cappy_throw_ground(m);
+    }
+
+    return ACTION_RESULT_CONTINUE;
+}
diff --git a/data/smo/mario/smo_mario_actions_stationary.c b/data/smo/mario/smo_mario_actions_stationary.c
new file mode 100644
index 0000000..ba11088
--- /dev/null
+++ b/data/smo/mario/smo_mario_actions_stationary.c
@@ -0,0 +1,162 @@
+#include "../smo_c_includes.h"
+
+//
+// Actions
+//
+
+static s32 smo_act_idle(struct MarioState *m) {
+    RETURN_CANCEL_IF_ACTION_SET(ACT_SMO_CAPPY_THROW_GROUND, SMO_CAPPY != 0);
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_start_sleeping(struct MarioState *m) {
+    RETURN_CANCEL_IF_ACTION_SET(ACT_SMO_CAPPY_THROW_GROUND, SMO_CAPPY != 0);
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_sleeping(struct MarioState *m) {
+    RETURN_CANCEL_IF_ACTION_SET(ACT_SMO_CAPPY_THROW_GROUND, SMO_CAPPY != 0);
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_coughing(struct MarioState *m) {
+    RETURN_CANCEL_IF_ACTION_SET(ACT_SMO_CAPPY_THROW_GROUND, SMO_CAPPY != 0);
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_shivering(struct MarioState *m) {
+    RETURN_CANCEL_IF_ACTION_SET(ACT_SMO_CAPPY_THROW_GROUND, SMO_CAPPY != 0);
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_standing_against_wall(struct MarioState *m) {
+    RETURN_CANCEL_IF_ACTION_SET(ACT_SMO_CAPPY_THROW_GROUND, SMO_CAPPY != 0);
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_in_quicksand(struct MarioState *m) {
+    RETURN_CANCEL_IF_ACTION_SET(ACT_SMO_CAPPY_THROW_GROUND, SMO_CAPPY != 0);
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_panting(struct MarioState *m) {
+    RETURN_CANCEL_IF_ACTION_SET(ACT_SMO_CAPPY_THROW_GROUND, SMO_CAPPY != 0);
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_crouching(struct MarioState *m) {
+    RETURN_CANCEL_IF_ACTION_SET(ACT_SMO_ROLLING, SMO_MARIO == 1);
+    RETURN_CANCEL_IF_ACTION_SET(ACT_SMO_CAPPY_THROW_GROUND, SMO_CAPPY != 0);
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_braking_stop(struct MarioState *m) {
+    RETURN_CANCEL_IF_ACTION_SET(ACT_SMO_CAPPY_THROW_GROUND, SMO_CAPPY != 0);
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_jump_land_stop(struct MarioState *m) {
+    RETURN_CANCEL_IF_ACTION_SET(ACT_SMO_CAPPY_THROW_GROUND, SMO_CAPPY != 0);
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_double_jump_land_stop(struct MarioState *m) {
+    RETURN_CANCEL_IF_ACTION_SET(ACT_SMO_CAPPY_THROW_GROUND, SMO_CAPPY != 0);
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_side_flip_land_stop(struct MarioState *m) {
+    RETURN_CANCEL_IF_ACTION_SET(ACT_SMO_CAPPY_THROW_GROUND, SMO_CAPPY != 0);
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_freefall_land_stop(struct MarioState *m) {
+    RETURN_CANCEL_IF_ACTION_SET(ACT_SMO_CAPPY_THROW_GROUND, SMO_CAPPY != 0);
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_triple_jump_land_stop(struct MarioState *m) {
+    RETURN_CANCEL_IF_ACTION_SET(ACT_SMO_CAPPY_THROW_GROUND, SMO_CAPPY != 0);
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_backflip_land_stop(struct MarioState *m) {
+    RETURN_CANCEL_IF_ACTION_SET(ACT_SMO_CAPPY_THROW_GROUND, SMO_CAPPY != 0);
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_long_jump_land_stop(struct MarioState *m) {
+    RETURN_CANCEL_IF_ACTION_SET(ACT_SMO_CAPPY_THROW_GROUND, SMO_CAPPY != 0);
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_ground_pound_land(struct MarioState *m) {
+    RETURN_CANCEL_IF_ACTION_SET(ACT_SMO_GROUND_POUND_JUMP, SMO_MARIO == 1);
+    RETURN_CANCEL_IF_ACTION_SET(ACT_SMO_ROLLING, SMO_MARIO == 1);
+    RETURN_CANCEL_IF_ACTION_SET(ACT_SMO_CAPPY_THROW_GROUND, SMO_CAPPY != 0);
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_shocked_from_high_fall(struct MarioState *m) {
+    if (m->actionState == 0) {
+        m->particleFlags |= PARTICLE_MIST_CIRCLE;
+        set_mario_animation(m, MARIO_ANIM_SHOCKED);
+        play_sound_if_no_flag(m, SOUND_MARIO_ATTACKED, MARIO_ACTION_SOUND_PLAYED);
+        play_mario_heavy_landing_sound(m, SOUND_ACTION_TERRAIN_BODY_HIT_GROUND);
+        m->actionState = 1;
+    } else {
+        m->actionTimer++;
+    }
+
+    mario_set_forward_vel(m, 0.0f);
+    stop_and_set_height_to_floor(m);
+
+    if (m->actionTimer < 30) {
+        set_camera_shake_from_hit(SHAKE_SHOCK);
+    }
+    if (m->actionTimer >= 45) {
+        set_mario_action(m, ACT_IDLE, 0);
+        return ACTION_RESULT_CANCEL;
+    }
+    return ACTION_RESULT_CONTINUE;
+}
+
+s32 mario_check_smo_stationary_action(struct MarioState *m) {
+    m->oCappyJumped = FALSE;
+    m->oWallSlide = TRUE;
+
+    // Fall damage
+    if (SMO_MARIO == 1) {
+        f32 fallHeight = m->oPeakHeight - m->pos[1];
+        m->peakHeight = m->pos[1];
+        m->oPeakHeight = m->pos[1];
+        if ((fallHeight > SMO_FALL_DAMAGE_HEIGHT) && (m->vel[1] < -50.0f) && (m->action != ACT_TWIRLING) && (m->floor->type != SURFACE_BURNING)) {
+            drop_and_set_mario_action(m, ACT_SMO_SHOCKED_FROM_HIGH_FALL, 0);
+            return ACTION_RESULT_CANCEL;
+        }
+    }
+
+    switch (m->action) {
+        case ACT_IDLE:                          return smo_act_idle(m);
+        case ACT_START_SLEEPING:                return smo_act_start_sleeping(m);
+        case ACT_SLEEPING:                      return smo_act_sleeping(m);
+        case ACT_COUGHING:                      return smo_act_coughing(m);
+        case ACT_SHIVERING:                     return smo_act_shivering(m);
+        case ACT_STANDING_AGAINST_WALL:         return smo_act_standing_against_wall(m);
+        case ACT_IN_QUICKSAND:                  return smo_act_in_quicksand(m);
+        case ACT_PANTING:                       return smo_act_panting(m);
+        case ACT_CROUCHING:                     return smo_act_crouching(m);
+        case ACT_BRAKING_STOP:                  return smo_act_braking_stop(m);
+        case ACT_JUMP_LAND_STOP:                return smo_act_jump_land_stop(m);
+        case ACT_DOUBLE_JUMP_LAND_STOP:         return smo_act_double_jump_land_stop(m);
+        case ACT_SIDE_FLIP_LAND_STOP:           return smo_act_side_flip_land_stop(m);
+        case ACT_FREEFALL_LAND_STOP:            return smo_act_freefall_land_stop(m);
+        case ACT_TRIPLE_JUMP_LAND_STOP:         return smo_act_triple_jump_land_stop(m);
+        case ACT_BACKFLIP_LAND_STOP:            return smo_act_backflip_land_stop(m);
+        case ACT_LONG_JUMP_LAND_STOP:           return smo_act_long_jump_land_stop(m);
+        case ACT_GROUND_POUND_LAND:             return smo_act_ground_pound_land(m);
+        case ACT_SMO_SHOCKED_FROM_HIGH_FALL:    return smo_act_shocked_from_high_fall(m);
+    }
+
+    return ACTION_RESULT_CONTINUE;
+}
diff --git a/data/smo/mario/smo_mario_actions_submerged.c b/data/smo/mario/smo_mario_actions_submerged.c
new file mode 100644
index 0000000..86b0ff8
--- /dev/null
+++ b/data/smo/mario/smo_mario_actions_submerged.c
@@ -0,0 +1,387 @@
+#include "../smo_c_includes.h"
+
+#define WATER_DASH_MAX_DURATION 16
+#define WATER_DASH_START_REPEAT 12
+
+static void smo_stationary_slow_down(struct MarioState *m) {
+
+    // Face angles
+    m->angleVel[0] = 0;
+    m->angleVel[1] = 0;
+    m->faceAngle[0] = approach_s32(m->faceAngle[0], 0, 0x200, 0x200);
+    m->faceAngle[2] = approach_s32(m->faceAngle[2], 0, 0x100, 0x100);
+
+    // Velocity
+    m->forwardVel = approach_f32(m->forwardVel, 0.0f, 1.0f, 1.0f);
+    m->vel[0] = m->forwardVel * coss(m->faceAngle[0]) * sins(m->faceAngle[1]);
+    m->vel[2] = m->forwardVel * coss(m->faceAngle[0]) * coss(m->faceAngle[1]);
+    m->vel[1] = approach_f32(m->vel[1], 0.0f, 2.0f, 1.0f);
+}
+
+static u32 smo_perform_water_full_step(struct MarioState *m, Vec3f nextPos) {
+    
+    // Wall collision
+    struct Surface *wall = resolve_and_return_wall_collisions(nextPos, 10.0f, 110.0f);
+    
+    // Floor collision
+    struct Surface *floor = NULL;
+    f32 floorHeight = find_floor(nextPos[0], nextPos[1], nextPos[2], &floor);
+    if (floor == NULL) {
+        return WATER_STEP_CANCELLED;
+    }
+
+    // Ceiling collision
+    struct Surface *ceil = NULL;
+    f32 ceilHeight = vec3f_find_ceil(nextPos, floorHeight, &ceil);
+
+    // Above floor
+    if (nextPos[1] >= floorHeight) {
+
+        // Below ceiling
+        if (ceilHeight - nextPos[1] >= 160.0f) {
+            vec3f_copy(m->pos, nextPos);
+            m->floor = floor;
+            m->floorHeight = floorHeight;
+
+            if (wall != NULL) {
+                return WATER_STEP_HIT_WALL;
+            } else {
+                return WATER_STEP_NONE;
+            }
+        }
+
+        // Not enough space to fit Mario
+        if (ceilHeight - floorHeight < 160.0f) {
+            return WATER_STEP_CANCELLED;
+        }
+
+        // Hit ceiling
+        vec3f_set(m->pos, nextPos[0], ceilHeight - 160.0f, nextPos[2]);
+        m->floor = floor;
+        m->floorHeight = floorHeight;
+        return WATER_STEP_HIT_CEILING;
+    }
+
+    // Not enough space to fit Mario
+    if (ceilHeight - floorHeight < 160.0f) {
+        return WATER_STEP_CANCELLED;
+    }
+
+    // Hit floor
+    vec3f_set(m->pos, nextPos[0], floorHeight, nextPos[2]);
+    m->floor = floor;
+    m->floorHeight = floorHeight;
+    return WATER_STEP_HIT_FLOOR;
+}
+
+static u32 smo_perform_water_step(struct MarioState *m) {
+    Vec3f nextPos = { m->pos[0] + m->vel[0], m->pos[1] + m->vel[1], m->pos[2] + m->vel[2] };
+    if (nextPos[1] > m->waterLevel - 80) {
+        nextPos[1] = m->waterLevel - 80;
+        m->vel[1] = 0.0f;
+    }
+
+    u32 stepResult = smo_perform_water_full_step(m, nextPos);
+    vec3f_copy(m->marioObj->header.gfx.pos, m->pos);
+    vec3s_set(m->marioObj->header.gfx.angle, -m->faceAngle[0], m->faceAngle[1], m->faceAngle[2]);
+    return stepResult;
+}
+
+//
+// Actions
+//
+
+static s32 smo_act_water_idle(struct MarioState *m) {
+    RETURN_CANCEL_IF_ACTION_SET(ACT_SMO_WATER_DESCENT, SMO_MARIO == 1);
+    RETURN_CANCEL_IF_ACTION_SET(ACT_SMO_CAPPY_THROW_WATER, SMO_CAPPY != 0);
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_water_action_end(struct MarioState *m) {
+    RETURN_CANCEL_IF_ACTION_SET(ACT_SMO_WATER_DESCENT, SMO_MARIO == 1);
+    RETURN_CANCEL_IF_ACTION_SET(ACT_SMO_CAPPY_THROW_WATER, SMO_CAPPY != 0);
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_breaststroke(struct MarioState *m) {
+    RETURN_CANCEL_IF_ACTION_SET(ACT_SMO_WATER_DESCENT, SMO_MARIO == 1);
+    RETURN_CANCEL_IF_ACTION_SET(ACT_SMO_CAPPY_THROW_WATER, SMO_CAPPY != 0);
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_swimming_end(struct MarioState *m) {
+    RETURN_CANCEL_IF_ACTION_SET(ACT_SMO_WATER_DESCENT, SMO_MARIO == 1);
+    RETURN_CANCEL_IF_ACTION_SET(ACT_SMO_CAPPY_THROW_WATER, SMO_CAPPY != 0);
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_flutter_kick(struct MarioState *m) {
+    RETURN_CANCEL_IF_ACTION_SET(ACT_SMO_WATER_DESCENT, SMO_MARIO == 1);
+    RETURN_CANCEL_IF_ACTION_SET(ACT_SMO_CAPPY_THROW_WATER, SMO_CAPPY != 0);
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_metal_water_standing(struct MarioState *m) {
+    RETURN_CANCEL_IF_ACTION_SET(ACT_SMO_METAL_WATER_PUNCH, SMO_MARIO == 1);
+    RETURN_CANCEL_IF_ACTION_SET(ACT_SMO_CAPPY_THROW_METAL_WATER_FLOOR, SMO_CAPPY != 0);
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_metal_water_walking(struct MarioState *m) {
+    RETURN_CANCEL_IF_ACTION_SET(ACT_SMO_METAL_WATER_PUNCH, SMO_MARIO == 1);
+    RETURN_CANCEL_IF_ACTION_SET(ACT_SMO_CAPPY_THROW_METAL_WATER_FLOOR, SMO_CAPPY != 0);
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_metal_water_jump(struct MarioState *m) {
+    RETURN_CANCEL_IF_ACTION_SET(ACT_SMO_METAL_WATER_KICK, SMO_MARIO == 1);
+    RETURN_CANCEL_IF_ACTION_SET(ACT_SMO_CAPPY_THROW_METAL_WATER_AIR, SMO_CAPPY != 0);
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_metal_water_falling(struct MarioState *m) {
+    RETURN_CANCEL_IF_ACTION_SET(ACT_SMO_METAL_WATER_KICK, SMO_MARIO == 1);
+    RETURN_CANCEL_IF_ACTION_SET(ACT_SMO_CAPPY_THROW_METAL_WATER_AIR, SMO_CAPPY != 0);
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_metal_water_jump_land(struct MarioState *m) {
+    RETURN_CANCEL_IF_ACTION_SET(ACT_SMO_METAL_WATER_PUNCH, SMO_MARIO == 1);
+    RETURN_CANCEL_IF_ACTION_SET(ACT_SMO_CAPPY_THROW_METAL_WATER_FLOOR, SMO_CAPPY != 0);
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_metal_water_fall_land(struct MarioState *m) {
+    RETURN_CANCEL_IF_ACTION_SET(ACT_SMO_METAL_WATER_PUNCH, SMO_MARIO == 1);
+    RETURN_CANCEL_IF_ACTION_SET(ACT_SMO_CAPPY_THROW_METAL_WATER_FLOOR, SMO_CAPPY != 0);
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_water_dash(struct MarioState *m) {
+
+    if (m->actionTimer >= WATER_DASH_MAX_DURATION) {
+        set_mario_action(m, ACT_BREASTSTROKE, 0);
+        return ACTION_RESULT_CANCEL;
+    }
+
+    if (m->actionTimer >= WATER_DASH_START_REPEAT) {
+        RETURN_CANCEL_IF_ACTION_SET(ACT_SMO_WATER_DASH, SMO_MARIO == 1);
+    }
+
+    if ((m->actionTimer % 4) == 0) {
+        play_sound(SOUND_ACTION_UNKNOWN434, m->marioObj->header.gfx.cameraToObject);
+    }
+
+    set_mario_anim_with_accel(m, MARIO_ANIM_FLUTTERKICK, 0x30000);
+    m->particleFlags |= (PARTICLE_PLUNGE_BUBBLE | PARTICLE_BUBBLE);
+    m->vel[0] = coss(m->faceAngle[0]) * sins(m->faceAngle[1]) * 56.0f;
+    m->vel[1] = sins(m->faceAngle[0]) * 56.0f;
+    m->vel[2] = coss(m->faceAngle[0]) * coss(m->faceAngle[1]) * 56.0f;
+    m->actionTimer++;
+
+    switch (smo_perform_water_step(m)) {
+        case WATER_STEP_HIT_WALL:
+            m->particleFlags |= PARTICLE_VERTICAL_STAR;
+            play_sound(SOUND_MARIO_OOOF2, m->marioObj->header.gfx.cameraToObject);
+            set_mario_action(m, ACT_BACKWARD_WATER_KB, 0);
+            return ACTION_RESULT_CANCEL;
+    }
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_water_descent(struct MarioState *m) {
+    if (m->actionState == 0) {
+        if (m->actionTimer < 10) {
+            m->pos[1] += (20 - 2 * m->actionTimer);
+            vec3f_copy(m->marioObj->header.gfx.pos, m->pos);
+        }
+
+        m->vel[0] = 0;
+        m->vel[1] = 0;
+        m->vel[2] = 0;
+
+        RETURN_CANCEL_IF_ACTION_SET(ACT_SMO_WATER_DASH, SMO_MARIO == 1);
+
+        set_mario_animation(m, MARIO_ANIM_START_GROUND_POUND);
+        if (m->actionTimer == 0) {
+            play_sound(SOUND_ACTION_SPIN, m->marioObj->header.gfx.cameraToObject);
+        }
+
+        if (++(m->actionTimer) >= m->marioObj->header.gfx.unk38.curAnim->unk08 + 4) {
+            play_sound(SOUND_MARIO_GROUND_POUND_WAH, m->marioObj->header.gfx.cameraToObject);
+            play_sound(SOUND_ACTION_UNKNOWN430, m->marioObj->header.gfx.cameraToObject);
+            m->actionState = 1;
+            m->vel[1] = -105.f;
+            m->faceAngle[0] = 0;
+            m->faceAngle[2] = 0;
+        }
+
+    } else {
+
+        set_mario_animation(m, MARIO_ANIM_GROUND_POUND);
+        m->particleFlags |= (PARTICLE_PLUNGE_BUBBLE | PARTICLE_BUBBLE);
+        m->vel[1] += 5.0f;
+
+        if (m->vel[1] >= 0) {
+            m->vel[1] = 0;
+            set_mario_action(m, ACT_WATER_IDLE, 0);
+            return ACTION_RESULT_CANCEL;
+        }
+
+        u32 stepResult = smo_perform_water_step(m);
+        if (stepResult == WATER_STEP_HIT_FLOOR) {
+            set_mario_action(m, ACT_WATER_IDLE, 0);
+            return ACTION_RESULT_CANCEL;
+        }
+    }
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_leave_object_water(struct MarioState *m) {
+    smo_stationary_slow_down(m);
+    smo_perform_water_step(m);
+    set_mario_animation(m, MARIO_ANIM_WATER_IDLE);
+    m->marioBodyState->headAngle[0] = 0;
+    m->particleFlags |= PARTICLE_SPARKLES;
+
+    if (absx(m->vel[1]) < 1.f) {
+        set_mario_action(m, ACT_WATER_IDLE, 0);
+        return ACTION_RESULT_CANCEL;
+    }
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_metal_water_punch(struct MarioState *m) {
+
+    if (!(m->flags & MARIO_METAL_CAP)) {
+        set_mario_action(m, ACT_WATER_IDLE, 0);
+        return ACTION_RESULT_CANCEL;
+    }
+
+    mario_set_forward_vel(m, 2.f);
+    switch (m->actionArg) {
+        case 0:
+            m->actionArg = 1;
+            m->flags |= MARIO_PUNCHING;
+            if (is_anim_past_end(m)) {
+                m->actionArg = 2;
+            }
+            break;
+
+        case 1:
+            set_mario_animation(m, MARIO_ANIM_FIRST_PUNCH_FAST);
+            if (is_anim_at_end(m)) {
+                set_mario_action(m, ACT_METAL_WATER_STANDING, 0);
+            }
+            break;
+    }
+
+    switch (perform_ground_step(m)) {
+        case GROUND_STEP_LEFT_GROUND:
+            set_mario_action(m, ACT_METAL_WATER_FALLING, 0);
+            break;
+
+        case GROUND_STEP_HIT_WALL:
+            m->forwardVel = 0;
+            break;
+    }
+
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_metal_water_kick(struct MarioState *m) {
+    
+    if (!(m->flags & MARIO_METAL_CAP)) {
+        set_mario_action(m, ACT_WATER_IDLE, 0);
+        return ACTION_RESULT_CANCEL;
+    }
+
+    if (!is_anim_at_end(m)) {
+        m->flags |= MARIO_KICKING;
+    }
+
+    switch (perform_air_step(m, 0)) {
+        case AIR_STEP_LANDED:
+            set_mario_action(m, ACT_METAL_WATER_FALL_LAND, 0);
+            break;
+
+        case AIR_STEP_HIT_WALL:
+            mario_set_forward_vel(m, 0.0f);
+            break;
+    }
+
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_cappy_throw_water(struct MarioState *m) {
+    update_mario_throw_anim(m, ACT_WATER_IDLE);
+    play_sound_if_no_flag(m, SOUND_ACTION_SWIM, MARIO_ACTION_SOUND_PLAYED);
+    mario_set_forward_vel(m, m->forwardVel * 0.9f);
+    smo_perform_water_step(m);
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_cappy_throw_metal_water_floor(struct MarioState *m) {
+    update_mario_throw_anim(m, ACT_METAL_WATER_STANDING);
+    mario_set_forward_vel(m, m->forwardVel * 0.85f);
+    switch (perform_ground_step(m)) {
+        case GROUND_STEP_LEFT_GROUND:
+            set_mario_action(m, ACT_METAL_WATER_FALLING, 0);
+            break;
+
+        case GROUND_STEP_HIT_WALL:
+            m->forwardVel = 0;
+            break;
+    }
+    return ACTION_RESULT_CONTINUE;
+}
+
+static s32 smo_act_cappy_throw_metal_water_air(struct MarioState *m) {
+    RETURN_CANCEL_IF_ACTION_SET(ACT_SMO_METAL_WATER_KICK, SMO_MARIO == 1);
+    update_mario_throw_anim(m, ACT_METAL_WATER_FALLING);
+    switch (perform_air_step(m, 0)) {
+        case AIR_STEP_LANDED:
+            set_mario_action(m, ACT_METAL_WATER_FALL_LAND, 0);
+            break;
+
+        case AIR_STEP_HIT_WALL:
+            mario_set_forward_vel(m, 0.0f);
+            break;
+    }
+    return ACTION_RESULT_CONTINUE;
+}
+
+s32 mario_check_smo_submerged_action(struct MarioState *m) {
+    m->oCappyJumped = FALSE;
+    m->oWallSlide = TRUE;
+
+    // Fall height
+    if (SMO_MARIO == 1) {
+        m->peakHeight = m->pos[1];
+        m->oPeakHeight = m->pos[1];
+    }
+
+    switch (m->action) {
+        case ACT_WATER_IDLE:                        return smo_act_water_idle(m);
+        case ACT_WATER_ACTION_END:                  return smo_act_water_action_end(m);
+        case ACT_BREASTSTROKE:                      return smo_act_breaststroke(m);
+        case ACT_SWIMMING_END:                      return smo_act_swimming_end(m);
+        case ACT_FLUTTER_KICK:                      return smo_act_flutter_kick(m);
+        case ACT_METAL_WATER_STANDING:              return smo_act_metal_water_standing(m);
+        case ACT_METAL_WATER_WALKING:               return smo_act_metal_water_walking(m);
+        case ACT_METAL_WATER_JUMP:                  return smo_act_metal_water_jump(m);
+        case ACT_METAL_WATER_FALLING:               return smo_act_metal_water_falling(m);
+        case ACT_METAL_WATER_JUMP_LAND:             return smo_act_metal_water_jump_land(m);
+        case ACT_METAL_WATER_FALL_LAND:             return smo_act_metal_water_fall_land(m);
+        case ACT_SMO_WATER_DESCENT:                 return smo_act_water_descent(m);
+        case ACT_SMO_WATER_DASH:                    return smo_act_water_dash(m);
+        case ACT_SMO_LEAVE_OBJECT_WATER:            return smo_act_leave_object_water(m);
+        case ACT_SMO_METAL_WATER_PUNCH:             return smo_act_metal_water_punch(m);
+        case ACT_SMO_METAL_WATER_KICK:              return smo_act_metal_water_kick(m);
+        case ACT_SMO_CAPPY_THROW_WATER:             return smo_act_cappy_throw_water(m);
+        case ACT_SMO_CAPPY_THROW_METAL_WATER_FLOOR: return smo_act_cappy_throw_metal_water_floor(m);
+        case ACT_SMO_CAPPY_THROW_METAL_WATER_AIR:   return smo_act_cappy_throw_metal_water_air(m);
+    }
+
+    return ACTION_RESULT_CONTINUE;
+}
diff --git a/data/smo/mario/smo_mario_capture.c b/data/smo/mario/smo_mario_capture.c
new file mode 100644
index 0000000..5a1d472
--- /dev/null
+++ b/data/smo/mario/smo_mario_capture.c
@@ -0,0 +1,522 @@
+#include "../smo_c_includes.h"
+#ifdef SMO_SGI
+#include "sgi/utils/characters.h"
+#endif
+
+// Traps the object in an infinite loop, preventing it from updating normally
+static const BehaviorScript bhvCappyLock[] = {
+    0x08000000, 
+    0x09000000
+};
+
+//
+// Object copy
+//
+
+static void copy_object_data(struct Object *obj) {
+
+    // Copying object fields
+    memcpy(&obj->smoData->objData.rawData, &obj->rawData, sizeof(obj->rawData));
+#if IS_64_BIT
+    memcpy(&obj->smoData->objData.ptrData, &obj->ptrData, sizeof(obj->ptrData));
+#endif
+
+    // Copying behavior data
+    memcpy(&obj->smoData->objData.behavior, &obj->behavior, sizeof(obj->behavior));
+    memcpy(&obj->smoData->objData.curBhvCommand, &obj->curBhvCommand, sizeof(obj->curBhvCommand));
+    memcpy(&obj->smoData->objData.bhvStackIndex, &obj->bhvStackIndex, sizeof(obj->bhvStackIndex));
+    memcpy(&obj->smoData->objData.bhvStack, &obj->bhvStack, sizeof(obj->bhvStack));
+
+    // Copying scale data
+    memcpy(&obj->smoData->objData.hitboxRadius, &obj->hitboxRadius, sizeof(obj->hitboxRadius));
+    memcpy(&obj->smoData->objData.hitboxHeight, &obj->hitboxHeight, sizeof(obj->hitboxHeight));
+    memcpy(&obj->smoData->objData.hurtboxRadius, &obj->hurtboxRadius, sizeof(obj->hurtboxRadius));
+    memcpy(&obj->smoData->objData.hurtboxHeight, &obj->hurtboxHeight, sizeof(obj->hurtboxHeight));
+    memcpy(&obj->smoData->objData.hitboxDownOffset, &obj->hitboxDownOffset, sizeof(obj->hitboxDownOffset));
+    memcpy(&obj->smoData->objData.gfxScaleX, &obj->header.gfx.scale[0], sizeof(obj->header.gfx.scale[0]));
+    memcpy(&obj->smoData->objData.gfxScaleY, &obj->header.gfx.scale[1], sizeof(obj->header.gfx.scale[1]));
+    memcpy(&obj->smoData->objData.gfxScaleZ, &obj->header.gfx.scale[2], sizeof(obj->header.gfx.scale[2]));
+}
+
+static void restore_object_data(struct Object *obj) {
+    f32 x = obj->oPosX;
+    f32 y = obj->oPosY;
+    f32 z = obj->oPosZ;
+    f32 pitch = obj->oFaceAnglePitch;
+    f32 yaw = obj->oFaceAngleYaw;
+    f32 roll = obj->oFaceAngleRoll;
+
+    // Restoring object fields
+    memcpy(&obj->rawData, &obj->smoData->objData.rawData, sizeof(obj->rawData));
+#if IS_64_BIT
+    memcpy(&obj->ptrData, &obj->smoData->objData.ptrData, sizeof(obj->ptrData));
+#endif
+
+    // Restoring behavior data
+    memcpy(&obj->behavior, &obj->smoData->objData.behavior, sizeof(obj->behavior));
+    memcpy(&obj->curBhvCommand, &obj->smoData->objData.curBhvCommand, sizeof(obj->curBhvCommand));
+    memcpy(&obj->bhvStackIndex, &obj->smoData->objData.bhvStackIndex, sizeof(obj->bhvStackIndex));
+    memcpy(&obj->bhvStack, &obj->smoData->objData.bhvStack, sizeof(obj->bhvStack));
+
+    // Restoring scale data
+    memcpy(&obj->hitboxRadius, &obj->smoData->objData.hitboxRadius, sizeof(obj->hitboxRadius));
+    memcpy(&obj->hitboxHeight, &obj->smoData->objData.hitboxHeight, sizeof(obj->hitboxHeight));
+    memcpy(&obj->hurtboxRadius, &obj->smoData->objData.hurtboxRadius, sizeof(obj->hurtboxRadius));
+    memcpy(&obj->hurtboxHeight, &obj->smoData->objData.hurtboxHeight, sizeof(obj->hurtboxHeight));
+    memcpy(&obj->hitboxDownOffset, &obj->smoData->objData.hitboxDownOffset, sizeof(obj->hitboxDownOffset));
+    memcpy(&obj->header.gfx.scale[0], &obj->smoData->objData.gfxScaleX, sizeof(obj->header.gfx.scale[0]));
+    memcpy(&obj->header.gfx.scale[1], &obj->smoData->objData.gfxScaleY, sizeof(obj->header.gfx.scale[1]));
+    memcpy(&obj->header.gfx.scale[2], &obj->smoData->objData.gfxScaleZ, sizeof(obj->header.gfx.scale[2]));
+
+    // Updating values
+    obj->oPosX = x;
+    obj->oPosY = y;
+    obj->oPosZ = z;
+    obj->oHomeX = x;
+    obj->oHomeY = y;
+    obj->oHomeZ = z;
+    obj->oVelX = 0;
+    obj->oVelY = 0;
+    obj->oVelZ = 0;
+    obj->oForwardVel = 0;
+    obj->oFaceAnglePitch = pitch;
+    obj->oFaceAngleYaw = yaw;
+    obj->oFaceAngleRoll = roll;
+    obj->oMoveAnglePitch = pitch;
+    obj->oMoveAngleYaw = yaw;
+    obj->oMoveAngleRoll = roll;
+}
+
+//
+// Act
+//
+
+s32 mario_lock(struct MarioState *m) {
+    if (m->action != ACT_SMO_POSSESSION) {
+        return FALSE;
+    }
+    m->oPossessionLock = TRUE;
+    return TRUE;
+}
+
+s32 mario_unlock(struct MarioState *m) {
+    if (m->action != ACT_SMO_POSSESSION) {
+        return FALSE;
+    }
+    m->oPossessionLock = FALSE;
+    return TRUE;
+}
+
+static void mario_cappy_update_object_and_gfx(struct MarioState *m) {
+    struct Object *cap = m->oObjectCap;
+    struct PObject *pobj = m->oPossessedObject;
+
+    // Mario
+    if (m->oPossessionTimer >= 20) {
+        m->pos[0] = pobj->oPosX;
+        m->pos[1] = pobj->oPosY;
+        m->pos[2] = pobj->oPosZ;
+        m->vel[0] = pobj->oVelX;
+        m->vel[1] = pobj->oVelY;
+        m->vel[2] = pobj->oVelZ;
+        m->forwardVel = pobj->oForwardVel;
+        m->faceAngle[0] = -pobj->oFaceAnglePitch;
+        m->faceAngle[1] = pobj->oFaceAngleYaw;
+        m->faceAngle[2] = pobj->oFaceAngleRoll;
+        m->marioObj->header.gfx.scale[0] = 1.f;
+        m->marioObj->header.gfx.scale[1] = 1.f;
+        m->marioObj->header.gfx.scale[2] = 1.f;
+        m->squishTimer = 0;
+        set_mario_animation(m, MARIO_ANIM_A_POSE);
+        m->marioObj->header.gfx.node.flags |= GRAPH_RENDER_INVISIBLE;
+    }
+    m->marioObj->oPosX = m->pos[0];
+    m->marioObj->oPosY = m->pos[1];
+    m->marioObj->oPosZ = m->pos[2];
+    m->marioObj->oFaceAnglePitch = m->faceAngle[0];
+    m->marioObj->oFaceAngleYaw = m->faceAngle[1];
+    m->marioObj->oFaceAngleRoll = m->faceAngle[2];
+    m->marioObj->header.gfx.pos[0] = m->marioObj->oPosX;
+    m->marioObj->header.gfx.pos[1] = m->marioObj->oPosY + m->marioObj->oGraphYOffset;
+    m->marioObj->header.gfx.pos[2] = m->marioObj->oPosZ;
+    m->marioObj->header.gfx.angle[0] = m->marioObj->oFaceAnglePitch & 0xFFFF;
+    m->marioObj->header.gfx.angle[1] = m->marioObj->oFaceAngleYaw & 0xFFFF;
+    m->marioObj->header.gfx.angle[2] = m->marioObj->oFaceAngleRoll & 0xFFFF;
+
+    // Cappy
+    if (cap != NULL) {
+        Vec3f dv = { -pobj->oCappyLateralDist * pobj->header.gfx.scale[0], pobj->oCappyVerticalDist * pobj->header.gfx.scale[1], pobj->oCappyForwardDist * pobj->header.gfx.scale[0] };
+        vec3f_rotate_zxy(dv, pobj->oFaceAnglePitch, pobj->oFaceAngleYaw, pobj->oFaceAngleRoll);
+        cap->oPosX = pobj->oPosX + dv[0];
+        cap->oPosY = pobj->oPosY + dv[1];
+        cap->oPosZ = pobj->oPosZ + dv[2];
+        cap->oFaceAnglePitch = pobj->oFaceAnglePitch + pobj->oCappyInitialPitch;
+        cap->oFaceAngleYaw   = pobj->oFaceAngleYaw   + pobj->oCappyInitialYaw;
+        cap->oFaceAngleRoll  = pobj->oFaceAngleRoll  + pobj->oCappyInitialRoll;
+        cap->header.gfx.pos[0] = cap->oPosX;
+        cap->header.gfx.pos[1] = cap->oPosY + cap->oGraphYOffset;
+        cap->header.gfx.pos[2] = cap->oPosZ;
+        cap->header.gfx.angle[0] = cap->oFaceAnglePitch & 0xFFFF;
+        cap->header.gfx.angle[1] = cap->oFaceAngleYaw   & 0xFFFF;
+        cap->header.gfx.angle[2] = cap->oFaceAngleRoll  & 0xFFFF;
+        cap->header.gfx.scale[0] = (pobj->oCappyInitialScale / 100.f) * pobj->header.gfx.scale[0];
+        cap->header.gfx.scale[1] = (pobj->oCappyInitialScale / 100.f) * pobj->header.gfx.scale[1];
+        cap->header.gfx.scale[2] = (pobj->oCappyInitialScale / 100.f) * pobj->header.gfx.scale[2];
+#ifdef SMO_SGI
+        if (getCharacterType() == LUIGI) {
+            cap->header.gfx.scale[0] *= LUIGIS_CAPPY_SCALE_MULTIPLIER;
+            cap->header.gfx.scale[1] *= LUIGIS_CAPPY_SCALE_MULTIPLIER;
+            cap->header.gfx.scale[2] *= LUIGIS_CAPPY_SCALE_MULTIPLIER;
+        }
+#endif
+        cap->header.gfx.node.flags = GRAPH_RENDER_ACTIVE;
+        cap->header.gfx.node.flags &= ~GRAPH_RENDER_INVISIBLE;
+        cap->oOpacity = 0xFF;
+    }
+}
+
+// Possession phases
+// 10 frames / 1: Mario spins towards the object to possess
+// 04 frames / 2: Mario stops, dive, rotates towards the ground and starts shrinking
+// 06 frames / 3: while shrinking, Mario dives into the object
+
+/*From, To, Coeff, Angle, Scale, Animation */
+static const s32 sCappyPossessAnimParams[20][6] = {
+
+    // Phase 1
+    { 0, 1,  19, 0x0000, 100, MARIO_ANIM_FORWARD_SPINNING },
+    { 0, 1,  36, 0x0000, 100, MARIO_ANIM_FORWARD_SPINNING },
+    { 0, 1,  51, 0x0000, 100, MARIO_ANIM_FORWARD_SPINNING },
+    { 0, 1,  64, 0x0000, 100, MARIO_ANIM_FORWARD_SPINNING },
+    { 0, 1,  75, 0x0000, 100, MARIO_ANIM_FORWARD_SPINNING },
+    { 0, 1,  84, 0x0000, 100, MARIO_ANIM_FORWARD_SPINNING },
+    { 0, 1,  91, 0x0000, 100, MARIO_ANIM_FORWARD_SPINNING },
+    { 0, 1,  96, 0x0000, 100, MARIO_ANIM_FORWARD_SPINNING },
+    { 0, 1,  99, 0x0000, 100, MARIO_ANIM_FORWARD_SPINNING },
+    { 0, 1, 100, 0x0000, 100, MARIO_ANIM_FORWARD_SPINNING },
+
+    // Phase 2
+    { 1, 1,   0, 0x0000, 100, MARIO_ANIM_DIVE },
+    { 1, 1,   0, 0x1000,  95, MARIO_ANIM_DIVE },
+    { 1, 1,   0, 0x2000,  90, MARIO_ANIM_DIVE },
+    { 1, 1,   0, 0x3000,  85, MARIO_ANIM_DIVE },
+
+    // Phase 3
+    { 1, 2,   5, 0x4000,  80, MARIO_ANIM_DIVE },
+    { 1, 2,  15, 0x4000,  70, MARIO_ANIM_DIVE },
+    { 1, 2,  30, 0x4000,  60, MARIO_ANIM_DIVE },
+    { 1, 2,  50, 0x4000,  50, MARIO_ANIM_DIVE },
+    { 1, 2,  75, 0x4000,  40, MARIO_ANIM_DIVE },
+    { 1, 2, 100, 0x4000,  30, MARIO_ANIM_DIVE },
+};
+
+#define xFrom(t)        (m->oPossessAnimPos(sCappyPossessAnimParams[t][0], 0))
+#define yFrom(t)        (m->oPossessAnimPos(sCappyPossessAnimParams[t][0], 1))
+#define zFrom(t)        (m->oPossessAnimPos(sCappyPossessAnimParams[t][0], 2))
+#define xTo(t)          (m->oPossessAnimPos(sCappyPossessAnimParams[t][1], 0))
+#define yTo(t)          (m->oPossessAnimPos(sCappyPossessAnimParams[t][1], 1))
+#define zTo(t)          (m->oPossessAnimPos(sCappyPossessAnimParams[t][1], 2))
+#define coeff(t)        ((f32)(sCappyPossessAnimParams[t][2]) / 100.f)
+#define angle(t)        ((s16)(sCappyPossessAnimParams[t][3]))
+#define scale(t)        ((f32)(sCappyPossessAnimParams[t][4]) / 100.f)
+#define anim(t)         (sCappyPossessAnimParams[t][5])
+#define lerp(t, a, b)   ((a) + ((b) - (a)) * (t));
+
+s32 smo_act_possession(struct MarioState *m) {
+    if (m->oPossessionTimer < 20) {
+
+        // Play the possession animation for 20 frames
+        if (m->oPossessionTimer == 0) {
+            smo_play_sound_effect(SOUND_ACTION_CAPPY_1, m->marioObj->header.gfx.cameraToObject);
+        }
+        s32 t = m->oPossessionTimer;
+        m->pos[0] = lerp(coeff(t), xFrom(t), xTo(t));
+        m->pos[1] = lerp(coeff(t), yFrom(t), yTo(t));
+        m->pos[2] = lerp(coeff(t), zFrom(t), zTo(t));
+        m->faceAngle[0] = angle(t);
+        m->squishTimer = 0xFF;
+        vec3f_set(m->marioObj->header.gfx.scale, scale(t), scale(t), scale(t));
+        set_mario_animation(m, anim(t));
+        m->particleFlags |= PARTICLE_SPARKLES;
+        m->oPossessionTimer++;
+    
+    } else {
+
+        // Spawn Cappy if not spawned
+        if (!m->oObjectCap) {
+#ifdef SMO_SGI
+            if (getCharacterType() == LUIGI) {
+                m->oObjectCap = spawn_object(m->marioObj, MODEL_LUIGIS_CAP, bhvCappyLock);
+            } else {
+#endif
+                m->oObjectCap = spawn_object(m->marioObj, MODEL_MARIOS_CAP, bhvCappyLock);
+#ifdef SMO_SGI
+            }
+#endif
+            m->oObjectCap->oFlags = 0;
+            smo_obj_alloc_data(m->oObjectCap, m);
+        }
+
+        // If Mario is locked, don't check [Z] press and zero-init inputs
+        if (m->oPossessionLock) {
+            m->oInputStickX        = 0;
+            m->oInputStickY        = 0;
+            m->oInputStickMag      = 0;
+            m->oInputStickYaw      = 0;
+            m->oInputButtonPressed = 0;
+            m->oInputButtonDown    = 0;
+        } else {
+
+            // Press [Z] to leave the object
+            if (m->input & INPUT_Z_PRESSED) {
+                if (mario_unpossess_object(m, MARIO_UNPOSSESS_ACT_JUMP_OUT, FALSE, 6)) {
+                    return ACTION_RESULT_CANCEL;
+                }
+            }
+
+            // Update inputs
+            m->oInputStickX        = (m->controller->stickX / 64.f);
+            m->oInputStickY        = (m->controller->stickY / 64.f);
+            m->oInputStickMag      = (m->controller->stickMag / 64.f);
+            m->oInputStickYaw      = (m->intendedYaw);
+            m->oInputButtonPressed = (m->controller->buttonPressed);
+            m->oInputButtonDown    = (m->controller->buttonDown);
+        }
+
+        // Update possessed object
+        struct PObject *pobj = m->oPossessedObject;
+        const PObjMainLoopFunc *f = pobj->smoData->captureData->mloop;
+        pobj->oCappyForwardDist  = 0;
+        pobj->oCappyLateralDist  = 0;
+        pobj->oCappyVerticalDist = 0;
+        pobj->oCappyInitialPitch = 0;
+        pobj->oCappyInitialYaw   = 0;
+        pobj->oCappyInitialRoll  = 0;
+        pobj->oCappyInitialScale = 100;
+        while (*f) {
+            (*f)(pobj);
+            if (m->action != ACT_SMO_POSSESSION) {
+                return ACTION_RESULT_CANCEL;
+            }
+            f++;
+        }
+
+        // Debug only: use these fields to store the hitbox values (used later in smo_debug)
+        DEBUG_ONLY(pobj->oStickX = pobj->hitboxRadius);
+        DEBUG_ONLY(pobj->oStickY = pobj->hitboxHeight);
+        DEBUG_ONLY(pobj->oStickMag = pobj->hitboxDownOffset);
+
+        // Unset possessed object's hitbox to avoid undesirable interactions
+        pobj->hitboxRadius = 0;
+        pobj->hitboxHeight = 0;
+        pobj->hurtboxRadius = 0;
+        pobj->hurtboxHeight = 0;
+        pobj->hitboxDownOffset = 0;
+        pobj->oWallHitboxRadius = 0;
+    }
+
+    // Update Mario and Cappy's objects and graphics
+    mario_cappy_update_object_and_gfx(m);
+    return ACTION_RESULT_BREAK;
+}
+
+#undef xFrom
+#undef yFrom
+#undef zFrom
+#undef xTo
+#undef yTo
+#undef zTo
+#undef coeff
+#undef angle
+#undef scale
+#undef anim
+#undef lerp
+
+//
+// Possess
+//
+
+s32 mario_possess_object(struct MarioState *m, struct Object *obj) {
+    if (SMO_CAPPY != 2) {
+        return FALSE;
+    }
+
+    // Oof
+    if (m->health < 0x100 || m->hurtCounter != 0) {
+        return FALSE;
+    }
+
+    // Mario can't possess more than
+    // one object at a time
+    if (m->action == ACT_SMO_POSSESSION) {
+        return FALSE;
+    }
+
+    // Try to capture
+    const struct SmoCaptureData *captureData = cappy_capture(obj);
+    if (captureData == NULL) {
+        return FALSE;
+    }
+
+    // Try to init
+    smo_obj_alloc_data(obj, m);
+    obj->smoData->captureData = captureData;
+    if (!obj->smoData->captureData->init(obj)) {
+        smo_obj_free_data(obj);
+        return FALSE;
+    }
+
+    // OK
+    copy_object_data(obj);
+    obj->behavior = bhvCappyLock;
+    obj->curBhvCommand = bhvCappyLock;
+    obj->oFlags = 0;
+    obj->oIntangibleTimer = 0;
+    m->oPossessedObject = obj;
+    m->oObjectCap = NULL;
+    m->oPossessionTimer = 0;
+    m->oPossessionLock = FALSE;
+
+    // Init animation positions
+    f32 x = obj->oPosX;
+    f32 y = obj->oPosY + obj->smoData->captureData->gettop(obj);
+    f32 z = obj->oPosZ;
+    m->oPossessAnimPos(0, 0) = m->pos[0];
+    m->oPossessAnimPos(0, 1) = m->pos[1];
+    m->oPossessAnimPos(0, 2) = m->pos[2];
+    m->oPossessAnimPos(1, 0) = x;
+    m->oPossessAnimPos(1, 1) = y + 180.f;
+    m->oPossessAnimPos(1, 2) = z;
+    m->oPossessAnimPos(2, 0) = x;
+    m->oPossessAnimPos(2, 1) = y - 30.f;
+    m->oPossessAnimPos(2, 2) = z;
+
+    // Init face angles
+    m->faceAngle[0] = 0;
+    m->faceAngle[1] = mario_obj_angle_to_object(m, obj);
+    m->faceAngle[2] = 0;
+
+    smo_capture_reset_camera(obj);
+    set_mario_action(m, ACT_SMO_POSSESSION, 0);
+    return TRUE;
+}
+
+//
+// Unpossess
+//
+
+/* action, actionArg, forward vel, non-zero vertical vel, come from top, invert face yaw */
+static const s32 sMarioUnpossessActions[MARIO_UNPOSSESS_ACT_COUNT * 6][6] = {
+
+    /* MARIO_UNPOSSESS_ACT_JUMP_OUT */
+    /* GF */ { ACT_SMO_LEAVE_OBJECT_JUMP,   0,  18, 42, TRUE,  FALSE },
+    /* GB */ { ACT_SMO_LEAVE_OBJECT_JUMP,   0,  18, 42, TRUE,  FALSE },
+    /* AF */ { ACT_SMO_LEAVE_OBJECT_JUMP,   0,  18, 42, TRUE,  FALSE },
+    /* AB */ { ACT_SMO_LEAVE_OBJECT_JUMP,   0,  18, 42, TRUE,  FALSE },
+    /* WF */ { ACT_SMO_LEAVE_OBJECT_WATER,  0,   0, 20, TRUE,  FALSE },
+    /* WB */ { ACT_SMO_LEAVE_OBJECT_WATER,  0,   0, 20, TRUE,  FALSE },
+
+    /* MARIO_UNPOSSESS_ACT_KNOCKED_BACK */
+    /* GF */ { ACT_HARD_FORWARD_GROUND_KB,  1,  28,  0, FALSE, TRUE  },
+    /* GB */ { ACT_HARD_BACKWARD_GROUND_KB, 1, -28,  0, FALSE, FALSE },
+    /* AF */ { ACT_HARD_FORWARD_AIR_KB,     1,  28,  0, FALSE, TRUE  },
+    /* AB */ { ACT_HARD_BACKWARD_AIR_KB,    1, -28,  0, FALSE, FALSE },
+    /* WF */ { ACT_FORWARD_WATER_KB,        1,  28,  0, FALSE, TRUE  },
+    /* WB */ { ACT_BACKWARD_WATER_KB,       1, -28,  0, FALSE, FALSE },
+
+    /* MARIO_UNPOSSESS_ACT_KNOCKED_OUT_OF_KING_WHOMP */
+    /* GF */ { ACT_HARD_BACKWARD_GROUND_KB, 1,  32, 16, TRUE,  TRUE  },
+    /* GB */ { ACT_HARD_BACKWARD_GROUND_KB, 1,  32, 16, TRUE,  TRUE  },
+    /* AF */ { ACT_HARD_BACKWARD_AIR_KB,    1,  32, 16, TRUE,  TRUE  },
+    /* AB */ { ACT_HARD_BACKWARD_AIR_KB,    1,  32, 16, TRUE,  TRUE  },
+    /* WF */ { ACT_BACKWARD_WATER_KB,       1,  32, 16, TRUE,  TRUE  },
+    /* WB */ { ACT_BACKWARD_WATER_KB,       1,  32, 16, TRUE,  TRUE  },
+
+    /* MARIO_UNPOSSESS_ACT_BURNT */
+    /* GF */ { ACT_BURNING_JUMP,            1,  12, 34, TRUE,  FALSE },
+    /* GB */ { ACT_BURNING_JUMP,            1,  12, 34, TRUE,  FALSE },
+    /* AF */ { ACT_BURNING_JUMP,            1,  12, 34, TRUE,  FALSE },
+    /* AB */ { ACT_BURNING_JUMP,            1,  12, 34, TRUE,  FALSE },
+    /* WF */ { ACT_BURNING_JUMP,            1,  12, 34, TRUE,  FALSE },
+    /* WB */ { ACT_BURNING_JUMP,            1,  12, 34, TRUE,  FALSE },
+
+    /* MARIO_UNPOSSESS_ACT_GRABBED */
+    /* GF */ { ACT_GRABBED,                 0,   0,  0, FALSE, FALSE },
+    /* GB */ { ACT_GRABBED,                 0,   0,  0, FALSE, FALSE },
+    /* AF */ { ACT_GRABBED,                 0,   0,  0, FALSE, FALSE },
+    /* AB */ { ACT_GRABBED,                 0,   0,  0, FALSE, FALSE },
+    /* WF */ { ACT_GRABBED,                 0,   0,  0, FALSE, FALSE },
+    /* WB */ { ACT_GRABBED,                 0,   0,  0, FALSE, FALSE },
+
+    /* MARIO_UNPOSSESS_ACT_EATEN */
+    /* GF */ { ACT_EATEN_BY_BUBBA,          0,   0,  0, FALSE, FALSE },
+    /* GB */ { ACT_EATEN_BY_BUBBA,          0,   0,  0, FALSE, FALSE },
+    /* AF */ { ACT_EATEN_BY_BUBBA,          0,   0,  0, FALSE, FALSE },
+    /* AB */ { ACT_EATEN_BY_BUBBA,          0,   0,  0, FALSE, FALSE },
+    /* WF */ { ACT_EATEN_BY_BUBBA,          0,   0,  0, FALSE, FALSE },
+    /* WB */ { ACT_EATEN_BY_BUBBA,          0,   0,  0, FALSE, FALSE },
+
+    /* MARIO_UNPOSSESS_ACT_BLOWN */
+    /* GF */ { ACT_GETTING_BLOWN,           0, -24, 12, FALSE, FALSE },
+    /* GB */ { ACT_GETTING_BLOWN,           0, -24, 12, FALSE, FALSE },
+    /* AF */ { ACT_GETTING_BLOWN,           0, -24, 12, FALSE, FALSE },
+    /* AB */ { ACT_GETTING_BLOWN,           0, -24, 12, FALSE, FALSE },
+    /* WF */ { ACT_GETTING_BLOWN,           0, -24, 12, FALSE, FALSE },
+    /* WB */ { ACT_GETTING_BLOWN,           0, -24, 12, FALSE, FALSE },
+
+    /* MARIO_UNPOSSESS_ACT_TORNADO */
+    /* GF */ { ACT_TORNADO_TWIRLING,        0,   0,  0, FALSE, FALSE },
+    /* GB */ { ACT_TORNADO_TWIRLING,        0,   0,  0, FALSE, FALSE },
+    /* AF */ { ACT_TORNADO_TWIRLING,        0,   0,  0, FALSE, FALSE },
+    /* AB */ { ACT_TORNADO_TWIRLING,        0,   0,  0, FALSE, FALSE },
+    /* WF */ { ACT_TORNADO_TWIRLING,        0,   0,  0, FALSE, FALSE },
+    /* WB */ { ACT_TORNADO_TWIRLING,        0,   0,  0, FALSE, FALSE },
+};
+
+s32 mario_unpossess_object(struct MarioState *m, u8 unpossessAct, s32 isBackwards, u32 objIntangibleFrames) {
+    struct PObject *pobj = m->oPossessedObject;
+    if (pobj == NULL) {
+        return FALSE;
+    }
+
+    // Unpossess action
+    s32 terrainType = (obj_is_underwater(pobj, find_water_level(pobj->oPosX, pobj->oPosZ)) ? 2 : (obj_is_on_ground(pobj) ? 0 : 1));
+    s32 actionIndex = (unpossessAct * 6) + (terrainType * 2) + isBackwards;
+    u32 action      = (u32) sMarioUnpossessActions[actionIndex][0];
+    u32 actionArg   = (u32) sMarioUnpossessActions[actionIndex][1];
+    f32 forwardVel  = (f32) sMarioUnpossessActions[actionIndex][2];
+    f32 verticalVel = (f32) sMarioUnpossessActions[actionIndex][3];
+    s32 comeFromTop = (s32) sMarioUnpossessActions[actionIndex][4];
+    s16 faceYaw     = (s16) sMarioUnpossessActions[actionIndex][5];
+
+    mario_cappy_update_object_and_gfx(m);
+    mario_set_forward_vel(m, forwardVel);
+    if (verticalVel != 0.f) m->vel[1] = verticalVel;
+    m->pos[1] += (comeFromTop * pobj->smoData->captureData->gettop(pobj));
+    m->faceAngle[1] += faceYaw * 0x8000;
+    m->input &= ~(INPUT_FIRST_PERSON | INPUT_A_PRESSED | INPUT_A_DOWN | INPUT_B_PRESSED | INPUT_Z_DOWN | INPUT_Z_PRESSED);
+    m->marioObj->header.gfx.node.flags &= ~GRAPH_RENDER_INVISIBLE;
+    set_mario_action(m, action, actionArg);
+
+    // Unload cap, restore camera
+    smo_play_sound_effect(SOUND_ACTION_CAPPY_2, m->marioObj->header.gfx.cameraToObject);
+    obj_spawn_white_puff(m->marioObj, -1);
+    smo_obj_free_data(m->oObjectCap);
+    obj_mark_for_deletion(m->oObjectCap);
+    smo_capture_reset_camera(pobj);
+
+    // End object possession
+    restore_object_data(pobj);
+    pobj->smoData->captureData->end(pobj);
+    smo_obj_free_data(pobj);
+    pobj->oIntangibleTimer = objIntangibleFrames;
+
+    // Clear fields
+    m->oPossessedObject = NULL;
+    m->oObjectCap = NULL;
+    m->oPossessionTimer = 0;
+    m->oPossessionLock = FALSE;
+
+    return TRUE;
+}
+
diff --git a/data/smo/object/smo_helpers.c b/data/smo/object/smo_helpers.c
new file mode 100644
index 0000000..2bae26a
--- /dev/null
+++ b/data/smo/object/smo_helpers.c
@@ -0,0 +1,552 @@
+#include "../smo_c_includes.h"
+#include <stdarg.h>
+
+//
+// Object stuff
+//
+
+struct Object *obj_get_first(struct ObjectNode *list) {
+    struct Object *obj = (struct Object *) list->next;
+    if (obj == (struct Object *) list) {
+        return NULL;
+    }
+    return obj;
+}
+
+struct Object *obj_get_next(struct ObjectNode *list, struct Object *obj) {
+    struct Object *next = (struct Object *) obj->header.next;
+    if (next == (struct Object *) list) {
+        return NULL;
+    }
+    return next;
+}
+
+struct Object *obj_get_first_with_behavior(struct Object *obj, const BehaviorScript *behavior) {
+    struct ObjectNode *listHead = &gObjectLists[get_object_list_from_behavior(behavior)];
+    struct Object *next = (struct Object *) listHead->next;
+    while (next != (struct Object *) listHead) {
+        if (next->behavior == behavior && next->activeFlags != ACTIVE_FLAG_DEACTIVATED && next != obj) {
+            return next;
+        }
+        next = (struct Object *) next->header.next;
+    }
+    return NULL;
+}
+
+struct Object *obj_get_first_child_with_behavior(struct Object *obj, const BehaviorScript *behavior) {
+    struct ObjectNode *listHead = &gObjectLists[get_object_list_from_behavior(behavior)];
+    struct Object *next = (struct Object *) listHead->next;
+    while (next != (struct Object *) listHead) {
+        if (next->behavior == behavior && next->activeFlags != ACTIVE_FLAG_DEACTIVATED && next != obj && next->parentObj == obj) {
+            return next;
+        }
+        next = (struct Object *) next->header.next;
+    }
+    return NULL;
+}
+
+struct Object *obj_get_nearest_with_behavior(struct Object *obj, const BehaviorScript *behavior) {
+    f32 nearDist = 15000.f;
+    struct Object *nearObj = NULL;
+    struct ObjectNode *listHead = &gObjectLists[get_object_list_from_behavior(behavior)];
+    struct Object *next = (struct Object *) listHead->next;
+    while (next != (struct Object *) listHead) {
+        if (next->behavior == behavior) {
+            if (next->activeFlags != ACTIVE_FLAG_DEACTIVATED && next != obj) {
+                f32 dist = sqrtf(sqr(obj->oPosX - next->oPosX) + sqr(obj->oPosY - next->oPosY) + sqr(obj->oPosZ - next->oPosZ));
+                if (dist < nearDist) {
+                    nearObj = next;
+                    nearDist = dist;
+                }
+            }
+        }
+        next = (struct Object *) next->header.next;
+    }
+    return nearObj;
+}
+
+u8 obj_get_list_index(struct Object *obj) {
+    u8 cmd = ((obj->behavior[0] >> 24) & 0xFF);
+    return (cmd == 0x00 ? (u8)((obj->behavior[0] >> 16) & 0xFF) : OBJ_LIST_DEFAULT);
+}
+
+s32 obj_is_surface(struct Object *obj) {
+    u8 type = obj_get_list_index(obj);
+    return
+        type == OBJ_LIST_SURFACE ||
+        type == OBJ_LIST_POLELIKE;
+}
+
+s32 obj_is_on_ground(struct Object *obj) {
+    return (obj->oFloor != NULL) && (obj->oFloorHeight == 0);
+}
+
+s32 obj_is_underwater(struct Object *obj, f32 waterLevel) {
+    return (obj->oPosY + (obj->hitboxHeight / 2) - obj->hitboxDownOffset) < waterLevel;
+}
+
+s16 obj_get_object1_angle_yaw_to_object2(struct Object *obj1, struct Object *obj2) {
+    return atan2s(obj2->oPosZ - obj1->oPosZ, obj2->oPosX - obj1->oPosX);
+}
+
+s32 obj_is_object1_facing_object2(struct Object *obj1, struct Object *obj2, s16 angleRange) {
+    s16 yawObj1ToObj2 = obj_get_object1_angle_yaw_to_object2(obj1, obj2);
+    s32 yawDiff = (s32)((s16)((s32)(yawObj1ToObj2) - (s32)(obj1->oMoveAngleYaw)));
+    return (-angleRange <= yawDiff) && (yawDiff <= angleRange);
+}
+
+s32 obj_is_object2_hit_from_above(struct Object *obj1, struct Object *obj2) {
+    return (obj1->oVelY < 0.f) && (obj1->oPosY >= (obj2->oPosY + (obj2->hitboxHeight / 2) - obj2->hitboxDownOffset));
+}
+
+s32 obj_is_object2_hit_from_below(struct Object *obj1, struct Object *obj2) {
+    return (obj1->oVelY > 0.f) && (obj2->oPosY >= (obj1->oPosY + (obj1->hitboxHeight / 2) - obj1->hitboxDownOffset));
+}
+
+struct Box { f32 radius; f32 height; };
+static struct Box obj_get_box_for_overlap_check(struct Object *obj, u32 flags) {
+    struct Box box;
+    f32 hitboxRadius = obj->hitboxRadius;
+    f32 hitboxHeight = obj->hitboxHeight;
+    f32 hurtboxRadius = obj->hurtboxRadius;
+    f32 hurtboxHeight = obj->hurtboxHeight;
+
+    if (flags & OBJ_OVERLAP_FLAG_HITBOX_HURTBOX_MAX) {
+        box.radius = MAX(hitboxRadius, hurtboxRadius);
+        box.height = MAX(hitboxHeight, hurtboxHeight);
+    } else if (flags & OBJ_OVERLAP_FLAG_HURTBOX_HITBOX_IF_ZERO) {
+        box.radius = hurtboxRadius;
+        box.height = hurtboxHeight;
+        if (box.radius <= 0 || box.height <= 0) {
+            box.radius = hitboxRadius;
+            box.height = hitboxHeight;
+        }
+    } else if (flags & OBJ_OVERLAP_FLAG_HITBOX) {
+        box.radius = hitboxRadius;
+        box.height = hitboxHeight;
+    } else { // No box by default
+        box.radius = 0;
+        box.height = 0;
+    }
+    return box;
+}
+
+s32 obj_detect_overlap(struct Object *obj1, struct Object *obj2, u32 obj1Flags, u32 obj2Flags) {
+    // Tangibility check
+    if ((obj1->oIntangibleTimer != 0 && !(obj1Flags & OBJ_OVERLAP_FLAG_IGNORE_INTANGIBLE)) ||
+        (obj2->oIntangibleTimer != 0 && !(obj2Flags & OBJ_OVERLAP_FLAG_IGNORE_INTANGIBLE))) {
+        return FALSE;
+    }
+
+    // Box dimensions check
+    struct Box box1 = obj_get_box_for_overlap_check(obj1, obj1Flags);
+    struct Box box2 = obj_get_box_for_overlap_check(obj2, obj2Flags);
+    if (box1.radius == 0 || box1.height == 0 ||
+        box2.radius == 0 || box2.height == 0) {
+        return FALSE;
+    }
+
+    // Radius check
+    f32 sumOfRadius2 = sqr(box1.radius + box2.radius);
+    f32 distance2 = sqr(obj1->oPosX - obj2->oPosX) + sqr(obj1->oPosZ - obj2->oPosZ);
+    if (distance2 > sumOfRadius2) {
+        return FALSE;
+    }
+
+    // Height check
+    f32 obj1LowerBound = obj1->oPosY - obj1->hitboxDownOffset;
+    f32 obj1UpperBound = box1.height + obj1LowerBound;
+    f32 obj2LowerBound = obj2->oPosY - obj2->hitboxDownOffset;
+    f32 obj2UpperBound = box2.height + obj2LowerBound;
+    f32 sumOfHeights   = box1.height + box2.height;
+    if (((obj2UpperBound - obj1LowerBound) > sumOfHeights) ||
+        ((obj1UpperBound - obj2LowerBound) > sumOfHeights)) {
+        return FALSE;
+    }
+
+    return TRUE;
+}
+
+s32 obj_check_if_near_animation_end(struct Object *obj) {
+    u32 spC = (s32) obj->header.gfx.unk38.curAnim->flags;
+    s32 sp8 = obj->header.gfx.unk38.animFrame;
+    s32 sp4 = obj->header.gfx.unk38.curAnim->unk08 - 2;
+    s32 sp0 = FALSE;
+
+    if (spC & 0x01) {
+        if (sp4 + 1 == sp8) {
+            sp0 = TRUE;
+        }
+    }
+
+    if (sp8 == sp4) {
+        sp0 = TRUE;
+    }
+
+    return sp0;
+}
+
+void obj_set_forward_vel(struct Object *obj, s16 yaw, f32 mag, f32 velMax) {
+    obj->oVelX = sins(yaw) * mag * velMax;
+    obj->oVelZ = coss(yaw) * mag * velMax;
+    obj->oForwardVel = mag * velMax;
+}
+
+#define STEPS 32
+#define Y_START_OFFSET 30.f
+static s32 obj_process_surface_collisions(struct Object *obj, s32 moveThroughVCWalls, s32 onGround) {
+
+    if (moveThroughVCWalls) {
+        obj->activeFlags |= ACTIVE_FLAG_MOVE_THROUGH_GRATE;
+    } else {
+        obj->activeFlags &= ~ACTIVE_FLAG_MOVE_THROUGH_GRATE;
+    }
+
+    // Wall collision
+    struct Surface *wall = NULL;
+    f32 dy = MAX(0.f, obj->hitboxHeight - Y_START_OFFSET) / STEPS;
+    for (s32 i = 0; i != STEPS; ++i) {
+        struct WallCollisionData hitbox;
+        hitbox.x = obj->oPosX;
+        hitbox.y = obj->oPosY;
+        hitbox.z = obj->oPosZ;
+        hitbox.offsetY = Y_START_OFFSET + (dy * i) - obj->hitboxDownOffset;
+        hitbox.radius = obj->oWallHitboxRadius;
+        if (find_wall_collisions(&hitbox) != 0) {
+            obj->oPosX = hitbox.x;
+            obj->oPosY = hitbox.y;
+            obj->oPosZ = hitbox.z;
+            wall = hitbox.walls[0];
+        }
+    }
+
+    // Floor collision
+    struct Surface *floor = NULL;
+    f32 floorY = find_floor(obj->oPosX, obj->oPosY - obj->hitboxDownOffset, obj->oPosZ, &floor) + obj->hitboxDownOffset;
+    if (floor != NULL) {
+        if (obj->oPosY <= floorY + (onGround ? 40.0f : 0.0f)) {
+            obj->oPosY = floorY;
+            obj->oVelY = MAX(obj->oVelY, 0.f);
+        }
+        obj->oFloor = floor;
+        obj->oFloorHeight = obj->oPosY - floorY;
+    } else {
+        // Out of bounds
+        obj->oVelX = 0;
+        obj->oVelZ = 0;
+        return FALSE;
+    }
+    
+    // Ceiling collision
+    struct Surface *ceil = NULL;
+    f32 ceilY = find_ceil(obj->oPosX, obj->oPosY, obj->oPosZ, &ceil);
+    if (ceil != NULL) {
+        f32 h = (obj->hitboxHeight - obj->hitboxDownOffset);
+        if (obj->oPosY <= ceilY && obj->oPosY + h > ceilY) {
+            obj->oPosY = MAX(ceilY - h, floorY);
+            obj->oVelY = MIN(obj->oVelY, 0.f);
+            if (obj->oPosY == floorY) {
+                // Treat floor + ceiling collision
+                // as OOB to cancel out step
+                return FALSE;
+            }
+            // Counts as a wall
+            obj->oWall = ceil;
+        }
+    }
+
+    // A solid wall is hit
+    if (wall) {
+        obj->oWall = wall;
+    }
+    return TRUE;
+}
+#undef STEPS
+#undef Y_START_OFFSET
+
+#define STEPS 8
+void obj_update_pos_and_vel(struct Object *obj, s32 moveThroughVCWalls, s32 onGround, s8 *squishTimer) {
+    obj->oFloor = NULL;
+    obj->oWall = NULL;
+
+    // Squish test
+    if (squishTimer != NULL) {
+        s32 squished = 0;
+        struct Surface *floor = NULL;
+        f32 floorY = find_floor(obj->oPosX, obj->oPosY - obj->hitboxDownOffset, obj->oPosZ, &floor) + obj->hitboxDownOffset;
+        if (floor != NULL) {
+            struct Surface *ceil = NULL;
+            f32 ceilY = find_ceil(obj->oPosX, obj->oPosY, obj->oPosZ, &ceil);
+            if (ceil != NULL) {
+                f32 h = (obj->hitboxHeight - obj->hitboxDownOffset);
+                if ((obj->oPosY <= ceilY) && (obj->oPosY + h > ceilY) && (ceilY - floorY < h)) {
+                    squished = 1;
+                }
+            }
+        }
+        *squishTimer = squished * (*squishTimer + 1);
+    }
+
+    // Movement
+    for (s32 i = 0; i != STEPS; ++i) {
+        f32 x = obj->oPosX;
+        f32 y = obj->oPosY;
+        f32 z = obj->oPosZ;
+        obj->oPosX += (obj->oVelX / STEPS);
+        obj->oPosY += (obj->oVelY / STEPS);
+        obj->oPosZ += (obj->oVelZ / STEPS);
+
+        if (!obj_process_surface_collisions(obj, moveThroughVCWalls, onGround)) {
+            // Out of bounds, cancel out step
+            obj->oPosX = x;
+            obj->oPosY = y;
+            obj->oPosZ = z;
+        } else {
+            onGround = (obj_is_on_ground(obj) && obj->oVelY <= 0.f);
+        }
+    }
+
+    obj->oHomeX = obj->oPosX;
+    obj->oHomeY = obj->oPosY;
+    obj->oHomeZ = obj->oPosZ;
+    obj->oForwardVel = sqrtf(sqr(obj->oVelX) + sqr(obj->oVelZ));
+}
+#undef STEPS
+
+void obj_update_blink_state(struct Object *obj, s32 *timer, s16 base, s16 range, s16 length) {
+    if (*timer != 0) {
+        (*timer)--;
+    } else {
+        *timer = base + (s16)(range * random_float());
+    }
+
+    if (*timer > length) {
+        obj->oAnimState = 0;
+    } else {
+        obj->oAnimState = 1;
+    }
+}
+
+void obj_random_blink(struct Object *obj, s32 *timer) {
+    if (*timer == 0) {
+        if ((s16)(random_float() * 100.0f) == 0) {
+            obj->oAnimState = 1;
+            *timer = 1;
+        }
+    } else {
+        (*timer)++;
+        if (*timer >= 6) {
+            obj->oAnimState = 0;
+        }
+        if (*timer >= 11) {
+            obj->oAnimState = 1;
+        }
+        if (*timer >= 16) {
+            obj->oAnimState = 0;
+            *timer = 0;
+        }
+    }
+}
+
+static void bhv_fire_smoke_init(void) {
+    cur_obj_scale(random_float() * 2 + 4.0);
+}
+
+static const BehaviorScript bhvFireSmoke[] = {
+    0x00060000,
+    0x11010001,
+    0x21000000,
+    0x0C000000, (uintptr_t) bhv_fire_smoke_init,
+    0x101AFFFF,
+    0x0500000A,
+    0x0F1A0001,
+    0x06000000,
+    0x1D000000,
+};
+
+void obj_make_step_sound_and_particle(struct Object *obj, f32 *dist, f32 distMin, f32 distInc, s32 soundBits, u32 particles) {
+    *dist += distInc;
+    if (*dist >= distMin) {
+        *dist -= distMin;
+
+        // Particles
+        if (particles & OBJ_STEP_PARTICLE_MIST) {
+            spawn_object(obj, MODEL_NONE, bhvMistParticleSpawner);
+        }
+        if (particles & OBJ_STEP_PARTICLE_SMOKE) {
+            spawn_object(obj, MODEL_SMOKE, bhvWhitePuffSmoke);
+        }
+        if (particles & OBJ_STEP_PARTICLE_WATER_TRAIL) {
+            spawn_object(obj, MODEL_WAVE_TRAIL, bhvObjectWaveTrail);
+        }
+        if (particles & OBJ_STEP_PARTICLE_WATER_DROPLET) {
+            for (s32 i = 0; i != 2; ++i) {
+                struct Object *drop = spawn_object_with_scale(obj, MODEL_WHITE_PARTICLE_SMALL, bhvWaterDroplet, 1.5f);
+                drop->oVelY = random_float() * 30.0f;
+                obj_translate_xz_random(drop, 110.0f);
+            }
+        }
+        if (particles & OBJ_STEP_PARTICLE_FIRE) {
+            spawn_object(obj, MODEL_RED_FLAME, bhvFireSmoke);
+        }
+        if (particles & OBJ_STEP_PARTICLE_FLAME) {
+            for (s32 i = 0; i != 2; ++i) {
+                spawn_object(obj, MODEL_RED_FLAME, bhvKoopaShellFlame);
+            }
+        }
+
+        // Sound effect
+        if (soundBits != -1) {
+            play_sound(soundBits, obj->header.gfx.cameraToObject);
+        }
+    }
+}
+
+void obj_set_animation_with_accel(struct Object *obj, s32 animIndex, f32 accel) {
+    struct Animation **anims = obj->oAnimations;
+    s32 animAccel = (s32)(accel * 65536.0f);
+    geo_obj_init_animation_accel(&obj->header.gfx, &anims[animIndex], animAccel);
+    obj->oSoundStateID = animIndex;
+}
+
+void obj_spawn_white_puff(struct Object *obj, s32 soundBits) {
+    return obj_spawn_white_puff_at(obj->oPosX, obj->oPosY, obj->oPosZ, soundBits);
+}
+
+void obj_spawn_white_puff_at(f32 x, f32 y, f32 z, s32 soundBits) {
+    for (s32 i = 0; i < 16; ++i) {
+        struct Object *particle = spawn_object(gMarioObject, MODEL_MIST, bhvWhitePuffExplosion);
+        if (particle != NULL) {
+            particle->oPosX = x;
+            particle->oPosY = y;
+            particle->oPosZ = z;
+            particle->oBehParams2ndByte = 2;
+            particle->oMoveAngleYaw = random_u16();
+            particle->oGravity = -4.f;
+            particle->oDragStrength = 30.f;
+            particle->oForwardVel = random_float() * 5.f + 40.f;
+            particle->oVelY = random_float() * 20.f + 30.f;
+            f32 scale = random_float() * 0.25f + 4.6f;
+            obj_scale_xyz(particle, scale, scale, scale);
+        }
+    }
+    if (soundBits != -1) {
+        struct Object *sound = spawn_object(gMarioObject, 0, bhvSoundSpawner);
+        if (sound != NULL) {
+            sound->oPosX = x;
+            sound->oPosY = y;
+            sound->oPosZ = z;
+            if (soundBits == 0) {
+                sound->oSoundEffectUnkF4 = SOUND_OBJ_DEFAULT_DEATH;
+            } else {
+                sound->oSoundEffectUnkF4 = soundBits;
+            }
+        }
+    }
+}
+
+void obj_spawn_triangle_break_particles(struct Object *obj, s32 numTris, s16 triModel, f32 triSize, s16 triAnimState) {
+    for (s32 i = 0; i < numTris; i++) {
+        struct Object *triangle = spawn_object(obj, triModel, bhvBreakBoxTriangle);
+        if (triangle != NULL) {
+            triangle->oAnimState = triAnimState;
+            triangle->oPosY += 100.0f;
+            triangle->oMoveAngleYaw = random_u16();
+            triangle->oFaceAngleYaw = triangle->oMoveAngleYaw;
+            triangle->oFaceAnglePitch = random_u16();
+            triangle->oVelY = random_f32_around_zero(50.0f);
+            if (triModel == 138 || triModel == 56) {
+                triangle->oAngleVelPitch = 0xF00;
+                triangle->oAngleVelYaw = 0x500;
+                triangle->oForwardVel = 30.0f;
+            } else {
+                triangle->oAngleVelPitch = 0x80 * (s32)(random_float() + 50.0f);
+                triangle->oForwardVel = 30.0f;
+            }
+            obj_scale(triangle, triSize);
+        }
+    }
+}
+
+void obj_instant_death(struct Object *obj) {
+    // Spawn coins
+    if (obj->oNumLootCoins < 0) {
+        spawn_object(obj, MODEL_BLUE_COIN, bhvMrIBlueCoin);
+    } else {
+        obj_spawn_loot_yellow_coins(obj, obj->oNumLootCoins, 20.0f);
+    }
+
+    // ded
+    obj_spawn_white_puff(obj, obj->oDeathSound);
+    obj_mark_for_deletion(obj);
+}
+
+void obj_explode(struct Object *obj, s32 soundBits) {
+    // Spawn coins
+    if (obj->oNumLootCoins < 0) {
+        spawn_object(obj, MODEL_BLUE_COIN, bhvMrIBlueCoin);
+    } else {
+        obj_spawn_loot_yellow_coins(obj, obj->oNumLootCoins, 20.0f);
+    }
+
+    // explode
+    obj_spawn_white_puff(obj, soundBits);
+    obj_spawn_triangle_break_particles(obj, 30, 138, 3.0f, 4);
+    obj_mark_for_deletion(obj);
+}
+
+void obj_update_gfx(struct Object *obj) {
+    obj->header.gfx.pos[0] = obj->oPosX;
+    obj->header.gfx.pos[1] = obj->oPosY + obj->oGraphYOffset;
+    obj->header.gfx.pos[2] = obj->oPosZ;
+    obj->header.gfx.angle[0] = obj->oFaceAnglePitch & 0xFFFF;
+    obj->header.gfx.angle[1] = obj->oFaceAngleYaw   & 0xFFFF;
+    obj->header.gfx.angle[2] = obj->oFaceAngleRoll  & 0xFFFF;
+}
+
+//
+// Other
+//
+
+const char *int_to_string(s32 value, const char *format) {
+    static char buffer[64];
+    bzero(buffer, 64);
+    if (!format || strlen(format) > 8) {
+        return buffer;
+    }
+    sprintf(buffer, format, value);
+    return buffer;
+}
+
+const u8 *int_to_sm64_string(s32 value, const char *format) {
+    static u8 buffer[64];
+    bzero(buffer, 64);
+    if (!format || strlen(format) > 8) {
+        return buffer;
+    }
+    s32 len = sprintf((char *) buffer, format, value);
+    for (s32 i = 0; i < len; ++i) {
+        if (buffer[i] >= 'A' && buffer[i] <= 'F') {
+            buffer[i] = buffer[i] - 'A';
+        } else if (buffer[i] >= 'a' && buffer[i] <= 'f') {
+            buffer[i] = buffer[i] - 'a';
+        } else {
+            buffer[i] = buffer[i] - '0';
+        }
+    }
+    buffer[len] = DIALOG_CHAR_TERMINATOR;
+    return buffer;
+}
+
+void vec3f_rotate_zxy(Vec3f v, s16 pitch, s16 yaw, s16 roll) {
+    Vec3f t = { 0, 0, 0 };
+    Vec3s r = { pitch, yaw, roll };
+    Mat4 mtx;
+    mtxf_rotate_zxy_and_translate(mtx, t, r);
+    f32 x = v[0];
+    f32 y = v[1];
+    f32 z = v[2];
+    v[0] = x * mtx[0][0] + y * mtx[1][0] + z * mtx[2][0] + mtx[3][0];
+    v[1] = x * mtx[0][1] + y * mtx[1][1] + z * mtx[2][1] + mtx[3][1];
+    v[2] = x * mtx[0][2] + y * mtx[1][2] + z * mtx[2][2] + mtx[3][2];
+}
\ No newline at end of file
diff --git a/data/smo/object/smo_helpers.h b/data/smo/object/smo_helpers.h
new file mode 100644
index 0000000..c8a4b3f
--- /dev/null
+++ b/data/smo/object/smo_helpers.h
@@ -0,0 +1,55 @@
+#ifndef SMO_HELPERS_H
+#define SMO_HELPERS_H
+
+#include "types.h"
+
+/* Flags */
+#define OBJ_OVERLAP_FLAG_HITBOX					(1 << 0)
+#define OBJ_OVERLAP_FLAG_HURTBOX_HITBOX_IF_ZERO	(1 << 1)
+#define OBJ_OVERLAP_FLAG_HITBOX_HURTBOX_MAX		(1 << 2)
+#define OBJ_OVERLAP_FLAG_IGNORE_INTANGIBLE		(1 << 3)
+
+/* Particles */
+#define OBJ_STEP_PARTICLE_NONE				0
+#define OBJ_STEP_PARTICLE_MIST				(1 << 0)
+#define OBJ_STEP_PARTICLE_SMOKE				(1 << 1)
+#define OBJ_STEP_PARTICLE_WATER_TRAIL		(1 << 2)
+#define OBJ_STEP_PARTICLE_WATER_DROPLET		(1 << 3)
+#define OBJ_STEP_PARTICLE_FIRE				(1 << 4)
+#define OBJ_STEP_PARTICLE_FLAME				(1 << 5)
+
+/* Object stuff */
+struct Object *obj_get_first(struct ObjectNode *list);
+struct Object *obj_get_next(struct ObjectNode *list, struct Object *obj);
+struct Object *obj_get_first_with_behavior(struct Object *obj, const BehaviorScript *behavior);
+struct Object *obj_get_first_child_with_behavior(struct Object *obj, const BehaviorScript *behavior);
+struct Object *obj_get_nearest_with_behavior(struct Object *obj, const BehaviorScript *behavior);
+u8   obj_get_list_index(struct Object *obj);
+s32  obj_is_surface(struct Object *obj);
+s32  obj_is_on_ground(struct Object *obj);
+s32  obj_is_underwater(struct Object *obj, f32 waterLevel);
+s16  obj_get_object1_angle_yaw_to_object2(struct Object *obj1, struct Object *obj2);
+s32  obj_is_object1_facing_object2(struct Object *obj1, struct Object *obj2, s16 angleRange);
+s32  obj_is_object2_hit_from_above(struct Object *obj1, struct Object *obj2);
+s32  obj_is_object2_hit_from_below(struct Object *obj1, struct Object *obj2);
+s32  obj_detect_overlap(struct Object *obj1, struct Object *obj2, u32 obj1Flags, u32 obj2Flags);
+s32  obj_check_if_near_animation_end(struct Object *obj);
+void obj_set_forward_vel(struct Object *obj, s16 yaw, f32 mag, f32 velMax);
+void obj_update_pos_and_vel(struct Object *obj, s32 moveThroughVCWalls, s32 onGround, s8 *squishTimer);
+void obj_update_blink_state(struct Object *obj, s32 *timer, s16 base, s16 range, s16 length);
+void obj_random_blink(struct Object *obj, s32 *timer);
+void obj_make_step_sound_and_particle(struct Object *obj, f32 *dist, f32 distMin, f32 distInc, s32 soundBits, u32 particles);
+void obj_set_animation_with_accel(struct Object *obj, s32 animIndex, f32 accel);
+void obj_spawn_white_puff(struct Object *obj, s32 soundBits);
+void obj_spawn_white_puff_at(f32 x, f32 y, f32 z, s32 soundBits);
+void obj_spawn_triangle_break_particles(struct Object* obj, s32 numTris, s16 triModel, f32 triSize, s16 triAnimState);
+void obj_instant_death(struct Object *obj);
+void obj_explode(struct Object *obj, s32 soundBits);
+void obj_update_gfx(struct Object *obj);
+
+/* Other */
+const char *int_to_string(s32 value, const char *format);
+const u8 *int_to_sm64_string(s32 value, const char *format);
+void vec3f_rotate_zxy(Vec3f v, s16 pitch, s16 yaw, s16 roll);
+
+#endif // SMO_HELPERS_H
diff --git a/data/smo/object/smo_object.c b/data/smo/object/smo_object.c
new file mode 100644
index 0000000..753f2d1
--- /dev/null
+++ b/data/smo/object/smo_object.c
@@ -0,0 +1,58 @@
+#include "../smo_c_includes.h"
+#include "actors/group12.h"
+
+//
+// SMO Fields
+//
+
+#define MAX_SMO_FIELDS 0x40
+
+struct SmoFields {
+    struct Object *ref;
+    struct SmoData data;
+};
+static struct SmoFields sSmoFields[MAX_SMO_FIELDS];
+
+static struct SmoFields *find_smo_fields(struct Object *obj) {
+    for (s32 i = 0; i != MAX_SMO_FIELDS; ++i) {
+        if (sSmoFields[i].ref == obj) {
+            return &sSmoFields[i];
+        }
+    }
+    return NULL;
+}
+
+void smo_obj_alloc_data(struct Object *obj, struct MarioState *m) {
+    struct SmoFields *sf = find_smo_fields(NULL);
+    bzero(&sf->data, sizeof(sf->data));
+    obj->smoData = &sf->data;
+    obj->smoData->mario = m;
+    sf->ref = obj;
+}
+
+void smo_obj_free_data(struct Object *obj) {
+    struct SmoFields *sf = find_smo_fields(obj);
+    if (sf != NULL) {
+        sf->ref = NULL;
+    }
+}
+
+void smo_free_all_data() {
+    bzero(sSmoFields, sizeof(sSmoFields));
+}
+
+void smo_object_reset() {
+    smo_free_all_data();
+}
+
+//
+// SMO Object Models
+//
+
+void smo_load_models() {
+    struct AllocOnlyPool *pool = alloc_only_pool_init(main_pool_available() - sizeof(struct AllocOnlyPool), MEMORY_POOL_LEFT);
+    gLoadedGraphNodes[MODEL_SHOCK_WAVE] = process_geo_layout(pool, (void *) invisible_bowser_accessory_geo);
+    DEBUG_ONLY(gLoadedGraphNodes[MODEL_DBG_CYLINDER_HITBOX] = process_geo_layout(pool, (void *) dbg_cylinder_hitbox_geo);)
+    DEBUG_ONLY(gLoadedGraphNodes[MODEL_DBG_CYLINDER_HURTBOX] = process_geo_layout(pool, (void *) dbg_cylinder_hurtbox_geo);)
+    alloc_only_pool_resize(pool, pool->usedSpace);
+}
diff --git a/data/smo/object/smo_object.h b/data/smo/object/smo_object.h
new file mode 100644
index 0000000..22583bd
--- /dev/null
+++ b/data/smo/object/smo_object.h
@@ -0,0 +1,56 @@
+#ifndef SMO_OBJECT_H
+#define SMO_OBJECT_H
+
+#include "types.h"
+
+/* SMO Fields */
+/* See smo_defines for fields macros */
+struct SmoCaptureData;
+struct SmoData {
+    struct MarioState *mario;
+
+    union {
+        s8  asS8 [0x20][4];
+        s16 asS16[0x20][2];
+        s32 asS32[0x20];
+        f32 asF32[0x20];
+    } fields;
+
+    union {
+        struct Object *asObject[0x10];
+        void *asVoidPtr[0x10];
+    } refs;
+
+    /* Possessed object only */
+
+    const struct SmoCaptureData *captureData; // Read-only!
+
+    struct {
+        u32 rawData[0x50];
+#if IS_64_BIT
+        void *ptrData[0x50];
+#endif
+        const BehaviorScript *behavior;
+        const BehaviorScript *curBhvCommand;
+        u32 bhvStackIndex;
+        uintptr_t bhvStack[8];
+        f32 hitboxRadius;
+        f32 hitboxHeight;
+        f32 hurtboxRadius;
+        f32 hurtboxHeight;
+        f32 hitboxDownOffset;
+        f32 gfxScaleX;
+        f32 gfxScaleY;
+        f32 gfxScaleZ;
+    } objData;
+};
+
+void smo_obj_alloc_data(struct Object *obj, struct MarioState *m);
+void smo_obj_free_data(struct Object *obj);
+void smo_free_all_data();
+void smo_object_reset();
+
+/* SMO Object Models */
+void smo_load_models();
+
+#endif // SMO_OBJECT_H
diff --git a/data/smo/smo_c_includes.h b/data/smo/smo_c_includes.h
new file mode 100644
index 0000000..9973a30
--- /dev/null
+++ b/data/smo/smo_c_includes.h
@@ -0,0 +1,42 @@
+#ifndef SMO_C_INCLUDES_H
+#define SMO_C_INCLUDES_H
+
+/* Include this file only in .c files */
+
+/* include */
+#include "sm64.h"
+#include "behavior_data.h"
+#include "gfx_dimensions.h"
+#include "dialog_ids.h"
+#include "libc/string.h"
+#include <stdio.h>
+
+/* src/game */
+#include "game/object_list_processor.h"
+#include "game/object_helpers.h"
+#include "game/spawn_object.h"
+#include "game/spawn_sound.h"
+#include "game/game_init.h"
+#include "game/level_update.h"
+#include "game/interaction.h"
+#include "game/ingame_menu.h"
+#include "game/mario.h"
+#include "game/mario_step.h"
+#include "game/print.h"
+#include "game/save_file.h"
+#include "game/segment2.h"
+
+/* src/engine */
+#include "engine/surface_collision.h"
+#include "engine/behavior_script.h"
+#include "engine/graph_node.h"
+#include "engine/math_util.h"
+
+/* src/audio */
+#include "audio/external.h"
+
+/* pc */
+#include "pc/configfile.h"
+#include "pc/controller/controller_api.h"
+
+#endif // SMO_C_INCLUDES_H
diff --git a/data/smo/smo_defines.h b/data/smo/smo_defines.h
new file mode 100644
index 0000000..2bf4750
--- /dev/null
+++ b/data/smo/smo_defines.h
@@ -0,0 +1,207 @@
+#ifndef SMO_DEFINES_H
+#define SMO_DEFINES_H
+
+/* Global */
+#define SMO_FALL_DAMAGE_HEIGHT					1600.f
+#define MARIO_BREATH_MAX_DURATION               1800        // 60 seconds, 20 seconds in cold water, 15 seconds in poison gas
+#define MARIO_ABOUT_TO_DROWN                    1350        // 45 seconds, 15 seconds in cold water, ~11 seconds in poison gas
+
+/* Models */
+#define MODEL_SHOCK_WAVE                        0xFC        // invisible_bowser_accessory_geo
+#define MODEL_DBG_CYLINDER_HITBOX               0xFD        // dbg_cylinder_hitbox_geo
+#define MODEL_DBG_CYLINDER_HURTBOX              0xFE        // dbg_cylinder_hurtbox_geo
+
+/* Dialogs */
+enum DialogSmoId {
+    DIALOG_SMO_START_INDEX =                    200,
+    DIALOG_SMO_KING_BOBOMB =                    200,
+    DIALOG_SMO_KING_WHOMP =                     201,
+};
+
+/* Stationary actions */
+#define ACT_SMO_SHOCKED_FROM_HIGH_FALL          (0x037 | ACT_FLAG_STATIONARY | ACT_FLAG_INVULNERABLE)
+
+/* Moving actions */
+#define ACT_SMO_ROLLING							(0x07B | ACT_FLAG_MOVING)
+#define ACT_SMO_CAPPY_THROW_GROUND				(0x07C | ACT_FLAG_MOVING)
+
+/* Airborne actions */
+#define ACT_SMO_CAPPY_JUMP						(0x081 | ACT_FLAG_AIR | ACT_FLAG_ALLOW_VERTICAL_WIND_ACTION)
+#define ACT_SMO_GROUND_POUND_JUMP				(0x084 | ACT_FLAG_AIR | ACT_FLAG_ALLOW_VERTICAL_WIND_ACTION)
+#define ACT_SMO_LEAVE_OBJECT_JUMP				(0x0B9 | ACT_FLAG_AIR | ACT_FLAG_ALLOW_VERTICAL_WIND_ACTION)
+#define ACT_SMO_WALL_SLIDE						(0x0BA | ACT_FLAG_AIR)
+#define ACT_SMO_CAPPY_THROW_AIRBORNE			(0x0BB | ACT_FLAG_AIR)
+
+/* Water actions */
+#define ACT_SMO_WATER_DESCENT					(0x0E4 | ACT_FLAG_SWIMMING)
+#define ACT_SMO_WATER_DASH						(0x0E5 | ACT_FLAG_SWIMMING)
+#define ACT_SMO_CAPPY_THROW_WATER				(0x0E6 | ACT_FLAG_SWIMMING)
+#define ACT_SMO_LEAVE_OBJECT_WATER				(0x0E7 | ACT_FLAG_STATIONARY | ACT_FLAG_SWIMMING | ACT_FLAG_SWIMMING_OR_FLYING | ACT_FLAG_WATER_OR_TEXT)
+#define ACT_SMO_METAL_WATER_PUNCH				(0x0FC | ACT_FLAG_MOVING | ACT_FLAG_METAL_WATER)
+#define ACT_SMO_METAL_WATER_KICK				(0x0FD | ACT_FLAG_MOVING | ACT_FLAG_METAL_WATER)
+#define ACT_SMO_CAPPY_THROW_METAL_WATER_FLOOR	(0x0FE | ACT_FLAG_METAL_WATER)
+#define ACT_SMO_CAPPY_THROW_METAL_WATER_AIR		(0x0FF | ACT_FLAG_METAL_WATER)
+
+/* Cutscene actions */
+#define ACT_SMO_POSSESSION                      (0x13F | ACT_FLAG_STATIONARY | ACT_FLAG_INVULNERABLE)
+
+/* Sounds */
+#define SMO_SOUND_BANK                          0x0A
+#define SMO_SOUND_COUNT                         0x05
+#define SOUND_ACTION_CAPPY_1					SOUND_ARG_LOAD(SMO_SOUND_BANK, 4, 0x00, 0xF0, 8)
+#define SOUND_ACTION_CAPPY_2					SOUND_ARG_LOAD(SMO_SOUND_BANK, 4, 0x01, 0xF0, 8)
+#define SOUND_ACTION_SMO_LIFE_UP				SOUND_ARG_LOAD(SMO_SOUND_BANK, 4, 0x02, 0xFE, 8)
+#define SOUND_ACTION_SMO_LIFE_UP_END			SOUND_ARG_LOAD(SMO_SOUND_BANK, 4, 0x04, 0xFF, 8)
+#define SOUND_ACTION_SMO_DAMAGE					SOUND_ARG_LOAD(SMO_SOUND_BANK, 4, 0x03, 0xF8, 8)
+#define SOUND_ACTION_SMO_HEAL					SOUND_ARG_LOAD(SMO_SOUND_BANK, 4, 0x04, 0xF8, 8)
+
+/* Renamed Object fields */
+#define oWall                                   OBJECT_FIELD_SURFACE(0x19)
+#define oScaleX                                 header.gfx.scale[0]
+#define oScaleY                                 header.gfx.scale[1]
+#define oScaleZ                                 header.gfx.scale[2]
+
+/* SMO fields */
+#define SMO_FIELD_AS_S8(index, subindex)        smoData->fields.asS8[index][subindex]
+#define SMO_FIELD_AS_S16(index, subindex)       smoData->fields.asS16[index][subindex]
+#define SMO_FIELD_AS_S32(index)                 smoData->fields.asS32[index]
+#define SMO_FIELD_AS_F32(index)                 smoData->fields.asF32[index]
+#define SMO_REF_AS_OBJ(index)                   smoData->refs.asObject[index]
+#define SMO_REF_AS_PTR(index)                   smoData->refs.asVoidPtr[index]
+#define oMario                                  smoData->mario
+#define oMarioObj                               smoData->mario->marioObj
+
+/* Mario fields */
+#define oWallSlide								marioObj->SMO_FIELD_AS_S8(0x00, 0)
+#define oCappyJumped							marioObj->SMO_FIELD_AS_S8(0x00, 1)
+#define oPossessionLock                         marioObj->SMO_FIELD_AS_S8(0x00, 2)
+#define oCoinCounter							marioObj->SMO_FIELD_AS_S16(0x01, 0)
+#define oHpCounter							    marioObj->SMO_FIELD_AS_S16(0x01, 1)
+#define oO2										marioObj->SMO_FIELD_AS_S16(0x02, 0)
+#define oPossessionTimer                        marioObj->SMO_FIELD_AS_S16(0x02, 1)
+#define oPeakHeight								marioObj->SMO_FIELD_AS_F32(0x03)
+#define oCappyBehavior                          marioObj->SMO_FIELD_AS_S8(0x04, 0)
+#define oCappyInteractMario                     marioObj->SMO_FIELD_AS_S8(0x04, 1)
+#define oCappyActionFlag                        marioObj->SMO_FIELD_AS_S8(0x04, 2)
+#define oCappyInitialized                       marioObj->SMO_FIELD_AS_S8(0x04, 3)
+#define oInputStickX                            marioObj->SMO_FIELD_AS_F32(0x05) // [-1, +1], positive is right
+#define oInputStickY                            marioObj->SMO_FIELD_AS_F32(0x06) // [-1, +1], positive is up
+#define oInputStickMag                          marioObj->SMO_FIELD_AS_F32(0x07) // [0, 1]
+#define oInputStickYaw                          marioObj->SMO_FIELD_AS_S32(0x08) // intended yaw
+#define oInputButtonPressed                     marioObj->SMO_FIELD_AS_S16(0x09, 0)
+#define oInputButtonDown                        marioObj->SMO_FIELD_AS_S16(0x09, 1)
+#define oPossessAnimPos(i, j)					marioObj->SMO_FIELD_AS_F32(0x0A + (3 * i) + j)
+
+#define oCappyObject                            marioObj->SMO_REF_AS_OBJ(0x00)
+#define oCappyWallObject                        marioObj->SMO_REF_AS_OBJ(0x01)
+#define oCappyFloorObject                       marioObj->SMO_REF_AS_OBJ(0x02)
+#define oCappyCeilObject                        marioObj->SMO_REF_AS_OBJ(0x03)
+#define oPossessedObject                        marioObj->SMO_REF_AS_OBJ(0x04)
+#define oObjectCap                              marioObj->SMO_REF_AS_OBJ(0x05)
+
+/* Capture data fields (scaled) */
+#define cdWalkSpeed                             smoData->captureData->walkSpeed * pobj->oScaleX
+#define cdRunSpeed                              smoData->captureData->runSpeed * pobj->oScaleX
+#define cdDashSpeed                             smoData->captureData->dashSpeed * pobj->oScaleX
+#define cdJumpVelocity                          smoData->captureData->jumpVelocity * pobj->oScaleY
+#define cdTerminalVelocity                      smoData->captureData->terminalVelocity * pobj->oScaleY
+#define cdGravity                               smoData->captureData->gravity * pobj->oScaleY
+#define cdHitboxRadius                          smoData->captureData->hitboxRadius * pobj->oScaleX
+#define cdHitboxHeight                          smoData->captureData->hitboxHeight * pobj->oScaleY
+#define cdHitboxDownOffset                      smoData->captureData->hitboxDownOffset * pobj->oScaleY
+#define cdWallHitboxRadius                      smoData->captureData->wallHitboxRadius * pobj->oScaleX
+
+/* Possessed object properties */
+#define POBJ_PROP_ABOVE_WATER					(1 << 0)
+#define POBJ_PROP_UNDERWATER					(1 << 1)
+#define POBJ_PROP_INVULNERABLE					(1 << 2)
+#define POBJ_PROP_UNPUSHABLE					(1 << 3)
+#define POBJ_PROP_IMMUNE_TO_FIRE				(1 << 4)
+#define POBJ_PROP_IMMUNE_TO_LAVA				(1 << 5)
+#define POBJ_PROP_IMMUNE_TO_QUICKSANDS			(1 << 6)
+#define POBJ_PROP_RESIST_STRONG_WINDS			(1 << 7)
+#define POBJ_PROP_MOVE_THROUGH_VC_WALLS			(1 << 8)
+#define POBJ_PROP_WALK_ON_WATER			        (1 << 9)
+#define POBJ_PROP_ATTACK						(1 << 10)
+#define POBJ_PROP_STRONG_ATTACK					(1 << 11)
+
+/* Possessed object common fields */
+#define oProperties								SMO_FIELD_AS_S32(0x00)
+#define oUnresponsiveTimer                      SMO_FIELD_AS_S16(0x01, 0)
+#define oSquishedTimer                          SMO_FIELD_AS_S8(0x01, 2)
+#ifdef BETTERCAMERA
+#define oCameraBehindMario                      SMO_FIELD_AS_S8(0x01, 3)
+#endif
+#define oWalkDistance                           SMO_FIELD_AS_F32(0x02)
+#define oCappyForwardDist                       SMO_FIELD_AS_F32(0x03)
+#define oCappyLateralDist                       SMO_FIELD_AS_F32(0x04)
+#define oCappyVerticalDist                      SMO_FIELD_AS_F32(0x05)
+#define oCappyInitialPitch                      SMO_FIELD_AS_S16(0x06, 0)
+#define oCappyInitialYaw                        SMO_FIELD_AS_S16(0x06, 1)
+#define oCappyInitialRoll                       SMO_FIELD_AS_S16(0x07, 0)
+#define oCappyInitialScale                      SMO_FIELD_AS_S16(0x07, 1)
+#define COMMON_FIELD_END						0x08
+
+#define COMMON_REF_END                          0x00
+
+/* Inputs for possessed object */
+#define oStickX                                 oMario->oInputStickX // [-1, +1], positive is right
+#define oStickY                                 oMario->oInputStickY // [-1, +1], positive is up
+#define oStickMag                               oMario->oInputStickMag // [0, 1]
+#define oStickYaw                               oMario->oInputStickYaw // intended yaw
+#define oButtonPressed                          oMario->oInputButtonPressed
+#define oButtonDown                             oMario->oInputButtonDown
+
+/* Goomba */
+#define oCappyGoombaStackCount					SMO_FIELD_AS_S32(COMMON_FIELD_END + 0x00)
+#define oCappyGoombaStackCurOffset(i)			SMO_FIELD_AS_S16(COMMON_FIELD_END + 0x01 + i, 0)	// Offset from address of object's behavior (bhvGoomba)
+#define oCappyGoombaStackStkIndex(i)			SMO_FIELD_AS_S16(COMMON_FIELD_END + 0x01 + i, 1)	// Stack index before captured
+
+#define oCappyGoombaStackObject(i)				SMO_REF_AS_OBJ(COMMON_REF_END + 0x00 + i)
+
+/* Koopa */
+#define oCappyKoopaState						SMO_FIELD_AS_S32(COMMON_FIELD_END + 0x00)
+
+/* Bob-omb */
+#define oCappyBobombExplosionTimer				SMO_FIELD_AS_S32(COMMON_FIELD_END + 0x00)
+#define oCappyBobombExplosionCount				SMO_FIELD_AS_S32(COMMON_FIELD_END + 0x01)
+
+/* Bob-omb buddy */
+#define oCappyBobombBuddyState					SMO_FIELD_AS_S32(COMMON_FIELD_END + 0x00)
+#define oCappyBobombBuddyTimer					SMO_FIELD_AS_S32(COMMON_FIELD_END + 0x01)
+
+/* Bob-omb king */
+#define oCappyBobombKingState					SMO_FIELD_AS_S32(COMMON_FIELD_END + 0x00)
+#define oCappyBobombKingTimer					SMO_FIELD_AS_S32(COMMON_FIELD_END + 0x01)
+
+/* Chain chomp */
+#define oCappyChainChompIsFreed					SMO_FIELD_AS_S8(COMMON_FIELD_END + 0x00, 0)
+#define oCappyChainChompIsBiting				SMO_FIELD_AS_S8(COMMON_FIELD_END + 0x00, 1)
+#define oCappyChainChompPivotX					SMO_FIELD_AS_F32(COMMON_FIELD_END + 0x01)
+#define oCappyChainChompPivotZ					SMO_FIELD_AS_F32(COMMON_FIELD_END + 0x02)
+
+/* Bullet bill */
+#define oCappyBulletBillInitialHomeX            SMO_FIELD_AS_F32(COMMON_FIELD_END + 0x00)
+#define oCappyBulletBillInitialHomeY            SMO_FIELD_AS_F32(COMMON_FIELD_END + 0x01)
+#define oCappyBulletBillInitialHomeZ            SMO_FIELD_AS_F32(COMMON_FIELD_END + 0x02)
+#define oCappyBulletBillDestroyed               SMO_FIELD_AS_S8(COMMON_FIELD_END + 0x03, 0)
+
+/* Hoot */
+#define oCappyHootInitialHomeX                  SMO_FIELD_AS_F32(COMMON_FIELD_END + 0x00)
+#define oCappyHootInitialHomeY                  SMO_FIELD_AS_F32(COMMON_FIELD_END + 0x01)
+#define oCappyHootInitialHomeZ                  SMO_FIELD_AS_F32(COMMON_FIELD_END + 0x02)
+
+/* Whomp */
+#define oCappyWhompActionState                  SMO_FIELD_AS_S32(COMMON_FIELD_END + 0x00)
+#define oCappyWhompActionTimer                  SMO_FIELD_AS_S32(COMMON_FIELD_END + 0x01)
+
+/* Whomp king */
+#define oCappyWhompKingState                    SMO_FIELD_AS_S32(COMMON_FIELD_END + 0x00)
+#define oCappyWhompKingTimer                    SMO_FIELD_AS_S32(COMMON_FIELD_END + 0x01)
+
+/* Freed Chain chomp (regular object fields) */
+#define oChainChompFreedState					OBJECT_FIELD_S32(0x1F)
+#define oChainChompFreedTimer					OBJECT_FIELD_S32(0x20)
+#define oChainChompFreedAngle					OBJECT_FIELD_S32(0x21)
+
+#endif // SMO_DEFINES_H
diff --git a/data/smo/smo_includes.h b/data/smo/smo_includes.h
new file mode 100644
index 0000000..5a95031
--- /dev/null
+++ b/data/smo/smo_includes.h
@@ -0,0 +1,17 @@
+#ifndef SMO_INCLUDES_H
+#define SMO_INCLUDES_H
+
+#include "smo_defines.h"
+#include "smo_sgi.h"
+#include "debug/smo_debug.h"
+#include "system/smo_health.h"
+#include "system/smo_sound.h"
+#include "system/smo_options.h"
+#include "system/smo_hud.h"
+#include "object/smo_object.h"
+#include "object/smo_helpers.h"
+#include "mario/smo_mario.h"
+#include "cappy/smo_mario_cappy.h"
+#include "capture/capture_all.h"
+
+#endif // SMO_INCLUDES_H
diff --git a/data/smo/smo_sgi.h b/data/smo/smo_sgi.h
new file mode 100644
index 0000000..4ae4a6d
--- /dev/null
+++ b/data/smo/smo_sgi.h
@@ -0,0 +1,12 @@
+#ifndef SMO_SGI_H
+#define SMO_SGI_H
+
+// Check if SGI is installed, based on macros defined in SGI files
+// May be modified in the future
+#include "model_ids.h"
+#if defined(MODEL_PLAYER) && defined(MODEL_LUIGIS_CAP) && defined(MODEL_LUIGIS_METAL_CAP) && defined(MODEL_LUIGIS_WING_CAP) && defined(MODEL_LUIGIS_WINGED_METAL_CAP)
+#define SMO_SGI
+#define LUIGIS_CAPPY_SCALE_MULTIPLIER 1.25f /* Luigi's cap is slightly smaller than Mario's */
+#endif
+
+#endif // SMO_SGI_H
\ No newline at end of file
diff --git a/data/smo/system/smo_health.c b/data/smo/system/smo_health.c
new file mode 100644
index 0000000..e276926
--- /dev/null
+++ b/data/smo/system/smo_health.c
@@ -0,0 +1,261 @@
+#include "../smo_c_includes.h"
+
+//
+// Health conversion
+//
+
+#define SMO_HEALTH_MAX              0x87F
+#define SMO_HEALTH_DEAD             0xFF
+#define SMO_NUM_SEGMENTS            6
+#define SMO_NUM_SEGMENTS_HALF       (SMO_NUM_SEGMENTS / 2)
+#define SMO_NUM_TICKS_PER_SEGMENT   0x10
+#define SMO_HEALTH_PER_SEGMENT      ((SMO_HEALTH_MAX - SMO_HEALTH_DEAD) / SMO_NUM_SEGMENTS)
+#define SMO_HEALTH_PER_TICK         (SMO_HEALTH_PER_SEGMENT / SMO_NUM_TICKS_PER_SEGMENT)
+#define SMO_NUM_COINS_PER_HEAL      10
+
+static s32 smo_fix_health(s32 health) {
+    return MAX(SMO_HEALTH_DEAD, MIN(SMO_HEALTH_MAX, (((health - SMO_HEALTH_DEAD + SMO_HEALTH_PER_SEGMENT / 2) / SMO_HEALTH_PER_SEGMENT) * SMO_HEALTH_PER_SEGMENT) + SMO_HEALTH_DEAD));
+}
+
+static s32 smo_hp_to_health(s32 hp) {
+    return (hp * SMO_HEALTH_PER_TICK) + SMO_HEALTH_DEAD;
+}
+
+static s32 smo_health_to_hp(s32 health) {
+    return (health - SMO_HEALTH_DEAD + SMO_HEALTH_PER_TICK / 2) / SMO_HEALTH_PER_TICK;
+}
+
+static s32 smo_get_max_health(s32 health) {
+    if (SMO_HEALTH == 2 || (health - SMO_HEALTH_DEAD > SMO_HEALTH_PER_SEGMENT * SMO_NUM_SEGMENTS_HALF)) {
+        return (SMO_HEALTH_PER_SEGMENT * SMO_NUM_SEGMENTS) + SMO_HEALTH_DEAD;
+    }
+    return (SMO_HEALTH_PER_SEGMENT * SMO_NUM_SEGMENTS_HALF) + SMO_HEALTH_DEAD;
+}
+
+s32 smo_get_max_hp(s32 hp) {
+    return smo_health_to_hp(smo_get_max_health(smo_hp_to_health(hp)));
+}
+
+s32 smo_get_num_segments_per_health_gauge() {
+    if (SMO_HEALTH == 2) {
+        return SMO_NUM_SEGMENTS;
+    }
+    return SMO_NUM_SEGMENTS_HALF;
+}
+
+s32 smo_get_hp_per_segment() {
+    return SMO_NUM_TICKS_PER_SEGMENT;
+}
+
+s32 smo_is_mario_losing_hp(struct MarioState *m) {
+    return m->oHpCounter > smo_health_to_hp(m->health);
+}
+
+//
+// O2 level
+//
+
+static void increase_O2_level(struct MarioState *m, s32 amount) {
+    if (m->oO2 != 0) {
+        play_sound(SOUND_MENU_POWER_METER, m->marioObj->header.gfx.cameraToObject);
+    }
+    m->oO2 = MAX(0, m->oO2 - amount);
+}
+
+static void decrease_O2_level(struct MarioState *m, s32 amount) {
+    m->oO2 += amount;
+}
+
+static void update_O2_level(struct MarioState *m) {
+
+    // Mario is healed -> gives 0.5 extra second of O2 per heal tick
+    if (m->healCounter > 0) {
+        increase_O2_level(m, 15);
+        m->healCounter--;
+    }
+
+    // "Metal Mario doesn't even have to breathe"
+    if (!(m->flags & MARIO_METAL_CAP) && !(m->action & ACT_FLAG_INTANGIBLE)) {
+        
+        // Poison gas
+        if (m->input & INPUT_IN_POISON_GAS) {
+            decrease_O2_level(m, 4);
+        }
+    
+        // Water
+        else if ((m->action & ACT_GROUP_MASK) == ACT_GROUP_SUBMERGED) {
+
+            // Above water
+            if (m->pos[1] >= (m->waterLevel - 140)) {
+                increase_O2_level(m, 0xFFFF);
+            }
+
+            // Under water
+            else {
+                s32 dec = (((m->area->terrainType & TERRAIN_MASK) == TERRAIN_SNOW) ? 3 : 1);
+
+                // Drains more O2 if Mario is plunging or dashing
+                if (m->action == ACT_SMO_WATER_DESCENT) {
+                    decrease_O2_level(m, 3 * dec);
+                } else if (m->action == ACT_SMO_WATER_DASH) {
+                    decrease_O2_level(m, 6 * dec);
+                } else {
+                    decrease_O2_level(m, dec);
+                }
+            }
+        }
+
+        // Fresh air
+        else {
+            increase_O2_level(m, 0xFFFF);
+        }
+
+        // Play a sound effect when low on O2
+        if (m->oO2 >= MARIO_ABOUT_TO_DROWN) {
+            play_sound(SOUND_MOVING_ALMOST_DROWNING, gDefaultSoundArgs);
+        }
+
+        // Drown Mario when out of O2
+        if (m->oO2 >= MARIO_BREATH_MAX_DURATION) {
+            m->health = 0xFF;
+            m->healCounter = 0;
+            m->hurtCounter = 0;
+        }
+    }
+}
+
+//
+// SMO Life-up cutscene object
+//
+
+#define LIFE_UP_CUTSCENE_MAX_DURATION   60
+#define LIFE_UP_CUTSCENE_HEAL_DURATION  45
+
+static void update_life_up_cutscene() {
+    struct Object *o = gCurrentObject;
+    if (o->oTimer >= LIFE_UP_CUTSCENE_MAX_DURATION) {
+        o->oMario->action &= ~ACT_FLAG_INTANGIBLE;
+        o->activeFlags &= ~ACTIVE_FLAG_INITIATED_TIME_STOP;
+        clear_time_stop_flags(TIME_STOP_ENABLED | TIME_STOP_MARIO_AND_DOORS);
+        smo_unsoften_music(NULL);
+        smo_play_sound_effect(SOUND_ACTION_SMO_LIFE_UP_END, NULL);
+        smo_obj_free_data(o);
+        obj_mark_for_deletion(o);
+    } else {
+        smo_update_mario_health(o->oMario);
+    }
+}
+
+static const BehaviorScript bhvLifeUpCutscene[] = {
+    0x08000000,
+    0x0C000000, (uintptr_t)(update_life_up_cutscene),
+    0x09000000
+};
+
+f32 smo_get_life_up_gauge_position(s32 hp) {
+    struct Object *obj = obj_get_first_with_behavior(NULL, bhvLifeUpCutscene);
+    if (obj == NULL) {
+        return (hp <= smo_get_max_hp(0) ? 1.f : 0.f);
+    }
+
+    f32 remainingTime = LIFE_UP_CUTSCENE_MAX_DURATION - MAX(LIFE_UP_CUTSCENE_HEAL_DURATION, obj->oTimer);
+    f32 endCutsceneTime = (LIFE_UP_CUTSCENE_MAX_DURATION - LIFE_UP_CUTSCENE_HEAL_DURATION);
+    return sqrtf(remainingTime / endCutsceneTime);
+}
+
+//
+// SMO health system
+//
+
+static u32 sSmoHealthPreviousState = 0;
+s32 smo_update_mario_health(struct MarioState *m) {
+    if (SMO_HEALTH == 0) {
+        sSmoHealthPreviousState = 0;
+        return FALSE;
+    }
+
+    // Health system was changed
+    // Set m->health, init m->oHpCounter and m->oCoinCounter
+    if (SMO_HEALTH != sSmoHealthPreviousState) {
+        m->health = MIN(m->health, smo_get_max_health(0));
+        m->oHpCounter = smo_health_to_hp(m->health);
+        m->oCoinCounter = m->numCoins;
+        sSmoHealthPreviousState = SMO_HEALTH;
+    }
+
+    // Entered a new area
+    if (m->oHpCounter == 0) {
+        m->oHpCounter = smo_health_to_hp(m->health);
+        m->oCoinCounter = m->numCoins;
+    }
+
+    // Update O2
+    update_O2_level(m);
+
+    // Mario takes damage
+    if (m->hurtCounter != 0) {
+        m->health -= SMO_HEALTH_PER_SEGMENT;
+        m->hurtCounter = 0;
+        smo_play_sound_effect(SOUND_ACTION_SMO_DAMAGE, NULL);
+    }
+
+    // Update coin counter and heal Mario every N coins
+    if (m->oCoinCounter < m->numCoins) {
+        m->oCoinCounter++;
+        if ((m->oCoinCounter % SMO_NUM_COINS_PER_HEAL) == 0) {
+            smo_heal_mario_for_1_health(m);
+        }
+    } else {
+        m->oCoinCounter = m->numCoins;
+    }
+
+    // Update health counter
+    m->health = smo_fix_health(m->health);
+    s32 counter = smo_health_to_hp(m->health);
+    if (m->oHpCounter < counter) {
+        m->oHpCounter++;
+        if ((m->oHpCounter % SMO_NUM_TICKS_PER_SEGMENT) == (SMO_NUM_TICKS_PER_SEGMENT / 2)) {
+            smo_play_sound_effect(SOUND_ACTION_SMO_HEAL, NULL);
+        }
+    } else if (m->oHpCounter > counter) {
+        m->oHpCounter--;
+    }
+
+    // Updated
+    gHudDisplay.wedges = 0xFF;
+    return TRUE;
+}
+
+void smo_heal_mario_for_1_health(struct MarioState *m) {
+    m->health = MIN(m->health + SMO_HEALTH_PER_SEGMENT, smo_get_max_health(m->health));
+}
+
+void smo_set_mario_to_full_health(struct MarioState *m) {
+    m->oHpCounter = MAX(m->oHpCounter, 1);
+    m->health = smo_get_max_health(m->health);
+}
+
+void smo_set_hp_counter_to_mario_health(struct MarioState *m) {
+    m->oHpCounter = smo_health_to_hp(m->health);
+}
+
+void smo_life_up_mario(struct MarioState *m) {
+    if (SMO_HEALTH == 1 && (m->health <= smo_get_max_health(0))) {
+        m->hurtCounter = 0;
+        m->oHpCounter = smo_health_to_hp(smo_get_max_health(0));
+        struct Object *o = spawn_object(m->marioObj, MODEL_NONE, bhvLifeUpCutscene);
+        if (o != NULL) {
+            smo_soften_music(NULL);
+            smo_play_sound_effect(SOUND_ACTION_SMO_LIFE_UP, NULL);
+            set_time_stop_flags(TIME_STOP_ENABLED | TIME_STOP_MARIO_AND_DOORS);
+            smo_obj_alloc_data(o, m);
+            o->activeFlags |= ACTIVE_FLAG_INITIATED_TIME_STOP;
+            m->action |= ACT_FLAG_INTANGIBLE;
+        }
+    }
+    m->health = SMO_HEALTH_MAX;
+}
+
+void smo_health_reset() {
+    sSmoHealthPreviousState = 0;
+}
\ No newline at end of file
diff --git a/data/smo/system/smo_health.h b/data/smo/system/smo_health.h
new file mode 100644
index 0000000..ae72690
--- /dev/null
+++ b/data/smo/system/smo_health.h
@@ -0,0 +1,19 @@
+#ifndef SMO_HEALTH_H
+#define SMO_HEALTH_H
+
+#include "types.h"
+
+s32 smo_get_max_hp(s32 hp);
+s32 smo_get_num_segments_per_health_gauge();
+s32 smo_get_hp_per_segment();
+f32 smo_get_life_up_gauge_position(s32 hp);
+s32 smo_is_mario_losing_hp(struct MarioState *m);
+
+s32 smo_update_mario_health(struct MarioState *m);
+void smo_heal_mario_for_1_health(struct MarioState *m);
+void smo_set_mario_to_full_health(struct MarioState *m);
+void smo_set_hp_counter_to_mario_health(struct MarioState *m);
+void smo_life_up_mario(struct MarioState *m);
+void smo_health_reset();
+
+#endif // SMO_HEALTH_H
diff --git a/data/smo/system/smo_hud.c b/data/smo/system/smo_hud.c
new file mode 100644
index 0000000..813673b
--- /dev/null
+++ b/data/smo/system/smo_hud.c
@@ -0,0 +1,340 @@
+#include "../smo_c_includes.h"
+
+//
+// Power Meter data
+//
+
+static Vtx sPowerMeterSmoVertexArray[0x1000];
+
+static u8 sPowerMeterSmoColorsRGB[][2][3] = {
+          /* Center */          /* Border */
+    { { 0xFF, 0xFF, 0xFF }, { 0xFF, 0xFF, 0xFF } }, // Empty segment
+    { { 0xFF, 0x00, 0x00 }, { 0xD0, 0x00, 0x00 } }, // Critical life
+    { { 0xFF, 0xC8, 0x00 }, { 0xD0, 0xA0, 0x00 } }, // Low life
+    { { 0x00, 0xE0, 0x00 }, { 0x00, 0xB8, 0x00 } }, // Normal
+    { { 0x00, 0xC8, 0xFF }, { 0x00, 0xA0, 0xD0 } }, // Life up
+    { { 0xFF, 0xFF, 0xFF }, { 0xD0, 0xD0, 0xD0 } }, // Heart (white)
+    { { 0xFF, 0xB8, 0xB8 }, { 0xD0, 0x90, 0x90 } }, // Heart (pale red)
+    { { 0xFF, 0x40, 0x40 }, { 0xD0, 0x30, 0x30 } }, // Heart (red)
+    { { 0x30, 0x30, 0x30 }, { 0x30, 0x30, 0x30 } }, // Background
+};
+
+static s32 sPowerMeterHeartPulse[30] = {
+    5, 6, 7, 7, 7, 6, 5, 5, 5, 5,
+    5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
+    5, 5, 5, 5, 5, 5, 5, 5, 5, 5
+};
+
+#define BACKGROUND_NUM_TRIANGLES    64
+#define NUM_SUB_SEGMENTS            32
+#define HEART_NUM_PIECES            64
+#define SUB_SEG_D0                  16.0f
+#define SUB_SEG_D1                  18.0f
+#define SUB_SEG_D2                  20.0f
+#define SUB_SEG_D3                  22.0f
+#define HEART_D1_X                  20.0f
+#define HEART_D1_Y                  18.0f
+#define HEART_D2_X                  22.0f
+#define HEART_D2_Y                  20.0f
+#define BACKGROUND_R                sPowerMeterSmoColorsRGB[8][0][0]
+#define BACKGROUND_G                sPowerMeterSmoColorsRGB[8][0][1]
+#define BACKGROUND_B                sPowerMeterSmoColorsRGB[8][0][2]
+#define SUB_SEG_CENTER_R            sPowerMeterSmoColorsRGB[rgbIdx][0][0]
+#define SUB_SEG_CENTER_G            sPowerMeterSmoColorsRGB[rgbIdx][0][1]
+#define SUB_SEG_CENTER_B            sPowerMeterSmoColorsRGB[rgbIdx][0][2]
+#define SUB_SEG_BORDER_R            sPowerMeterSmoColorsRGB[rgbIdx][1][0]
+#define SUB_SEG_BORDER_G            sPowerMeterSmoColorsRGB[rgbIdx][1][1]
+#define SUB_SEG_BORDER_B            sPowerMeterSmoColorsRGB[rgbIdx][1][2]
+#define HEART_CENTER_R              sPowerMeterSmoColorsRGB[hIdx][0][0]
+#define HEART_CENTER_G              sPowerMeterSmoColorsRGB[hIdx][0][1]
+#define HEART_CENTER_B              sPowerMeterSmoColorsRGB[hIdx][0][2]
+#define HEART_BORDER_R              sPowerMeterSmoColorsRGB[hIdx][1][0]
+#define HEART_BORDER_G              sPowerMeterSmoColorsRGB[hIdx][1][1]
+#define HEART_BORDER_B              sPowerMeterSmoColorsRGB[hIdx][1][2]
+
+#define NUM_FULL_SEGMENTS           smo_get_num_segments_per_health_gauge()
+#define HP_PER_SEGMENT              smo_get_hp_per_segment()
+#define HP_MAX_NO_LIFEUP            smo_get_max_hp(0)
+#define HP_CRITICAL                 ((HP_PER_SEGMENT * 3) / 2)
+#define HP_LOW                      ((HP_PER_SEGMENT * 5) / 2)
+#define HP_DISPLAY_VALUE            ((hp + HP_PER_SEGMENT / 2) / HP_PER_SEGMENT)
+
+//
+// Background
+//
+
+static Vtx *smo_power_meter_render_background_triangle(Vtx *vtx, f32 x, f32 y, f32 a0, f32 a1, f32 d) {
+    Vtx v0 = { { { x,                y,                0 }, 0, { 0, 0 }, { BACKGROUND_R, BACKGROUND_G, BACKGROUND_B, 0xFF } } };
+    Vtx v1 = { { { x + sins(a0) * d, y + coss(a0) * d, 0 }, 0, { 0, 0 }, { BACKGROUND_R, BACKGROUND_G, BACKGROUND_B, 0xFF } } };
+    Vtx v2 = { { { x + sins(a1) * d, y + coss(a1) * d, 0 }, 0, { 0, 0 }, { BACKGROUND_R, BACKGROUND_G, BACKGROUND_B, 0xFF } } };
+    vtx[0] = v0;
+    vtx[1] = v1;
+    vtx[2] = v2;
+    gSPVertex(gDisplayListHead++, vtx, 3, 0);
+    gSP1Triangle(gDisplayListHead++, 0, 2, 1, 0x0);
+    return &vtx[3];
+}
+
+
+static Vtx *smo_power_meter_render_background(Vtx *vtx, f32 x, f32 y) {
+    for (s32 i = 0; i != BACKGROUND_NUM_TRIANGLES; ++i) {
+        f32 a0 = ((i + 0) * 65536.f) / BACKGROUND_NUM_TRIANGLES;
+        f32 a1 = ((i + 1) * 65536.f) / BACKGROUND_NUM_TRIANGLES;
+        vtx = smo_power_meter_render_background_triangle(vtx, x, y, a0, a1, SUB_SEG_D3 + 0.5f);
+    }
+    return vtx;
+}
+
+//
+// Health segments
+//
+
+static Vtx *smo_power_meter_render_sub_segment(Vtx *vtx, f32 x, f32 y, f32 a0, f32 a1, s32 rgbIdx) {
+    Vtx v0 = { { { x + sins(a0) * SUB_SEG_D0, y + coss(a0) * SUB_SEG_D0, 0 }, 0, { 0, 0 }, { SUB_SEG_BORDER_R, SUB_SEG_BORDER_G, SUB_SEG_BORDER_B, 0xFF } } };
+    Vtx v1 = { { { x + sins(a0) * SUB_SEG_D1, y + coss(a0) * SUB_SEG_D1, 0 }, 0, { 0, 0 }, { SUB_SEG_CENTER_R, SUB_SEG_CENTER_G, SUB_SEG_CENTER_B, 0xFF } } };
+    Vtx v2 = { { { x + sins(a0) * SUB_SEG_D2, y + coss(a0) * SUB_SEG_D2, 0 }, 0, { 0, 0 }, { SUB_SEG_CENTER_R, SUB_SEG_CENTER_G, SUB_SEG_CENTER_B, 0xFF } } };
+    Vtx v3 = { { { x + sins(a0) * SUB_SEG_D3, y + coss(a0) * SUB_SEG_D3, 0 }, 0, { 0, 0 }, { SUB_SEG_BORDER_R, SUB_SEG_BORDER_G, SUB_SEG_BORDER_B, 0xFF } } };
+    Vtx v4 = { { { x + sins(a1) * SUB_SEG_D0, y + coss(a1) * SUB_SEG_D0, 0 }, 0, { 0, 0 }, { SUB_SEG_BORDER_R, SUB_SEG_BORDER_G, SUB_SEG_BORDER_B, 0xFF } } };
+    Vtx v5 = { { { x + sins(a1) * SUB_SEG_D1, y + coss(a1) * SUB_SEG_D1, 0 }, 0, { 0, 0 }, { SUB_SEG_CENTER_R, SUB_SEG_CENTER_G, SUB_SEG_CENTER_B, 0xFF } } };
+    Vtx v6 = { { { x + sins(a1) * SUB_SEG_D2, y + coss(a1) * SUB_SEG_D2, 0 }, 0, { 0, 0 }, { SUB_SEG_CENTER_R, SUB_SEG_CENTER_G, SUB_SEG_CENTER_B, 0xFF } } };
+    Vtx v7 = { { { x + sins(a1) * SUB_SEG_D3, y + coss(a1) * SUB_SEG_D3, 0 }, 0, { 0, 0 }, { SUB_SEG_BORDER_R, SUB_SEG_BORDER_G, SUB_SEG_BORDER_B, 0xFF } } };
+    vtx[0] = v0;
+    vtx[1] = v1;
+    vtx[2] = v2;
+    vtx[3] = v3;
+    vtx[4] = v4;
+    vtx[5] = v5;
+    vtx[6] = v6;
+    vtx[7] = v7;
+    gSPVertex(gDisplayListHead++, vtx, 8, 0);
+    gSP2Triangles(gDisplayListHead++, 2, 6, 3, 0x0, 3, 6, 7, 0x0);
+    gSP2Triangles(gDisplayListHead++, 1, 5, 2, 0x0, 2, 5, 6, 0x0);
+    gSP2Triangles(gDisplayListHead++, 0, 4, 1, 0x0, 1, 4, 5, 0x0);
+    return &vtx[8];
+}
+
+static Vtx *smo_power_meter_render_segment(Vtx *vtx, f32 x, f32 y, s32 hp, s32 segment, s32 isLifeUp) {
+    f32 aMax = (hp * 65536.f) / (NUM_FULL_SEGMENTS * HP_PER_SEGMENT);
+    f32 da = 65536.f / (NUM_SUB_SEGMENTS * NUM_FULL_SEGMENTS);
+    for (s32 i = 0; i != NUM_SUB_SEGMENTS; ++i) {
+        f32 a0 = da * (segment * NUM_SUB_SEGMENTS + i + 0);
+        f32 a1 = da * (segment * NUM_SUB_SEGMENTS + i + 1);
+        s32 rgbIdx = 0;
+        if ((a0 + a1) / 2 <= aMax) {
+            if (isLifeUp) {
+                rgbIdx = 4;
+            } else if (hp > HP_LOW) {
+                rgbIdx = 3;
+            } else if (hp > HP_CRITICAL) {
+                rgbIdx = 2;
+            } else {
+                rgbIdx = 1;
+            }
+        }
+        vtx = smo_power_meter_render_sub_segment(vtx, x, y, a0, a1, rgbIdx);
+    }
+    return vtx;
+}
+
+static Vtx *smo_power_meter_render_segments(Vtx *vtx, f32 x, f32 y, s32 hp, s32 isLifeUp) {
+    for (s32 segment = 0; segment != NUM_FULL_SEGMENTS; ++segment) {
+        f32 sa = (segment * 65536 + 32768) / NUM_FULL_SEGMENTS;
+        f32 dx = sins(sa);
+        f32 dy = coss(sa);
+        vtx = smo_power_meter_render_segment(vtx, x + dx, y + dy, hp, segment, isLifeUp);
+    }
+    return vtx;
+}
+
+//
+// Heart
+//
+
+static Vtx *smo_power_meter_render_heart_piece(Vtx *vtx, f32 x, f32 y, f32 t0, f32 t1, s32 hIdx) {
+
+    // Heart shape <3
+    f32 a0 = t0 * 65536.f / (2.f * 3.14159265359f);
+    f32 a1 = t1 * 65536.f / (2.f * 3.14159265359f);
+    f32 r0 = (1.f - absx(t0)) * (1.f + 3.f * absx(t0));
+    f32 r1 = (1.f - absx(t1)) * (1.f + 3.f * absx(t1));
+    f32 dx0 = r0 * sins(a0);
+    f32 dy0 = r0 * coss(a0) - 0.65f;
+    f32 dx1 = r1 * sins(a1);
+    f32 dy1 = r1 * coss(a1) - 0.65f;
+
+    Vtx v0 = { { { x,                    y,                    0 }, 0, { 0, 0 }, { HEART_CENTER_R, HEART_CENTER_G, HEART_CENTER_B, 0xFF } } };
+    Vtx v1 = { { { x + dx0 * HEART_D1_X, y + dy0 * HEART_D1_Y, 0 }, 0, { 0, 0 }, { HEART_CENTER_R, HEART_CENTER_G, HEART_CENTER_B, 0xFF } } };
+    Vtx v2 = { { { x + dx0 * HEART_D2_X, y + dy0 * HEART_D2_Y, 0 }, 0, { 0, 0 }, { HEART_BORDER_R, HEART_BORDER_G, HEART_BORDER_B, 0xFF } } };
+    Vtx v3 = { { { x + dx1 * HEART_D1_X, y + dy1 * HEART_D1_Y, 0 }, 0, { 0, 0 }, { HEART_CENTER_R, HEART_CENTER_G, HEART_CENTER_B, 0xFF } } };
+    Vtx v4 = { { { x + dx1 * HEART_D2_X, y + dy1 * HEART_D2_Y, 0 }, 0, { 0, 0 }, { HEART_BORDER_R, HEART_BORDER_G, HEART_BORDER_B, 0xFF } } };
+    vtx[0] = v0;
+    vtx[1] = v1;
+    vtx[2] = v2;
+    vtx[3] = v3;
+    vtx[4] = v4;
+    gSPVertex(gDisplayListHead++, vtx, 5, 0);
+    gSP2Triangles(gDisplayListHead++, 2, 1, 4, 0x0, 1, 3, 4, 0x0);
+    gSP1Triangle(gDisplayListHead++, 1, 0, 3, 0x0);
+    return &vtx[5];
+}
+
+static Vtx *smo_power_meter_render_heart(Vtx *vtx, f32 x, f32 y, s32 hp) {
+    for (s32 i = 0; i != HEART_NUM_PIECES; ++i) {
+        f32 t0 = (i + 0 - 32) / (HEART_NUM_PIECES / 2.f);
+        f32 t1 = (i + 1 - 32) / (HEART_NUM_PIECES / 2.f);
+        s32 hIdx = sPowerMeterHeartPulse[hp <= HP_CRITICAL ? gGlobalTimer % 30 : 0];
+        vtx = smo_power_meter_render_heart_piece(vtx, x, y, t0, t1, hIdx);
+    }
+    return vtx;
+}
+
+//
+// Health gauge
+//
+
+static Vtx *smo_power_meter_render_health_gauge(Vtx *vtx, f32 x, f32 y, s32 hp, f32 luPos) {
+    hp = MIN(hp, HP_MAX_NO_LIFEUP);
+    vtx = smo_power_meter_render_segments(vtx, x, y, hp, FALSE);
+    vtx = smo_power_meter_render_heart(vtx, x, y - 1.5f, hp);
+    if (luPos > 0.1f) {
+        print_text(x - 8, y - 10, int_to_string(HP_DISPLAY_VALUE, "%d"));
+    }
+    return vtx;
+}
+
+static Vtx *smo_power_meter_render_health_gauge_life_up(Vtx *vtx, f32 x, f32 y, s32 hp, f32 luPos) {
+    if (hp > HP_MAX_NO_LIFEUP) {
+        x = x + luPos * ((SCREEN_WIDTH * 0.5f) - x);
+        y = y + luPos * ((SCREEN_HEIGHT * 0.65f) - y);
+        vtx = smo_power_meter_render_background(vtx, x, y);
+        vtx = smo_power_meter_render_segments(vtx, x, y, hp - HP_MAX_NO_LIFEUP, TRUE);
+        vtx = smo_power_meter_render_heart(vtx, x, y - 1.5f, hp);
+        print_text(x - 8, y - 10, int_to_string(HP_DISPLAY_VALUE, "%d"));
+    }
+    return vtx;
+}
+
+//
+// HUD
+//
+
+static void smo_render_power_meter(struct MarioState *m) {
+    if (gHudDisplay.flags & HUD_DISPLAY_FLAG_CAMERA_AND_POWER) {
+        f32 x = GFX_DIMENSIONS_RECT_FROM_RIGHT_EDGE(36);
+        f32 y = 204.f;
+        s32 hp = m->oHpCounter;
+        if (smo_is_mario_losing_hp(m)) {
+            x += (random_float() * 12.f) - 6.f;
+            y += (random_float() * 12.f) - 6.f;
+        }
+        f32 luPos = smo_get_life_up_gauge_position(hp);
+        gDPPipeSync(gDisplayListHead++);
+        gSPClearGeometryMode(gDisplayListHead++, G_LIGHTING);
+        gDPSetCombineMode(gDisplayListHead++, G_CC_SHADE, G_CC_SHADE);
+        Vtx *vtx = sPowerMeterSmoVertexArray;
+        vtx = smo_power_meter_render_health_gauge(vtx, x, y, hp, luPos);
+        vtx = smo_power_meter_render_health_gauge_life_up(vtx, x - 8, y, hp, luPos);
+        gDPPipeSync(gDisplayListHead++);
+        gSPSetGeometryMode(gDisplayListHead++, G_LIGHTING);
+    }
+}
+
+#ifdef SMO_SGI
+static void smo_render_hud_glyph(s32 x, s32 y, u8 *texture) {
+    gDPPipeSync(gDisplayListHead++);
+    gDPSetTextureImage(gDisplayListHead++, G_IM_FMT_RGBA, G_IM_SIZ_16b, 1, texture);
+    gSPDisplayList(gDisplayListHead++, &dl_hud_img_load_tex_block);
+    gSPTextureRectangle(gDisplayListHead++, x << 2, y << 2, (x + 15) << 2, (y + 15) << 2, G_TX_RENDERTILE, 0, 0, 4 << 10, 1 << 10);
+}
+#endif
+
+static u32 sO2DisplayTimer = 60;
+static void smo_render_values(struct MarioState *m) {
+    f32 y = 209;
+
+    // Star count
+    if (gHudDisplay.flags & HUD_DISPLAY_FLAG_STAR_COUNT) {
+        print_text(GFX_DIMENSIONS_RECT_FROM_LEFT_EDGE(22), y, "-"); // 'Star' glyph
+        print_text(GFX_DIMENSIONS_RECT_FROM_LEFT_EDGE(38), y, "*"); // 'X' glyph
+        print_text(GFX_DIMENSIONS_RECT_FROM_LEFT_EDGE(54), y, int_to_string(gHudDisplay.stars, "%d"));
+        y -= 20;
+    }
+
+    // Key count
+#ifdef SMO_SGI
+    if (gHudDisplay.flags & HUD_DISPLAY_FLAG_KEYS) {
+        if (m->numKeys > 0 && m->numKeys < 10) {
+            gSPDisplayList(gDisplayListHead++, dl_hud_img_begin);
+            smo_render_hud_glyph(GFX_DIMENSIONS_RECT_FROM_LEFT_EDGE(22), 224 - y, (u8 *) "textures/segment2/boo_key.rgba16");
+            gSPDisplayList(gDisplayListHead++, dl_hud_img_end);
+            print_text(GFX_DIMENSIONS_RECT_FROM_LEFT_EDGE(38), y, "*"); // 'X' glyph
+            print_text(GFX_DIMENSIONS_RECT_FROM_LEFT_EDGE(54), y, int_to_string(m->numKeys, "%d"));
+            y -= 20;
+        }
+    }
+#endif
+
+    // Coint count
+    if (gHudDisplay.flags & HUD_DISPLAY_FLAG_COIN_COUNT) {
+        print_text(GFX_DIMENSIONS_RECT_FROM_LEFT_EDGE(22), y, "+"); // 'Coin' glyph
+        print_text(GFX_DIMENSIONS_RECT_FROM_LEFT_EDGE(38), y, "*"); // 'X' glyph
+        print_text(GFX_DIMENSIONS_RECT_FROM_LEFT_EDGE(54), y, int_to_string(gHudDisplay.coins, "%d"));
+        y -= 20;
+    }
+
+    // O2 level
+    if (gHudDisplay.flags & HUD_DISPLAY_FLAG_STAR_COUNT) {
+        if (m->oO2 > 0) {
+            sO2DisplayTimer = 0;
+        }
+        if (sO2DisplayTimer++ < 60) {
+            print_text(GFX_DIMENSIONS_RECT_FROM_LEFT_EDGE(22), y - 6, "2");
+            print_text(GFX_DIMENSIONS_RECT_FROM_LEFT_EDGE(13), y, "O");
+            print_text(GFX_DIMENSIONS_RECT_FROM_LEFT_EDGE(38), y, "*"); // 'X' glyph
+            print_text(GFX_DIMENSIONS_RECT_FROM_LEFT_EDGE(54), y, int_to_string(MAX((((s32)(MARIO_BREATH_MAX_DURATION - m->oO2) * 100) / MARIO_BREATH_MAX_DURATION), 0), "%03d"));
+            y -= 20;
+        }
+    }
+}
+
+static const u8 sTextTime[] = { 29, 18, 22, 14, DIALOG_CHAR_TERMINATOR };
+static const u8 sTextApostrophe[] = { GLYPH_APOSTROPHE, DIALOG_CHAR_TERMINATOR };
+static const u8 sTextDoubleQuote[] = { GLYPH_DOUBLE_QUOTE, DIALOG_CHAR_TERMINATOR };
+static void smo_render_timer() {
+    if (gHudDisplay.flags & HUD_DISPLAY_FLAG_TIMER) {
+        gDPSetEnvColor(gDisplayListHead++, 255, 255, 255, 255);
+        gSPDisplayList(gDisplayListHead++, dl_rgba16_text_begin);
+        print_hud_lut_string(HUD_LUT_GLOBAL, GFX_DIMENSIONS_RECT_FROM_RIGHT_EDGE(294), 12, sTextTime);
+        print_hud_lut_string(HUD_LUT_GLOBAL, GFX_DIMENSIONS_RECT_FROM_RIGHT_EDGE(294 - 60), 12, int_to_sm64_string((gHudDisplay.timer / 1800) % 60, "%0d"));
+        print_hud_lut_string(HUD_LUT_GLOBAL, GFX_DIMENSIONS_RECT_FROM_RIGHT_EDGE(294 - 80), 12, int_to_sm64_string((gHudDisplay.timer / 30) % 60, "%02d"));
+        print_hud_lut_string(HUD_LUT_GLOBAL, GFX_DIMENSIONS_RECT_FROM_RIGHT_EDGE(294 - 114), 12, int_to_sm64_string(((gHudDisplay.timer * 10) / 3) % 100, "%02d"));
+        print_hud_lut_string(HUD_LUT_GLOBAL, GFX_DIMENSIONS_RECT_FROM_RIGHT_EDGE(294 - 70), 4, sTextApostrophe);
+        print_hud_lut_string(HUD_LUT_GLOBAL, GFX_DIMENSIONS_RECT_FROM_RIGHT_EDGE(294 - 105), 4, sTextDoubleQuote);
+        gSPDisplayList(gDisplayListHead++, dl_rgba16_text_end);
+        gDPSetEnvColor(gDisplayListHead++, 255, 255, 255, 255);
+    }
+}
+
+void smo_render_hud(struct MarioState *m) {
+    if (gHudDisplay.flags != HUD_DISPLAY_NONE && configHUD) {
+        create_dl_ortho_matrix();
+
+        // Cannon reticle
+        if (gCurrentArea != NULL && gCurrentArea->camera->mode == CAMERA_MODE_INSIDE_CANNON) {
+            render_hud_cannon_reticle();
+        }
+
+        // Values
+        smo_render_values(m);
+
+        // Power meter
+        smo_render_power_meter(m);
+
+        // KtQ Timer
+        smo_render_timer();
+    }
+}
+
+void smo_hud_reset() {
+    sO2DisplayTimer = 60;
+}
diff --git a/data/smo/system/smo_hud.h b/data/smo/system/smo_hud.h
new file mode 100644
index 0000000..bf64bc8
--- /dev/null
+++ b/data/smo/system/smo_hud.h
@@ -0,0 +1,9 @@
+#ifndef SMO_HUD_H
+#define SMO_HUD_H
+
+#include "types.h"
+
+void smo_render_hud(struct MarioState *m);
+void smo_hud_reset();
+
+#endif // SMO_HUD_H
diff --git a/data/smo/system/smo_options.cpp b/data/smo/system/smo_options.cpp
new file mode 100644
index 0000000..6734f66
--- /dev/null
+++ b/data/smo/system/smo_options.cpp
@@ -0,0 +1,28 @@
+#ifdef __cplusplus
+extern "C" {
+#endif
+#include "../smo_c_includes.h"
+#include "game/options_menu.h"
+#ifdef __cplusplus
+}
+#endif
+
+#ifdef DYNOS
+static void smo_return_to_main_menu(UNUSED struct Option *opt, s32 arg) {
+    if (!arg) {
+        optmenu_toggle();
+        unpause_game();
+        smo_hud_reset();
+        smo_health_reset();
+        smo_object_reset();
+        fade_into_special_warp(-2, 0);
+    }
+}
+
+DYNOS_DEFINE_ACTION(smo_return_to_main_menu);
+#else
+// Provides a default config if DynOS is not installed
+// [X] key and (X) button for the mask 0x0040
+u32 gSmoConfigKeyCappy[MAX_BINDS] = { 0x002D, 0x1002, VK_INVALID };
+#endif
+
diff --git a/data/smo/system/smo_options.h b/data/smo/system/smo_options.h
new file mode 100644
index 0000000..e739008
--- /dev/null
+++ b/data/smo/system/smo_options.h
@@ -0,0 +1,21 @@
+#ifndef SMO_OPTIONS_H
+#define SMO_OPTIONS_H
+
+#define SMO_CAPPY_BUTTON 0x0040
+
+#ifdef DYNOS
+#include "pc/dynamic_options.h"
+#define SMO_ID		"SuperMarioOdyssey"
+#define SMO_MARIO	dynos_get_value(SMO_ID, 0)
+#define SMO_CAPPY	dynos_get_value(SMO_ID, 1)
+#define SMO_HEALTH	dynos_get_value(SMO_ID, 3)
+#define SMO_UCJ		dynos_get_value(SMO_ID, 4)
+#else
+#define SMO_MARIO	1
+#define SMO_CAPPY	2
+#define SMO_HEALTH	1
+#define SMO_UCJ		0
+extern u32 gSmoConfigKeyCappy[];
+#endif
+
+#endif // SMO_OPTIONS_H
diff --git a/data/smo/system/smo_sound.c b/data/smo/system/smo_sound.c
new file mode 100644
index 0000000..e921e5c
--- /dev/null
+++ b/data/smo/system/smo_sound.c
@@ -0,0 +1,97 @@
+#include "../smo_c_includes.h"
+
+//
+// Sound data
+//
+
+#define SMO_SEQ_INITCHANNELS_BYTE_0    0x07
+#define SMO_SEQ_INITCHANNELS_BYTE_1    0xFF
+
+static u8 sPlaySmoSoundEffects = TRUE;
+void smo_perform_sequence_checks(void *data) {
+    u8 *byteData = (u8 *) data;
+
+    // Number of sequences | Must be 0x23
+    if (byteData[0x02] != 0x23) {
+        sPlaySmoSoundEffects = FALSE;
+        return;
+    }
+
+    // Sequence 0 byte pattern | Should start at 0x240
+    // 0xD3 0x60 0xD5 0x00 0xDB 0x7F 0xDD 0x78
+    // Corresponds to the first lines of code of "00_sound_player.s":
+    // seq_setmutebhv 0x60
+    // seq_setmutescale 0
+    // seq_setvol 127
+    // seq_settempo 120
+    if (byteData[0x240] != 0xD3 ||
+        byteData[0x241] != 0x60 ||
+        byteData[0x242] != 0xD5 ||
+        byteData[0x243] != 0x00 ||
+        byteData[0x244] != 0xDB ||
+        byteData[0x245] != 0x7F ||
+        byteData[0x246] != 0xDD ||
+        byteData[0x247] != 0x78) {
+        sPlaySmoSoundEffects = FALSE;
+        return;
+    }
+
+    // Sound Bank 10 init
+    // 0xD7 0x07 0xFF
+    if (byteData[0x248] != 0xD7 ||
+        byteData[0x249] != SMO_SEQ_INITCHANNELS_BYTE_0 ||
+        byteData[0x24A] != SMO_SEQ_INITCHANNELS_BYTE_1) {
+        sPlaySmoSoundEffects = FALSE;
+        return;
+    }
+
+    // Sound Banks start
+    // 0x90 xx xx
+    // 0x91 xx xx
+    // 0x92 xx xx
+    // 0x93 xx xx
+    // 0x94 xx xx
+    // 0x95 xx xx
+    // 0x96 xx xx
+    // 0x97 xx xx
+    // 0x98 xx xx
+    // 0x99 xx xx
+    // 0x9A xx xx
+    if (byteData[0x24B] != 0x90 ||
+        byteData[0x24E] != 0x91 ||
+        byteData[0x251] != 0x92 ||
+        byteData[0x254] != 0x93 ||
+        byteData[0x257] != 0x94 ||
+        byteData[0x25A] != 0x95 ||
+        byteData[0x25D] != 0x96 ||
+        byteData[0x260] != 0x97 ||
+        byteData[0x263] != 0x98 ||
+        byteData[0x266] != 0x99 ||
+        byteData[0x269] != 0x9A) {
+        sPlaySmoSoundEffects = FALSE;
+        return;
+    }
+
+    // Now we are sure that there are 11 sound banks filled with data
+    // We can stop the checks here
+    sPlaySmoSoundEffects = TRUE;
+    return;
+}
+
+void smo_play_sound_effect(s32 soundBits, f32 *pos) {
+    if (sPlaySmoSoundEffects) {
+        if (!pos) {
+            play_sound(soundBits, gDefaultSoundArgs);
+        } else {
+            play_sound(soundBits, pos);
+        }
+    }
+}
+
+void smo_soften_music() {
+    func_8031FFB4(SEQ_PLAYER_LEVEL, 60, 40);
+}
+
+void smo_unsoften_music() {
+    sequence_player_unlower(SEQ_PLAYER_LEVEL, 60);
+}
diff --git a/data/smo/system/smo_sound.h b/data/smo/system/smo_sound.h
new file mode 100644
index 0000000..868a095
--- /dev/null
+++ b/data/smo/system/smo_sound.h
@@ -0,0 +1,15 @@
+#ifndef SMO_SOUND_H
+#define SMO_SOUND_H
+
+#include "types.h"
+
+/*This mod defines new sounds in the source code (see "00.json" and "00_sound_player.s"
+for more details), and uses Sound Bank 10, which is normally not accessible.
+The game must perform checks when loading external data to make sure there is
+a Sound Bank 10, or it will crash as soon as it'll try to play those sounds. */
+void smo_perform_sequence_checks(void *data);
+void smo_play_sound_effect(s32 soundBits, f32 *pos);
+void smo_soften_music();
+void smo_unsoften_music();
+
+#endif // SMO_SOUND_H
diff --git a/data/smo/system/smo_sounds.inc b/data/smo/system/smo_sounds.inc
new file mode 100644
index 0000000..30b3c5b
--- /dev/null
+++ b/data/smo/system/smo_sounds.inc
@@ -0,0 +1,98 @@
+# SMO Mod sound effects
+
+.channelSmo:
+chan_largenoteson
+chan_setinstr 0
+chan_setpanmix 127
+chan_setnotepriority 14
+chan_setval 0
+chan_iowriteval 5
+chan_stereoheadseteffects 1
+chan_setdyntable .channelSmo_table
+chan_jump .main_loop_smo
+
+.main_loop_smo:
+chan_delay1
+chan_ioreadval 0
+chan_bltz .main_loop_smo
+.start_playing_smo:
+chan_freelayer 0
+chan_freelayer 1
+chan_freelayer 2
+chan_setval 0
+chan_iowriteval 5
+chan_ioreadval 4
+chan_dyncall
+
+.poll_smo:
+chan_delay1
+chan_ioreadval 0
+chan_bltz .skip_smo
+  chan_beqz .force_stop_smo
+  chan_jump .start_playing_smo
+.skip_smo:
+chan_testlayerfinished 0
+chan_beqz .poll_smo
+chan_jump .main_loop_smo
+.force_stop_smo:
+chan_freelayer 0
+chan_freelayer 1
+chan_freelayer 2
+chan_jump .main_loop_smo
+
+.channelSmo_table:
+sound_ref .sound_action_smo_1
+sound_ref .sound_action_smo_2
+sound_ref .sound_action_smo_3
+sound_ref .sound_action_smo_4
+sound_ref .sound_action_smo_5
+
+.sound_action_smo_1:
+chan_setbank 0
+chan_setinstr 6
+chan_setlayer 0, .layer_action_smo_1
+chan_end
+
+.layer_action_smo_1:
+layer_note1 39, 0xc8, 120
+layer_end
+
+.sound_action_smo_2:
+chan_setbank 0
+chan_setinstr 7
+chan_setlayer 0, .layer_action_smo_2
+chan_end
+
+.layer_action_smo_2:
+layer_note1 39, 0xc8, 120
+layer_end
+
+.sound_action_smo_3:
+chan_setbank 0
+chan_setinstr 8
+chan_setlayer 0, .layer_action_smo_3
+chan_end
+
+.layer_action_smo_3:
+layer_note1 39, 0xc8, 127
+layer_end
+
+.sound_action_smo_4:
+chan_setbank 0
+chan_setinstr 9
+chan_setlayer 0, .layer_action_smo_4
+chan_end
+
+.layer_action_smo_4:
+layer_note1 39, 0xc8, 100
+layer_end
+
+.sound_action_smo_5:
+chan_setbank 0
+chan_setinstr 10
+chan_setlayer 0, .layer_action_smo_5
+chan_end
+
+.layer_action_smo_5:
+layer_note1 39, 0xc8, 100
+layer_end
diff --git a/dynos/smo_menu.txt b/dynos/smo_menu.txt
new file mode 100644
index 0000000..a12217b
--- /dev/null
+++ b/dynos/smo_menu.txt
@@ -0,0 +1,32 @@
+# Dynamic Options System aka DynOS v0.2
+# By PeachyPeach
+#
+# This is a comment
+# Here are the available commands:
+# ID [Id] - Mandatory, must be placed in first
+# TITLE [Name] - Mandatory
+# TOGGLE [Name] [InitialValue]
+# SCROLL [Name] [InitialValue] [Min] [Max] [Step]
+# CHOICE [Name] [InitialValue] [ChoiceStrings...]
+# BUTTON [Name] [FuncName]
+# BIND [Name] [Key] [Mask] [DefaultValues]
+#
+# Valid characters:
+# 0-9 A-Z a-z
+# '".:,-?!/
+# ^ | < > [A] [B] [C] [Z] [R] for buttons
+# * for the x (multiply) glyph
+# @ for coin glyph
+# + for filled star glyph
+# _ for empty star glyph
+#
+
+
+ID "SuperMarioOdyssey"
+TITLE "SUPER MARIO ODYSSEY"
+TOGGLE "Mario's Moveset" 1
+CHOICE "Cappy" 2 "Disabled" "No Capture" "Capture"
+BIND "Cappy Throw Button" "key_cappy" 0x0040 0x002D 0x1002 0xFFFF
+CHOICE "Health System" 1 "Disabled" "3-Health" "6-Health"
+TOGGLE "Unlimited Cappy Jumps" 0
+BUTTON "Back To Main Menu" "smo_return_to_main_menu"
diff --git a/include/sm64.h b/include/sm64.h
index 632224e..efd7f6a 100644
--- a/include/sm64.h
+++ b/include/sm64.h
@@ -14,6 +14,9 @@
 #include "surface_terrains.h"
 #include "macros.h"
 
+// Super Mario Odyssey
+#include "data/smo/smo_includes.h"
+
 // Crash handler enhancement
 #ifdef CRASH_SCREEN_INCLUDED
 #define DEBUG_ASSERT(exp) do { if (!(exp)) _n64_assert(__FILE__, __LINE__, #exp, 1); } while (0)
diff --git a/include/types.h b/include/types.h
index b3dc27e..1bbc74b 100644
--- a/include/types.h
+++ b/include/types.h
@@ -145,6 +145,8 @@ struct ObjectNode
 // NOTE: Since ObjectNode is the first member of Object, it is difficult to determine
 // whether some of these pointers point to ObjectNode or Object.
 
+struct SmoData;
+
 struct Object
 {
     /*0x000*/ struct ObjectNode header;
@@ -204,6 +206,9 @@ struct Object
     /*0x218*/ void *collisionData;
     /*0x21C*/ Mat4 transform;
     /*0x25C*/ void *respawnInfo;
+
+    // SMO related data
+    struct SmoData *smoData;
 };
 
 struct ObjectHitbox
diff --git a/levels/ending/script.c b/levels/ending/script.c
index ad3d738..0555fb9 100644
--- a/levels/ending/script.c
+++ b/levels/ending/script.c
@@ -8,6 +8,7 @@
 
 #include "game/area.h"
 #include "game/level_update.h"
+#include "game/game_init.h"
 
 #include "levels/scripts.h"
 
@@ -15,6 +16,14 @@
 
 #include "make_const_nonconst.h"
 #include "levels/ending/header.h"
+#include "levels/intro/header.h"
+
+static s32 credits_end_wait_for_reset() {
+    if (gPlayer1Controller->buttonPressed & START_BUTTON) {
+        return TRUE;
+    }
+    return FALSE;
+}
 
 const LevelScript level_ending_entry[] = {
     /*0*/ INIT_LEVEL(),
@@ -31,7 +40,9 @@ const LevelScript level_ending_entry[] = {
     /*12*/ TRANSITION(/*transType*/ WARP_TRANSITION_FADE_FROM_COLOR, /*time*/ 75, /*color*/ 0x00, 0x00, 0x00),
     /*14*/ SLEEP(/*frames*/ 120),
     /*15*/ CALL(/*arg*/ 0, /*func*/ lvl_play_the_end_screen_sound),
-    // L1:
-    /*17*/ SLEEP(/*frames*/ 1),
-    /*18*/ JUMP(level_ending_entry + 17),
+    /*17*/ SLEEP(/*frames*/ 120),
+    /*18*/ CALL_LOOP(/*arg*/ 1, /*func*/ credits_end_wait_for_reset),
+    /*20*/ TRANSITION(/*transType*/ WARP_TRANSITION_FADE_INTO_COLOR, /*time*/ 75, /*color*/ 0x00, 0x00, 0x00),
+    /*22*/ SLEEP(/*frames*/ 120),
+    /*23*/ EXECUTE(/*seg*/ 0x14, /*script*/ _introSegmentRomStart, /*scriptEnd*/ _introSegmentRomEnd, /*entry*/ level_intro_entry_1),
 };
diff --git a/sound/samples/sfx_1/06_smo_custom.aiff b/sound/samples/sfx_1/06_smo_custom.aiff
new file mode 100644
index 0000000..214ea7f
--- /dev/null
+++ b/sound/samples/sfx_1/06_smo_custom.aiff
@@ -0,0 +1,380 @@
+FORM  \AIFFCOMM      p @       SSND  6                O ` r3T>*$XJaP(nPSB[. &7d, ?  Xh"A+GDI){?u_&VE1z.<I=&|^c!1\Dxz2hd7lUK(+xz3WB;"+$BBM;j'SCn+s^@C'K;*"#>U%D4BRa9A-&?PE$)6L)GHE0,s7']):0_;2#H>z,_G:K	~4. :92b*X*A$pE	AO&WB]b+8:R*m\n	*[H7 EP8H*O7HNt5$hXf#nJ.58[	F0>(bP7XIT Z0LjL+3vwW@DPH>)>4)	A*4]69I3	PX$9j`)sH[2<BM+A5.}6rB;\SCo0k0[SPG~K+?17+d:6&`,3#1w44.n <8fQf-:<.!00[if[-43:KM~FD)sEH7$1(x3!6F}L=p0KZTE5UU(?K w$D
+ 6$		C]/)>AE6&',.W%Q't159?j>9938S@dH7r$F|itLuC:F+"ez>JSQ6@BIE?:2:s.::74/>RKX)*5-?2Y-,SUV#c8o!b>g AB@E]>79a90Ki s4$x|
+,(*&Z.].;)*,/(jQP@lJ7^f92+80a.68!465#6/A"	)v'	:"'(94>20|s%<j`'#/!}"(.3%d/!i=9"1--1:(z h#	}M$9>88 30*~!Q}/pH_xB>	~to 25R".934[.$KJ#W)'%$x ?dZl$0$ "a7uYQq4;	Xznun:U(Ux1\/s-4}	!8@<B@4%"3-83.!)"o*	b[%$&q1hI$) 5 s-e	oyQP=2@d<4*Qp&.00v#N	.8WWD'.0(v
+T#
+-)!#Day-t<&FzpP u(O2R-_$VM d}cvHaW2EN%* *l.f23I2>.*:'=C)9>mM:#%8#%r
+>D$]d:Y ($'.'-%"e"G$6+005o7/A@}pAX"#'Y&$ oM>o A mb)B1isAOx6z<]%M ClER#*W't&-w/(w-HI-	
+Vv'rh`q P	*}VTSs	|^7o_ Z
+=b!]vb3\ u
+r ?"](23)p$'%2%-.%.h
+dTK['`. @"I%)'-04bpxxsZJ)'j5Y4$J*,Q(/ !j,7"88]51`-!cj||N! .b)J5-?0e,<#u
+6!Oe`B:th3/@N=e/f	"#,(, 1]3^98!50b+p'!3Won9{d2})o	_,6ACl?93*/.,c r `	c%aPY EA~%,-y+'#!H!S*7g91%\dY<*3q- |F	
+	96	Ue
+Qy9}%7?!%'(b))7&Pz!
+
+#_sK_NO@H/+2:46541*$#%,599;?@<3$	\TN<^	 ?a<U6n&&" Oi>
+'12'^p(4F[[
+"VO"T\		&-./h36Z2&{pa^&.*10/4 QZvTSR+P35o3j-;#2o\:G	G	nit)D)+'#5!c%'(5-V6>@?<s8#2&;A%09`	2@WlV(,(@ F/Mm~'\./^'P@,~&
+6]?w;:	Jm*x$" Iy+K""! 
+%AbNI{Pf_fW%/\564.&_puvE3dQ\~A:8U^		1&.1/*%o$'+Q/2h222Y33, dsfh;	k&574I/)E!yv8><Dsvz".i _$k3588<641/-)#gNc[HNmw	tF9 	7!DFH>@;-//9]:<8<*TO/8l	6.hn4)5ET9q,4Rt!(5"y 
+'LP67?,VR-]6i7<>F6p PO:XK%3=?3;<4_%B{EU'&z/`8mv(*lG1	CE;"6aYRsZT:|DEZ8@F:7O0	:'t!]/;63TY#U.*=.^mO HD v+W=>."CzE4N{#;r*W)RH536B4Ll~sI;Dn>4FO:, 0$-zhwJT7[8f E(s1/ (2{1"ayQm_T1.GS8X'1.>?^7SJ&ZjI'{i 65!hEI&CI?="~nl qMcx>7I]KQGI&/Uq'1`ZLl'75M[0M;FL@-6$_!KwR\*"336"0.qdTQ)T1I:M9_?7!f 	'2.??TeH:Eo)cpaXMCU>8#);eA/8JC.\hjF
+:).&h1'	)*mM&b<FPP\>}42,`&,A5:>O>8:e1+<unt,j/6m?Q:7o<B}K8N1BHFKF:2j$@OQT}NH>o%#!f%b-,,.+A+$I$I(9>Im):{6G#^UH+LBW7.8=4%
+H_]/ 8),\%98n+./u&)$'d[koc#-ZRW..B)S;?1;2K8o3/2"@f1l<.V?E;5Av(@p($"2S;)H	GeB;~j+!&i%87 .z,7~0%	*"g+d5)+*!J(6MN
+L@;5),	Jgi/g"('],? ^	2e&Jg 3@=B83I&"+0(h# n	_\S'*V,-* ,]FT9:#-cCcsA  Z$Y'4 .*Ch$;8K *u+"`O.>`@5B:<,Lw .IC:f6>.#;}	O %0g3^Ebw3v9>+bl,(?-2919GN`F<4q5V/35,K;Ty 3?DP<0&"zd]*.& `y@g3F/zg%U4.2xyWUU%,A
+U! {B^0u|Gv-G0V18
+5n0X11/9--|)AmE$) $$4/gc\<PzG5;7<a>0''+-39E*O6]j k'==2-&r o?
+@"dO
+J5	2;~GOkTJIbx
+80)0&*'2e0#.eE
+%1d-)R uL%LqrsrN&FcT= 6c_Fi^J
++Ba1+0
+;A=0'%-:/[,M'6(5kw4U9kVa.7a<;9){	"U cgd>*3-|
+9%<}:Q/]\?I
+*D4 )|y#1N:>+@%SLsk-KB7hb~ 2+_83 )1hagD1%^&6*X%J8Q^=K3*$%ctFD,X,..ny:s:y*(2[5E/ QLn]|3IL A=>12k4C3Y7k		n4JatH72i8,+Z.(A2"D@)T-!YRg|.F8+w+r'"C;Ox9g<Y'y=8$t'5QZ`@
+ap2,XE$4@I0*S#-8:=38aJmC
+>4@99w@jVuD
+@&V1<1053-W6F"[A4("JwJ
+h/bm%~'!71(+59=C4A6nRm4c!A4)()54'xXKUjs]<(F96;*|ZeO
+["O(>-%/)))s'2C4BAE>6.$UOfEA@e?\);2-)$Q!L!'X8.9@k2C *$0D1
+!P& ZO>6*ibR~(`-?--W'kQd?
+%F-75=J:D4=,?"i1$+K!X@;1#134w-&P$$(-1B3k7D=@=Y/T(BE:4,nPnd[c2?/Ic7>=n;8A8+4	/9$IQ/$)t>EE 8,-41q48<tA@98)=fC%*o4n<D	l	
+	v	[	#1!;@?947,YQ;[:v2`;#D;mG=EBd?7/*~$}][B
+s"!$!&&!	+qj <Mmw %:I>H<b6}/++1-/.A*c)M)*@.& o"#((b%F V!kH*c
+S%
+@$%2GT%S,-0+6;K=,@CEC?5RZ*uiThA
+z;)T./]1?-?'h#`B\
+L ,o2p/+,Q!+"6 J
+@O  U AQ	@!$~ 8!!/Vx afmBs,")3A<CCj=5.)&/!7"'="!#!*U"#8,5&<	cE
+@2>PLD;""lb_fUKO@%7!).D&*oH+2eC0At31;E/S6>@2q4,
+J;Uk8w<D. Cn<oLOA4=X%	$5< ;2	1G-A#f]aE|ak+KLIo/7vK#(MC931i*mTc
+Xx^Z$0m+>*s?$lM U%GE=#I?/#\cZG86+>!$ X$3dD"J
+:Gk@37$(*X;B8\?&2,  d#>x. H0n
+I 	(DLSO6}g,K9]>>TGH|?$'vm<j*v>BA/Z'M|y&|NWB?+paC(a*7rFyM&2P1.
+ct =O':*9^#Y.3-R #=<2CWK3:$/<05+0" ~B#2`MEhPVr ]XLM#MVXVpFXG'rE2^BC>1H,!CB ;>*,u8 r2 n 9SCEw	#lCTHUI498".!p x(35:+ ,,`HZ [?,k\BYxN[2.)9TLC>>1,'&:]nMC86Cr/T#3;.=0 
+^Xs:
+5QM	v;1'K?3k=B61-QHZ@nFiDjI>S3'#EB^F#$F	
+uq[u::IxT3NGC<=&%~-(W7!!:*u"3@6E"314!p M.		V8	3G IF=]h[mF1],/5N`-V301<;I[^TIA6#	6,Q;o^T"?8r4s:Y,,LNWIz=xm	>
+
+)q'3#	-DEEe<n-(#YL z-|i%!!)&%ZFu~6 '2X}xdO=NF^4,r7<>;W743l0$P-mw,'(0W+(; ~{1|XJ<;A>.'-(*?/ &y+"a&61?9.#IZl5b\	{YPd0_c:xhR 0loZ|!>)$X$*r	-
+
+^#`Xnijp,
+J@o
+M/>.%# 8-G)3[?	@-Lv#(((Y#XPVT![')At2M	`2x  V+/
+-j$C52-(-(y*3;9:7,+<)6S3zFuW8
+Wb)'zz>A-0i%p1"K^:?Dh9.5/i"!uGs{0 HE960);d3_et:1/,): !]2a1*w!Q@'r(@L@&_Y+o?+:==2.)O {0ZN6OLHID4&-^(*/;0<S3T-IPV9Yv'&)gjl')<<*&L/*sCNGt 0$.[S).-y075/.v$h;y;a85$'y2gw99IF><-5C^#E@
+-<
+2(!wZ~%57`73
+$~,m7ZF$g$\fq
+\<)72`s- S=t-x#{ /g-}#-N /p11j+8=ZhS 5F#0:=7,6}KWkUu0M7h4(C%,32":
+\g|2GFND*=0=jiR,xw_2Ad>:3)!
+	5gkph|LA&)i+?273"fq'<	dF:	k1D@TIPJD<-2WWi6bW@-<[(;MA);4+U 5W
+!H+-2//--2/0+pXhxB9cJ)DQ>5)%{$crc{Um/.R	.>
+=
+<Gv%XtDD*#'%4#(,./+21343i43b,O*v\G+	u+ |4m^ -	/)<BC?6*
+	a
+^i~ib
+]
+59<`y!SV'oJ*t 67" )x1=ZC3l!z\!SWtt&$2x84.*L%L+#n(((j'^4i.;e.*&"~=bR"/11.>)%&SlGG&6=4&Y6Y2)
+F@$595B,.#S " #@{ vFm,p,W(75.("vm!lP
+,2u]b(d`	l~H(8*:7d84/#pwlZW+ (o)VS*]*&S
+sET!`jy
+OkJaVy70570843*.S! ?: fipp
+dT  #r/	IC^ sfjL5A!#'(0 A	#.= C~B=,:?E84PHp}-Z:9*QO3*/8'"_%---0F+)%|A#=/$UX(*:645<649#qd<@i\x2Tav.	k<5XXB0sgtjn
+Z$ID6x*;'d^	,>BI8CfWEVydz
+U
+mn}Z5+f>@%#^ ,FM
+AI!B# -(Z_0#6=:
+478"=<-9~.=!	,Z&x)=+'Jr$}k3"OT)<9F)[63=, +[-r	 58r;6$IIjkt ~R-&'e.]Aq(8:>:K X/3`&x|2/!GKE?B7"(1(6E7'>()D_f/R"9?p7e8:'8QO44AB>>+2u0`,	2%&!vJ1D6$Q ^(FK8*6@26B6>?<C:;
+"(6AN`
+0?"O?B5e;/BLr@;X2x`:5&09i'0+1#0W6E$gZJ:
+(&O=<3HA'-2,  7&f('%D!f8"|NC}G8]6
+<._(;'0?*~.l@.$' u;UK`=~?A&iKC 9:q>.g#a2.({ 8}]I;	UU]Q$
+?%.fe07 37]6N/?99/1n84 T&V?MGEA'2P"1>or=-Y	z$HuK.%.u9JH1[$Y%&" 	Q B)9*$6,1I*4KX,BIk5!O:4\84/v**c f!?7>B6&[#	=FiJ
+1E;_EsNC0!1C2WaNA`$
+ca*,!=jB==n%M	)'+3Q^o`+0<~tU@y"x!00+, Sz0W/`;889B=:q5 /
+  y/A/$$0?+{K)<pO2"t?&Z8Xr|%ef#" :I89b"9jf?&]#G$<f?C2&[&L~F)	.,K.	\[s|	@'s{<ej	XIA)5S9p+/D@1 **1Chh$)[3%\@E`L&]`_
+s}01[ FJ<A+/%,/yG*<&693"I50	vnoK#P]*#>5(:F5:	<Qz<L)h0N6$N=76&{
+/W#w$kx.8Pm453(*rsH)A5-
+!4\J ` waW$SCRF4#&G&
+\fu8;96:.1n >GI^DDBA1!> r$819;E7+'!!?4^u"2:t.Cc(h#|gB	;7:K(ETW!o%&4,2!)KAh3:2529"mh@LMT7
+/LM%D1s* M3%-I({h!22 *C!;!1994J%h?
+i{v<wo
+;@|+/?3QW^kSJw`$L$0!!nZ&+++ ?E{+"5?:e1$11u&8{<3k"U!%:9WiP:G; ZJ_'<D@;0#7
+!D	ja}w# %&8S:tCa6 
+?)Qa`.?5INNGK7\EThOl	s$9B<2%]e
+9r 
+-%H.0.02)5gyl0c)E>gHD?8~.b#:$	CvV 	R	<*_> 8r3M$//[-01/X/Z.J.+#KY\WeH\;9D 5ADD9*b>
+#\wWsE?P0FGQrD6sHUW_YjT]+i$J2`4I+5#
+"@ $TJ3R)$0L*&*%"w?j2@C8I'-NJ$_:t1A<31#7}S0?"Me.#64*$wM'bj=f4W)%jn.!/0/1.$49&Y- a'(&2}c"R !!%|m#KIqH+f:463(+E8 m\	0X?p5OI-n[*x{]a.Cz_CV[UWh #c%i&#g -<B<}(Npu; )#E0l/7w$9/' (%*))#+%)i!P_>m1WD			!,?542+MC#?TT$!
+Q
+fDK Z~g53eWAT6#4>=H4+&C"X!.',.10$nh:am"O8F5.Z(A{f!<cS!4?c@9-s}0{ GX3;f:83K.T-ho2(N'6y Ip%N./ixOOY:G$^S#XBDRE<((85*'"83WJ6.*`,O_9oXF@QG2*y,"oE,H@k<R`w(1Bx j`{$g}$1&H'V,%^K55M7<y( _7E?'%To KA9ys,iu*TH.|9^p5	;m0ma"41( !l[hP$\I!#mFHZ?;?90Du',O4 .1bS3?(#h$8/"#@30P#FR {%/;G*+#Tn6P^?7*I6 8<v-*wSXnP5#!>h 7C^S] ;
+h_5;66y_" *88j0@$8/JS)*/ZTZAd/)Pgo 'A@+N$g&(+80S#18kU(qA{SCcH;+$96@/7"v$g/p|<7#f, 6D<6=%/)A=k0G>*40:`V$._'k)2l9GM*@
+IO5WHd%+~b
+2I(l-q83o6siH22,s#>43cj0T<2ij 8c_QH=!!$qZ|h;;+' wmS}mG`Y6W
+
+>15L+#&"`9&y#W?9S(&)w6|#r$$,%)#&N+R=B6B5(G "Z!5u/5LWM-"~+&VIUG=:@*1,c,%Uii*0>'8(  f}.U&/<'[NWGUtE>.*z4.;vpN^VGM^ <dt(D*)D#C7<(y'?(S~ 3#Y$i~[bClx54S"R)^t%  }!qx*1/(3~56A~i2S#4jI*;9_ >  5?<,0	nA;JI44*4HudfDq:A85#!y!6
+G>hJ'?R3		="2&A
+@22>=kOxu`wDGHJ/E!$'	,uS-W ,wUow5<$}l`"E&y`}*" K("@ 8.;>8o=T!}2%,[8TD4 8CGQ80%%D"V&4/^"^q"f>$
+=Du("D8CZ_	$ w)!B+*f&H5*su}-:BG8yrQ]x6C;.& -sBzPLrNA2>:N/%E>;|/(1mo>" (&4~:,'i%ra Y3%H"(<C+9	 _0?)ue}d/"B+G8d% Of$+e/(3;3o|ih3 2qBJ;4#-\!H.!W8*j/_,!UWl5vDmI
+d&"Ur(%N)!*q/21p0.e&VVKz& "m%
+?ilJX_	%132f$z
+{$!-_u
+_>V ypAfn{ K!
+&	zXm
+z $Tp+*hE5v53(	^	k7#AWA1&3W1c
+ +=n5%W&$o u+.ja!=0j"n\
+v{I
+Dy.(/$(+P+b|(;${#n&rCc4
+C
+s}\C,.B
+o0,)"]|FjRo6t7	]L_gbtI+6i{$.C=7:^qfT?&W(v0h"`p'(S!o1&/&*?*(9Qu'00+<T@PE3kke'"v2	&or	4!
+
+J\S"$~5:4)6""v+(-*#*`'6=4W-H"#9"33ACMuI6OP{2;~<!8-V#Wk
++k?`Z~]!#5\aWhy+G7c8<;70%<P.2,"yZd&^^2(@FO@a2'
+:t+\Ia3EwB7,}Fn2Vy`	9trdDe<f(3._5M9U@v-/Q571*/.!Kd[im   !Jy $7@nPND:3J 0yx)=84-"C 	 J0 2b2#P`DR	pw#/((>  %0)
++)$H:K,,J.Qh:	z1a$RAL#o.@?TXY'@PkN[>,84'Td) 1'I:=eEc4V*gD	:C1g/N(:u_H<!;`M>o^*s]\WkO0I GG1L!aIt-,'}D2V) Jo+CLSE8H[ y% ^	b}cl	E11-BU.!F'\[j#"jUZN}S/NC9\2C;(F*7#W$T'reM *&0~-$t)3+F#9j/NNFEI7:'3&9#F1'9(:\!?(+QC'6gXt;A:C'#
+$WQy11'21r&Dfz ^*r=l:7.Tz{_n3YGM;T5x',^i	}xO"$&yh)<.+DPJ"
+ie=Qk $@0+ K	VU4V5X0,*G+x<bgm	 :Wr3.;2/E,0uoc@U "FFQA[-jL~_*%?+:-j`z:^yz#t!
+B}QA'UPa- ; 
+"A;4aw ~yf	rWuJ$E'*2 		t	?TGI1/N=pP[`=X%"#- 8  eOQs$4|r/ S5 2WY
+T&-E$v $tf!zV'x!		Wl%Vx	>e| +&*+s6]K[0U&s
+?S+ioq%d."T6#Zdm?N2
+|e&O-)]=)z}!G
+nnI02iyJwe z{P_7/c
+[!8<+(#mF
+&DTy#RT
+XM	~
+5y<	M d:	~	!!y ^c
+  k"Ya"S~7y)@3Pdz3j94R##nR  	Z_*xo!iB	|' 
+%R  =]qhsb .	
+93u$#%*'\L'%hx	7r0`~
+0	2	(	3l]J i$),^N.shsp)+*! ER%9'>,$
+YHI}6"r tdk
+(EPMwg{2N fYj8>	z2\CCx`a!L y:*!)}9U4 .#~pI VP109
+;XF_` 7h#w\-v,
+z
+ ju&2`; nn} p-j$=	Jx*0LURD/+!+("12|Fn2k`&-P8J	 'i!P:'XU-']ZqJ"q!`Pw
+'2rf	xge@_
+.?^g 98;0_:HVqVf$b%!?-_G)(pg.p$7xr!j ? H!~
+	$0g>?efRGFj j$8	6Bp
+X
+)	Cwf\8.=]SWM:4" %fq^ %yW_}0	yn wp%2
+G' 	' hq g |)Bz4~Phb|	 g6fukky#jqe;V  !
+"(.}fjL
+E w	t	b;
+lY/G!$4MP(F<BA
+7sS:'/O1$5l.l3$TB Cd x
+lY` 
+ AI0;JV!";  .	 &,{d+k/2m 
+.xU!'.%e	c<rMR(	H1sTMc^Bi aY`$ut$R
+?'T('"R>,!*! "PH )$Tam1o4(X.*6#d
+X>5n0 lc)QN:"ab3'>w%pEX[##\"$]%#g!)E g/0_#	xyUj ,)-4)"B6 -x,t})N.$4`&'-3	U(C66>U
+PfNmWE-qAT+.h4 `
+k6,B  T+c+nwSn6;e+Yq$%l?F#+I+- s&)g f%]+)39})
+b8ZQ
+b)T,>Xqx@+, <&{(0&.x0J!Ax
+4t&Kv
+oIILV$4.:+OO6FZFR(tz."!-%d*(m##4.+( yL})(	1
+M@hLS]y~_N$|-.'uBM(^%' 	Uk!|(@	% y	 -*("W! Jd|K+-U7]ZD!&wl hYoQ1~,	%l^#(B7k?"z;	Ny
+U%'&#)aqlI 3y rYL#dS4Ve'.m#)
+
+R.+|&R%~e_j,Y'/
+1_Z
+Zpj mqV k(/q)} n ! 	Op	59r/:M(
+\9yo0+4	`)$Y[3)/q
+JIiaZ#&C i#)*!$	QB02%0$J%"@+f2] fO$4,a
+zj{3"	%)+0$+jt@,(
+7/r}
+?	#Z8&{m,o6/*\1$T"5%~-ztRU'n@;\YwIFDZ9B.?.)=5;y
+JJ[#	{7 [/o,UC"%
+%Sj99;.>nI.F70]-E .S+v i">!"XK 0 #\"P d6
+,PP 
+C`0:ac2$#0 jO)%~iq#_
+%k
+0@]-=.%O		 p		YD:~L9C%9@&N`Y2~i+,O	!)\
+<j5~<D8y	` FCs nSF  ls4!%$k%S!>[?Vs!L=k	
+	C-	
+I= Yw? )]wgAqK%R  - O	%UDd
+iI o+'q<vZ!.5Qt7syY;ou3T?
+8e>oIHac!	"yb6
+NU
+`{>~F$"$0x`k!. s}8V! Ls .o(uMX>5 d4W	#$%$20\	FBcl	WH-|G[u,dT,+j5a
+sg'ce{	xsG/ OkN94'YXv:3 WOM
+ 
+:kaW `	fy<?(jpT0A{* Y3 4>cB5M
+K`c^lbv+WQ}n l!p}?MT.
+ L(&+:D
+rlXM iTE  	8XD 	^
+H*HCD.R:E80'GUz#+)=JGm OHDW^N? E ^	Fy!%7xvz4dOgp@]	 
+\/m^AFQZ 
+(	I{	68MR()% YyR3	> r	j rl}YlJ	Qxq*4LG
++~	NQ/N}Sn	K
+"@DK
+N;Ev5~vr)! qE4E#`~{nmAZ]ki IgP.bV' +
+}d$qvJBci4]i W;eyr)n0bz<UXX]Jlc[$  I 3{vpi
+K.$d2 /2W$YL
+~	7$wdz5X,
+H\-oo
+\9-QeV4>~|47i2V#q8?  l_k EI >r3& Gv6Rz,d-$ I'b(y#Ra
+e
+x$2,0D
+&++Y
+GX
+gAodJ5 ,*jb=Jq H
+q&q!H
+qv~ *	'6 0/I`T8Ub 	WL#)'	u
+<L!8QH%}=b]	w{ L
+\?!|h	?]j4f.,+Z]kbk
+\s#J pc RqTT|r	l s{
+/U1(m%0rfX ;G; &*S@04$	keV
+	"Qup:S.&$[&K5!% =jtV!8gx+r!1W: cK*95!5ww~Ru'T*) N
+-(	LT0n"<;.
+)Ocf=OL"%)	x@v
+~W!h+IWmnMH*." OoF
+eTtT	GW\~> gy>*zMS.DT%9|-^"S: ]
+%
+ppN>)!!3#	q&J$'*U. G [YACH{SsBH GGzDPuQpR]M^xL# i&#]{&f9 Bh * 	>l	1~n|zdJlk	^"0(q9k	J?VH
+ F cmWW=~v	zPsMp{	zxP\yK;0>_	k!+e Lpu3\Y
+8dw 	d,_3o5s	@!E]9_[Yv<9eZ_	|&}^	&~E0"3j!;Wn
+hE?GUM68f qP~+ -6{
+%
+g	p$P p8$|LsMEp$0
+GI
+q
+	kvwupt B|'v	s3=pF,q 	(+ 	B|g :  Hga{	&_ZA]-%Q1#SPJb?:X(2_D	69cgA^; $|.fT	clSR
+do}}| l]Er"(iN5(8N		BII@e	v
+5 RRP	 u>&]U		'E=y	keM  AYm  
+	c	TH Ec
+l	;B_][ 
+a	!A<7f ;W	Rq*wo= k*~Vh
+T6Kf	(
+0	g ZF	zF
+	
+Wf	xyI\5.!t$0Z^3e[v
+T	BVUil5*
+^\>RCi~	l[ZA,EBoxhD(jv	TvG2\sgG8hsC+Qc'~NP%,*ML1!y .74NWR 	c  kx"'		p  8ri{RkQ+-a| 4[
+c
+NbhT|~Qulb	$ T%6]SB WSO4BE_'8^1vUd4
+>  hNn\I{	,-xdIQN	 Xh
+i,`]u	Ey{hZ-/K	h
+ l E }b+;Y^
+M -v6E(ASvbmW&v&+?k
+
+y GJa\Yc5zJ?gx
+4R
+PZ D|
+`SC
+<
+5)F>*	g
+j
+g61%,	  y[*z| *b aQs  L*l" A	h*8 MjoLubZ2
+4	Y!
+
+r}\x"ww	^KsHh 85	7^rmf8zP1C
+ 
+	&:o""##E:ud#q! g
+URN?
+66 2	)	
+tq'u
+	6; ;;PN.O_|-O> (n-dlf*
+]"-bY~+	QI	V*B
+v:bX	s>pEt	CffBShP	mA8><@N+= x
+=ZnqNm"E
++xXyhf\9":^poP7l4uc"bzivSzw3	CSgY3zd zK	Y5?O9P	q,D6	G78	 dy"BODTjzEsbmI
+*M7M3j wJ{CM/<CF{o( 2LM
+\2G32 =+]M a1 		?
+t
+_~`9N
+ APtc"q0;x +3s
+	fr=_'Is
+=xx F N	y$${k qLk #NK31'(]? h? G$Ly
+L  TC5	oC#!R+En,GYctvX6A +a#vx'G>w[8 &	~
+t]7)L8CKwr	
+R
+K9Q1A-;_$+(!H! Dgduk
+	*
+D%#6&&lsA	|p`ic TWwA1x WK6p  (" 9d S y=[bZ]7u( ]l
+P5q,(	!c1`
+ nVj
+ &NR s|]L@%2~aw3fr	n	 ,U4N lmA37L'Yr 	  SF
+
+ 		7m g*;Q-S5$v	&fkEZ
+
+kRyarh%ZY	d+
+cw.vZOc# @R> ix
+U= u<);;7	=>6q@J	
+d' iu/w{UGU^?_ Q$1g	
+] +jCbBEn,|_a=G'ZZ	3)VBCVypi]J5
+VHFZ%= 64R\r 9 		:r
+l1k	)f2%Opn)44: *?	4	#[  X z)1[ @' kQq + lYc} dD $
+
+  `8 s. tK g)L\	x
+c+'4ito	n 9x*yC/0 0lX3 $J)'*a
+lFiR o 0e O { &	K	 +x%6 >:#Pg;G I&.CgM ' r	i
+C_wZq6c;o 5FK2
+Jhz-4  b ! a6gm% # ""#^=ul	6'\6P ;>5 i 1f3p#H} W
+2_?$ q3{N	} HOz\qbV	
+'xyA*WE{
+xJ0% v-x Z~hyr 
+	*4'Koo^G ^ | rbz s 0zK tnHs FZ#I
+>G7Y?a] 	<7<9lOT	]&	3&ck
+=v	^yc{- -{)" = TR S ]R  b'(M4+ l]9g6^5f KiUpux
+	B*; ?T`ujJ(BDotL 5M	kKD RbT:wM
+	ay	C$bs!e& |fQx;<}NyD$_ a j		. f)M#<Gs	QgaZy#{	G*ctmqJ #'X	   ; c' .	
+
+L,Yj]^E		de= % 4 5 a Hc$m-UL;|,{n    *= R !esdr5: g
+F) LW& e3gq9=K	*@iL
+ldQ-nh@: 7 Z3f
+| t(\t	)qp D_rou 8|YM#EWk (3^40Y]> xkjo<z&- y 
+ / Y  yju]{p,a
+
+!(J
+j	_kxle$:4,KYB z{:	
+M~(Q\N UrYJ 9(3	*Tw8; b\cAPR*\W:J	LmJ.M g	~)+Y]``C  {y*' <%dP+"p
++
+
+-Qo&		p8
+ 4;2E3y\
+	;w }FjIgnx]Ri1rS ;J$_2fk&Q; `s H!e*@Pf	62@ ^X LhC!bO7Q>DXck	x	P,LM|
+I
+, ( QI[4 w! ] |{hT>S-Y5Mu	# 0@N|~8?BDNv1g^>oGvl?8W	7	<
+ i}U,txg
+j76/OkG@	Pxi 	P_m)j4<
+e*I JbK{ *.7 U7'CA L&q0Otbi>P/a-6}`nm rYRB	lC	
+D>%}kJ	C
+nc|35t^ 9Pg k >Z dmmgXa,Cv$tXHi
+Z.6oh%
+
+	] O|	\	>~,FN  }1_~\
+6JDK.t ZS&2P|k	hG]s#j>%91 w >{), =  ) )q(	-{{:ndYfA 4aF&i=  U QSmpT rHkieMk`+2gU N [6.<{)PDX )K= _=&,\"*24Mc 4aO6  P |@:1I . BK"   z3
+PK ?Fr%*H` O<uk^E  u7LEn 2eTu zbKwM[ 1+G 4 CmT {4OX,C/17\ 93 %k-N R ? <TWS%q[TGXdEwTAkG{o   +V &*x7G  "?`i!!oiZ$X9LU	`9 !7& n2, 1 QV K =) :c ~[]D S  S?wz 5 x "$ @ Y x  l l i j  R /9 el6   gY   1 R(t  18DXn^k $  =   61 %fO=  e m  D-!  V gC7/ %fxBr7e C s ") 7 CC ^e3@%Y+ 3	 7  hj j @"sA&(% M2\ f#  \ O *^G  b N ? F b .*7	   O{ C yEVQEt+W,  &L0  T$V(X&J /   - Z N  M   '  a  d \P)= M>= w^c   4, /.p {k R}NN ; ` O `nfb g" v @VZ    z hQ U % <$dD@ A  %8K 9  UqH+rd  `J  R 
+ t  @a|L       I 2t) l+; # >` OZ[
+G    E8J  A7aQ
+: n` x 53  l~vb-z@K@ o ~b  ~ X  H t1Co  O  \  c r 5  AH +Dr$3iX t`of0RXl w4;# Q ?4-z`?rh     :9 ul =g^,{$U^~33 l    e8zQ^ 0ZKc   X c N% : V
+  X e    9 ] m7 J  _ @ms%5;0 Xu?	B ~^e!iM,l $4 u  Ck3_;1 }>) Xa ^ "Y;;O<y      l J: 0 Z  fU   Q:  pG* ?)  6     ]?8  y   b G v~y < n B66 2  ` ]  [  &  4 *hmY'  $D r  HO J E_X9 ]qG d3 g '@'pT $ B} ?33 $)T: T!  1*4MR( . h1e  raXDad s]?D37g (tj jFW  h f 6 r n-N |W #Tq  hSUF<)) F |- b  W E,2c|h.w  /eb   #e7En  hrp  hMG ]J  e ~ '[  2  v L   jZx  |: dO   { R 4 ] 7rG}f,9 N : 	X  1 >    ?e kJTY   h  A3y `	 ~%Pl( y  	  ) ^ Z7 "%DA:, =   F g]  V c[(l  M 1    J a9H?W :  :9A L  ~ $ ="0x t 4 ~% ,7dC<^f  qv [g  &n~ dz% D dq  |@7 h hx ^ {  f 4 tx   {;   j .  (SQZv  # DfO K / |  #  + <Wrj `ni2d` ; A " _ u 	n-%H< . U- XR:  B$ 0   G2 ZU  *  e?,] L"l  < Q&N> ' $  #- / +      )  dE?# Q w  y   )~_Mx] M   3D   .~ Z   "T=V1 y  5 N j or  /C 8 nP4a5   I  Y a   <  - Q?,a     D  q/  mg     6 s  m\  an E0Cb  rg jR / #   ^ybfp-D*I}uK0 y wWR F. N ! L6];ry 
+ n  P  
+ S aPI .W-xJD ywD  >  b    d&. >  @ 79 < V]:C 9 H GZ7c >  "y @g 6 J <|{ f7L     s>\  r i 4 (   Yo  <'   Q 3   Q} ~  G z  B   % # ; |A   4   'L Z" u ENt Q } \  M '&Q   ! ju 2 r v@Y& `  f maJ Qnb y  N T I LPpa B{, ok _  0U9; u'-1 qKv 7  ?d  >   n d  _ qO  Y G 4 0 LEC  9  F8 7    ) ( y C 8a [ 9 ;  r	 Q   o  6r   d p/@  C+F l`  _ m p?   oD 3 u % D C D      T R;Ck 7Z5   \;O ?  U #  H  A  x cN%7hu7 dC   J   9 } W      " $  p Y #D?J V.i 0=   ~ I  6vi  |  < ;>^
+k% ^ ,_q   NK P P * v g wS"y   {  12 ; ` C Q2  1BxE} . cd	2 	 X  7B   e ^  <O ,    k 9 Vq G = ! x W     o g MC `lj*    
+Y\ o       V Wue  )   3 ^>bD J  h G= / ( 3    Enpm  n  ( gxLj=)g ;ke   & -  V I   +n z2 ,  @s l     d5   ~6GX%  IEWz   b d ) k+ `W *      r  W @MSV-   % ' X T Q L l' =  @ :R     { V Mk V |+ D&  )l`0y ; Uz dlb G c    IvJ<{O. )#F |   T*~ vasL 0+ '  ) mgW FmJ g <  B[  ~ 6 \w	$ h  	 
+Hr 4ep  z   ; >P ?   N 
+   ] 	 ?   0 : Q   / |  )K ?  KL6 Q  T  j F n .  2O>    ; v J   # $   ? / X g}kz 6 4 i >@   k   H!    Z LR  s >6 v m  2  oZnO   e
+ 2 % 6 | eD2   $$?-  [    # x  zd) :   L 9X    6 h <   c | P6m^z x  O ]M4 ~i8?
+J[ J B?` + = a  X z[ w  o ;f  H' Y .* Fa{  Q %M %       i  !.  C_    5 \< - kR B       3 ?( 9 
+   N 9+&2  i  y 6   sts /   YT P c?l  ;g N < r  E R s E  N D@ ejL>  -C  .Q  gR   ] |   K; h  O 2  Y 7O , - K r  $      M u
+ 6k&  U 5sV  H
+om FE   d L  u% uj   u a   RJU N  y B4 ! : d MBX / P e    Mp   0 2 /     ( "  Kc  C N    * 	 fUR +  =  g{i~c/l  ( K g"  Ys &     R .  " 4 mk
+      e    'Zh E ~ [s 5 u   } W J 5x ? f B0  X  (aIec  t/F  + Mf Lu? * &G  \   @ mY W9 a *P   p p:xt D  I    H>7()  J%1 }(   ul " O 5 M  Y  c   q 7 w 0 l= FqN c 2  W 
+  zCJ1\I 0  % ^ ~ 2 z9Wy\   \   N  1 | { Nj -  9DJ      
+ \  X Q h J s s >  $ 5 D r]    A Ea / 
+   U Yi b] f| M@ l ! V (2(  _  Y  	  z ;w  GEr X,'  \ 
+t e `? r` a/~yn     k E G P  c.4Lv<   [O  &  ; Q =nVf H k 4   W  '
+-% Z Q;M  75a L h uUC   _   wwF  j - ^X  T O  v     } *3E   | 5  Z h7m  m? F, aW	T  _  ! y)c<6 T  44 X   f Z     h  c+ p   'f_ H   w 6 	  [W O  V 2u 	X  { x
+  O  c ? < /  ` Z  ;  f ^ E)X  c N   n]BJ _ 2 7    ]      ^    \    > W MP   h ~ 
+  ;RN  C~ | ;     /k S  B  {  L ;O!  2    #?0 ]   l+  $B ~z@ e+e =  %lZS  >  ^  j ` : 1  %   + Spu     G D y  ? q I ? S&8  & ~ DOJ & W  6  	~  Jl  :    $     g  ^   GI   k g   =b   U0'; n   C  m T F Q      Ij+Q N hx s   W > h|y ` D   !      ' $ ~ S ( n     vO >     t   g N  Y G h A     o\ ]r      > R `]  i    C   Q M! 3   - WN x   [ &  sH ' I b  L3  ~ % < } ` N Y / ` Qe| 1   h   ? / ^g/ | Dg7b 2)  w P k3S= ) 2    :6   h    .S <   u   SL!    88: H e r &    `e K N T^  v [ & 1 ]JT  LC ]  t     fi C  b  2 t   H n U  ` AlAw ! + l \,   P r Y A 6Q a M   *  Z + ] m    K Q (d y  [ ? e  & &HgX 1 f   sJ` H  f  d   3 A  1   Nz ct  =  m O bNX  k * j u   ,    !   , Z I  q  /   JB t  c|o SIT  j _     $ H t4%;  o    $&S e  7 ' 
+    k # m 
+ g ^  w 08.2 CI e /.d N 
+  _ s C   j      i ,  - K mG K m BZ Q   l y  v% v @ _ ^ E S   5 B
+3   y ,~ f  { h  o ZY  N  !  	    eWWt QG/p &yh@  0J 0 |   ` DQ ^   m    I  u ~U  zb ' x` ! 8 a m n    S      X_4(  j v  o    lS(  _4 [  [ E n ? = l  t  z w A "  e \ I}E[ A  U A  i} e     V {     V u " ~  K^ ,   +   _   ]   e ; t B   q '' J   v a{   C  E
+  m e y z%  $[0f    # #c  0 )j h S  d  ;   i _}7 ^  {  l 0 ? fa! q  $ b   9<O ' >  A    zP ^l - B T / %     q  X.=O8 i T  I  'wzg  ~  , Y ^  Aq`g    # t {%H k  q 6   Hv3 ^ 5 Zb " d b ; `5 h      !  " $ {    bP   X     Y   0 [Y |  y D  Y  L   ql " nR  1@
+Q4 `
+oE    <!o -        =yw  ] l     : ( _ 7 ?   X\ w   p z  w  r 4 o\y}.  P %  AUI  9 N 	 Cuu    C O  e  W NL     x #  D  % 3y l Z  
\ No newline at end of file
diff --git a/sound/samples/sfx_1/07_smo_custom.aiff b/sound/samples/sfx_1/07_smo_custom.aiff
new file mode 100644
index 0000000..9aea960
--- /dev/null
+++ b/sound/samples/sfx_1/07_smo_custom.aiff
@@ -0,0 +1,221 @@
+FORM  dVAIFFCOMM      2 @       SSND  d0                                                  
+  
+   " Z [aohM)iR~O0 R>!	#$).b0.(d }{J>r 	 \A576
+ >C VVc~7xt Q!% J	5	v
+mvm&a[g.;GPuQK">/ F@sdJnt
++
+g%q,r)# &!&
+%fk 	K:\jNJGWD-G1&")%,w..-*(H)+s*& g
+3riw>'1;M 2?GJYJIE=1\!pmHL	-(LQ-D)Q3	X}.	]"b-7g<,<6|+E!Z"	$hlM=;1BN%SdR[NJOD=2s"T26+h^L1} N;	,	buVK~iD7k%.1
+kj@	07 Y)479806"z_%F%	$#Hf=/#QJTL{D-OTFo&d7>?8"%~9US {v.ad+!4%*&hxr-3]&"3%1?206=v;4,v&./$"KbPc
+
+d ZN&i*D5!g("	&,!A!W0{6%	T$
+,-*	SV8vpI	{ 9NXXAz6256-M;2K>A;5.C0[<&m #K`0U9P[*
+,bv x+$,EccqkWq:qEK^@a~cme^IHI)TTB:~	nz
+4 Q.>@1#& * ZVksJb
+l_ F +_ _u2t-]@M_jUQGI:2 9g.xIa'Zj/= _RJ1x y!(}*&0 
+ &$(Q!u3<2jk5?R'"|=r@!H!-R	iAD~,HqO!Z%>^s'(_-';@U5-+>rRuflITE}x>nS+IQz$I#!9!z"r#z""""!$K Vj\Q?s5^k,{U}
+,"$!,
+E #oM2uOiLa$h
+
+	):S/)Hns-C14//04+GT$!bT	NbOuA+% [Z_ "%
+&(a*Y+*%> &.Ct JUi $	h[{H f.WDK) JM@y=No	Zi h `	4sKPVVj|$R  1?" rXfQ
+~RV 4Y[8lE^k  g%$$k
+o~g+h
+= ^\eX<"J03
+8!
+}sa K4LD]?uM5=$w   $v"w9BX,	
+
+JHM?FG0 M|cu@,. R{t  rZ|&Rot&q` u5H4_ 
+ !E 9(FJ-+4>OvqB 
+ cU( sf7 
+ |<z _n 
+,?)h2t
+Uzrv/jn=@81~Od u/# *l.g@B(w^fS c   f  [ `e+  7t51VT    gRpy  ` O ^8JI|
+=RC` .  >   :   5 5X0<  j M)  B W     [    P =k+Qq$[g5   + 	 R  
+ 0  .  # 4 c a  V  W  <yv
+1
+o	
+,	DD!5S!d
+ZMB
+
+ 5` 
+ Xf+
+ZZ_L^RM	F	=Y4<U l	
+ O}	3x> ?:+AB",$=$  !U*}^	D^b*
+1
+4YDlG1	Qa%5M3m/-.#,"{FfY\9 (v19 -['qy8   K0(X~#]&OLPELW
+! 
+ijg<9b z(		P aLqUSV]vk[%GV n	V@(P-/'*39 ;D1F8BZK3MOOHK@7FyG1II7362/z0f*w$ 
+
+u8jZKE;{]Tq-HP#Z'*F*D$w!'*i()(%&_$#"6nB	6	  4LI[E{ex a@nD4AS3'%8PUk|h\T#s%(),Q.,.0.._*))#J"#!$[	gJEP:9(lXLrbftazu."!j!!s~JAHq
+4=+
+@	k%u>IT4(Kap?iDw2UgFqj!%<()%+)+ )+>,N)l#Hh
+h 	;NTW~z9"#Z$B%&'(3(()*+A+ (",Q:uRo
+	>U6
+ 5
+1}Ab-X^I*(Esf4jeGx")e+**+3+m,4-/122p.#cR\z $'/*,1r91@KV[[U-NK7D?>8;]81&"U2h| q3|v
+0C(7#'2=B<C[?570)[$?I?ceGzB)9HACBBBBE:JMH;&O ?wI&}tVX~^`S["&-3S8rAtNCX=\\EV?OIA"6(u:FJut*
+q0AP8Y^_]WeN&Cx4 
+qen
+&"U`5	1&))+$8J$[>@A 	5&(&
+WzKsA9tdYy$85F|W@aWeAc[RI8?*6*O,X,lA _FI
+(s2k:]>R?:>:1e&a	"
+@T!"e# R-t  "L!  sDq)Tmc6r 'p\Lzhir9Ve-,~ %26@YKWahViVe[rOA*/D!? #T 3g6JuY.= yb D&|-"0v-%3iTxdagWaV
+Xbz!1<DFxC`<2(Y
+7l#'[\OeDt<v	4%g
+1
+@	+yL<m:^}$E3>FOTURLDa;4A+"c?_?9<lNT Y/;[BH/IGy@5() JaI1	;!{" G|&Ke9yBj\#9rKk/<!C@HQIFA/93i,${q=
+n4l&8
+G^^yd |"w).j/.H,+a&!F 5jY&eQW@%! 1~>GM1NL D9],oi^{ x)8 $i(t+--)$OE	gwGtxAkX*,z~	)/59::83H+o 8X49UiLg"  \eHO$?h?
+`yz"&'0\8V=5?=81V(J
+)?8aI"$-'~5i?U9V8 '1-m11.(O&om\+;  "$>#"wMU4C?:p {!LtnwG9S%-9fCJ}PUVTRMD8+b lO%&\[ZMT 
+]W$)C.233w1E/{,'"tI
+h v18eV>n xra}V~8s Z	!
+ V\	5y *[_e,?y!\[cL
+8D	V(3IF(E
+",3662+t"h~|{o_/twg
+&O	q
+O?
+@fT "7+9 	}%v,38;T;:a73A-)%!N{.R;{A60N|`
+Hl!%) +*($!onZ(Y 6  y   
+fB!0%*$/63t6\8873.f'F2WX.61O<$HY*t>
+d	CLiG(o
+:l :UXf_6a
+Wk*T_c$C.8+@GVLQQOKKDx;1]%@~+Co'lf$Tr7	)(#3%&s%"P`,dE(M,2m74% q1>~Aj=+5'l%G-4!if?0$ECu4!V%Lm@'dt <{Ri
+-,$#
+A>	&+85#@;/- S
+	Ugz{~.zzqL4!#"#d's(@asSyIg9&A}wf4
+
+_,0
+T"*0.13h*##qG 'y_U^TMa53/NXE
++
+
+ JVj{sMrs%-)/44242.' 4Zp9Np3C"(<(Z_3A# *A)n Pz	SkV+QNz&	Tn#di[4W<v")% +%(PQ:qv[4[g-7z"xU;L
+P61D4A6DpX !"R!V"T!]FrLDHZ:C	|)!R?N61jNZ=D7Tg	u		Gc
+raS>	=A	
+*K!B""|(#(%kNS|R~H
+Tq!	vR|DuP"S2 ]tow	C:@Xc%(#^ 1s %:p! G
+}Qd]j 3J.h`0F PD	Nu'
+P oki}Q
+`&Y8 6>sbP?##8T
+Nnc.y
+k ?J[Dp[3b3i0i q 4  5#uCR ( {/2
+2 7 \> '7nl W &8`4	! l/x0yV r= ML K(w b*SaR u U8H])P8x d4` xYd < 7}[B XH71 V  Gm/  =  dP@Z!Pfdax=`^v OW  On  h v + 8 n=#lVg *}h0 a?f pM k d! l0G? SS z]t V}!#r13\ Is3WK	)yHOEd3a
+BV 6~
+1MD#=%( t<]DOd6LO#%1/C
+a%B'+-J0A2/!68"W&<k#-4~7y),C&'"oP/ d`ona}(3.,0$!x, *:23!<I
+Y1",2j$q$
+f$C9B>=4F#>
+V3<_!6.)'7 @4qk %)t-{w9	<!0EG8-$3]sq	.wFOPUO#%2rUB	~
+6PU68~
+/P6(,$%e^1mIym
+	;Gigd@w.HVS3H4J	1L:&+`
+? Hv<3pj<f&i=XM\rd\nC8.NY)|#{0?3+&sD_pl~K!&/4:?M7u%#( 
+7Vgi#K0;<44n !Z[66 bKi"9(.> ?y*73&{
+mIh#w$u176B<<B"P$D,e
+ T3MFL+ %3(xW+)eq!9GI<! >am&F0,S;GLA)U/VZ0??13tY<6FC}5E%0vSQ'nb>HUnl<]Z g	}@7*3+)!	c 5fW>$*T
+NZPu5(T	S[6M}KInZqb 	9Utu34	BWY~JK)%	)0%jSCgk *!65*]+{5pb0 W2Q(u"4?<9,u)]!%( O.Do+RnzL#.'#u>z
+'t~
+2]?u
+RK y_4
++&/2,	/T+)	V<<fvg?cc"	#l6@ >S";#' 
+bMXw /%W"'e	0s_
+ u
+a
+ 
+0++$0	d3=Q"fFY5+4by$4j=)Bj$n,00<S ;v3tZ(D(<7bk*S0 s|P	<	%p ]U%
+
+rE
+F9&csb,I&bln-.N' FAz6V;oOE$I(S>Y*/2&R&"!VmDZ34b^$aHK
+%.n %bH@~ xB]F_a^	0*+}46:c(b+ 
+.P	e +: 1htW#K	)r	6 ](b$=W*@eG4E?2SZ)/;<.%45()0,$K)7g8	; us5vVM*an.
+,X<ko)^3ts E`N-dTOc :; b)!(@4^	/
+j73MGtj|=
+xz%a`H
+Wv
+"2D4!q~VL;
+6;Z
+!G+x`b^bBN : W
+Tu( A`= &y8
+rST8 bb
+ [ Jg   4EQ		L	m.c
+9_H = p 
+* , H/1k /] @|= /w/ 1w |}a+[lX 9DMW2ni7W?})YJ\A3'	_\zV>\ 4=uB%5 		2%d 4.
+	
+		rx	\
+	q
+\	W@0 xN
+
+icI
+ xP
+v oFe k38i7v	
+fS>	]w
+
+;S>(G	^iTkVNa}3ib
+/
+/ i
+
+* p 6	
+d 9+G	4		n:NjlA_~?^'eb :6
+m&]F<% lFyMaZ k'*L3 },/ DT/D>01J Jf +;^  Y
+'T   - 	b{?xt9' qS q "u   I J   0 _s %   u H hq [    Z d $ " H 4)Io = i & <  	 W / R N  `    r &   ! 9 ? Fg > Q     K   ( 	 o .    O s a x r u   f | / 9  R b + z !  & O  R  D & 	  2  
+   % F 3 * 
+     8 . O W  :  G e           8  (    -  (   !  E R q \ # : 5   7 I M    - . A 4   '  5 8  - 4 # #   	 "    ! 1  # 0 "     ,u J M      ^ = & ? b N % 5  1 d V 4r  1 L / <      8 6 P    ,   
+n .   % O '  	   b '  = 4 8 (  R 5  OW  e Q 	 )  0 J o _ V X - / 
+ D    $ H L z V   1 Y H C v   <   # ! / y y RNt # H B g ^    R t 7 $ %gE  a M M 5       + P  4 K F r G1 - h  B 5   1g 3    9 _ e  ; M x3s +  
+ + L   7 Y    h   
+ D d K : ,   LN S U [ 6   6 -  o 	{   z  \ -  4   Q     V U $ r iQ \0  (DXl'=8SO# o zfBXp
+:6r 	=BW/0o/RY P-.7EE$)co \R8' i5 $G lzs  g 3/vzA+W1zg{
+cLti6en 	px	6`	)[BY/\ `Z ;x:n"
+| Pv
+2 *% ]	:	O&9?S Y0 [5LVDi	lL<[d=#i i Aq66spQ::9tBv0!3Z
+I)z
+ ttsP\Qb oBthG&.	3a09O,]+ OIO  QE{+.	X B 
+AF'0;( '{PCc8= oVj[uga); j"cUgW/
+Y Y	K}&"5weN0	mC p :|",^X A	| y%
+;Gk E6$	rC|P?u O_oPg3 = mnVpZ  S` )  ;pBV}i >Jft  UuST>g d/C<  r<~Q``w9 l YW_ ~{	R=  NRdP nJ |cS A BI * Sio{eO   A  
+  M a `u&Q.4 th%sy;{653   \ ]	I	`  S*HHAe'de
+
+3^ 0?i	2
+-
+HZ[BrA>|1 
+ .Om,/L
+ 7HEwHEN 
+R	P+{
+,QHV Q3	'?
+<h  	'2	U|/	}TH Q cYJOL	pgR	u=um.\
+OXa~	
+b BMVt`
+lE'U^Fg]_!Sx*DB3u6S
+M _ 8_BO/b?qln7L
+m4 O/g^^[}
+23HGnC!4i#u
+	9 Tq8B,Umc3}8lA q\  	RkcV
+E=!_`#F	1PHu^e 0E N	bXt6kI 	t 	) !tRle{s2_Yk$<b@J|S
+?-Z'HM  _KGk`8)?K'    JRB6L 7
+G
+kGu QR @& Q+!"9|+J4M r Q y_V9Ij	'		hq92;
+b
+)\  O4puw k5s~{e=8^Z	G
+DTHt?^J.B \w		gtrJ~)M7|}UDTr16 S'cGUwj
+)Pl_`w$  K~{\j W ps@Q^+. 6s  L }pF+NvE| x@^h|t OChe}):+1@4Z
+R _
+1M,V Un?l	t	=x\(p[gO1h </|Mb Rj'8 5*/dy 8.8':A_=! J	{
+	!U[$3FH(04 p	<*1(o , ] Tjr 	9FS"Isx xjWICxN/ g XH &
+xT
+7-	U-	 azQ	B
+{	`8M:}JI|>~XOu w cz/B6LscUi=v \XLz{.`Ns$( 2k.',  s cMH:KQ    ,S-S ]^ [r #a
+K) QC, A 1 Yex  R Ao = }*  GJ?s*a4 \o#,6PlO clh6 @0a ],.K\ u<?_ ^Du  h}{X    xHc  y	qo  o  \%#  )5)S  K 3 C; Qc ; '  5r)@=>O "p   jhL 6 ?C1	 P01` OF 2`3(~y 1'Yu{ p E) De-k 	nE  e$W]=I)*Dw XYoOgGg  *{4i P+	\9,R*N95k?ey8
+	 q""exD`D;
+%4
+	P|(U
+z
+zi:m~U6Z [,, 5 vxL
+O 2jia 	 cEpw:}	5
+ I F  Z C7 B
+\ u^w 4	k!U	OB"4kP .,ce4   Z^.,
+ 9&G-&jqr0  iJ^%G
+#Yqg$Ui]^$  JA	axf;%*{
+7?,0 z iH ]_7F2 	y:u	\lc%:PO`-oua1h a
+@ |"@1 >muZvl7 JxwpY <Tlhb  [cf n  ?;aYw\lq i65 lsA _bk  V J% u   W 8 d* :  =i = S ] : Gm2nP ~C+LF _  &  x MY  ;t}9 M V   i  f N n   l&+O  YG0 \ f s 6 vMo  l p  F !twut   o nl f [(   7  3  p/ g : Y k s U  K b^ @   P M f`   h   ?R: 4  O  b [  : `  E W   &   y ; ' X ] +  B  -       *  [   h : e  I    1   j   2  d  89 V ! 1 g ; \  B D d  $ < ` | Z`  S h RX     J -    M B = T 0  . Z q     "   ]       / C  '  7   2          1  !         +    8 C   	  % 	            -     	         (         0  .         O Z    &      L  '    ( Z 7   l L   . Y  , 7 6 !    > =   J   %  4 T , /~   8 o >     / 0 # [ T @      .    + = G "    	 	 &   >  - .  M Q    ( W $   # .b a ) .     ; O )     " Z `  ]  L   Y [  :     1  A ! 0   d ? " $k 2 ,  .     @ @    x $ 0 / 6 o * # 1 !  ' & " ,  )  #  Q 7 Z 0  b 1 C A " !  9 2  D -    V C      0
\ No newline at end of file
diff --git a/sound/samples/sfx_1/08_smo_custom.aiff b/sound/samples/sfx_1/08_smo_custom.aiff
new file mode 100644
index 0000000..4d6e51a
--- /dev/null
+++ b/sound/samples/sfx_1/08_smo_custom.aiff
@@ -0,0 +1,673 @@
+FORM ,AIFFCOMM      - @       SSND ,b               0 R s g t  | u     b \  h q   F   W  9#'J   X C  S 
+  ;    v   0Wi;tX/ 0 -<"W?YM:H
+ W
+1& 6pXU)
+ l   k   z  \h@ }b   f+z~N  X7S-|# CXwct. & N5GE$cG S	
+.x	$w n<}e}dQnlc`-tV'H M ,<;< r  I4rIh%<		O>	
+0PJHS}":{>j
+Y1~
+
+hi
+i( b/M4v*4#Gl9	4s\(5(?	+
+	
+<	{W2C3( Z ~}KM$?&<W1*N	Qj.
+&[#X##Vdw.&'QCk+c\ /M	V	1&-V@C[p&r~WJ/ NPZk>2o,tbIbvM iI ?l&oLL)jKO e4Sd8%1	;K7.To	bX(Q4"46:-7'k{&G:m!:b3 eUi^cLQ2}t7D
+>Jq$52)6N/!VCM	g=@Kv/<IRt;0GhKl/};('GK/(M^u
+$6 Y	{kf! inun	n QL" :F
+&
+nMhy8   Z#r bL%-]_ryToB@d,xZD "^5/0/])Z1#82B@I7
+2_3n|!zA_hvgS@d!
+rv	41o(%"=g!n6,j&6nE7z{&Chzd;D%[>>&5:(@jL6gX@:
+E([ o&F+	h'w*j	FKv O	d'FEe* ,d_P.T<R4 d#T;nZ$C4>hu36 W,>wK*|P-->(PY"R!93X?'|$>%q#$A'%%K6)16 bL5}`+jUr9suR*?@M2)p !] |]Ml M!kn
+[ 7P"{	cS]8g!M+E{|
+I+&eJ	r	(?v3y()vFw
+=B., $X	
+-;$*otk#	20!_Q`F?Vd.r wD<Y@cPjDZ{(.),  ~t:o+fMe/"_GQS],*o,-b%.H>s  TW<
+		E
+ZY2&$T(}tE'pJ/giw<.I(ze x{A
+%+H&&#$	He*B")61.eFP-iHt& {|N#bj/ 7`
+ >	K$"	(0@;g65 +w$#	O_fn+$W7F'/	{aQJ#'<
+f/w	,'x&m!.&e
+@&;	,r3X*#Qkv s1YY56i(8v<h-p04%c
+P|nYiE	y
+B
+H 5M
+'-(#&
+o%OR#~
+kt/*}Go/
+T]!c6J/R<<F,y!WD;PXK&	-=,	wU0G3FCj=	,R6#'*Er	L
+6' /[a5VWhO2
+& -(/-#j }%+c!j{4
+qU~.^5n
+ZB:&X  (,d	U@8g8TsNVo394
+QB. rIqE`fo6
+\$}#gk#LN$bFKv$6-6@X:;(@2s5E Do!0m	)q {_?	B(oi&/#j H ty(u
+ `	J,*Mc:*	!8U5s_%+YK 	Y	88;)~4)0W!E
+v%m%~FfecKG	
+OqLiv Q	K
+z 
+
++	-g),/#xzd`*xvv"G/\	vxR&*)\V.^xjG s]-^G.C0Fa 
+ iZ;o h7@*#QS 
+55!)Qj,QQ<N0,>s!/)^?.7g#i+.S,LoLq:a'D([Qup7n~	'wH  D+Z>
+dUP$	4Jw,
+Q(8'}x
+tWn*	*%')P #tt`T!NzeOg,W	w).Vr_<,5$j[)3?1'!U<96@;~\/b _4"AL_3u*SRD[? Ty%4_0-/=w j&G&Z4r_ %M5	%`AU a4 $.>/) fA
+~WFd@tR0";Kmppz(pu 	Y3	.3\T	'
+Swt;". 	1<6$Sj<}D4nMvH!c.3T|B=<TGE
+\GR ~%x2j-!WS>
+	2gQ-OKz3>;zPm~
+BN$jb) 4.
+Ni>"BGmiy@a2[ lP
+ (R[I:).Q|FI]%g
+
+mrs'!DB #m'	4Oo	?T
+(XON%
+aeBN?Bq*Lpn^"K c/c{	]'	0 E		 LU
+
+	(,W !,0+lp1}S
+1 ,"2gd6:ilA#5"&#" ]&5+#yd"$i
+
+W
+vm(
+'88^[ -59t D ]3'T
+
+'*Xc@s vD0 Vt@c*LI2
+p)h(()-0	;Op 	I ZN1
+zj2; l}$(vb`o!& %)L
+;:'S5_||aIS	<`-'
+v7> {'/;/$0H)I	!^h5Ma
+#o2A%e( N%=f
+ip	g%][bL<Aj57)& 	r@{
+d@)kL&.$kk] p%~s m 0
+79[&	L!+wy*rX`4? ej?8"$!"$@*`/)+^[B-5}l	]Tw%NQ]]b`s1
+Z+B+q*})2L}k?Dm
+q6b|m
+S 1 
+Eef9"		&O4	E.L \@	8"/"vGVpFo	tjV`B|In&JKFT+
+6V3 ^cI-M1+Gw?elML*po[-]Q%a4xEZ%a`s
+3!Q5  A )A>,jj _%[k3ne4J"9!A
+t1#-*[c+0'/x 'w3g02X."{+
+z  'F3{'$Jq 	V$"S mCg'bN5}X YaZ1!7]m;k#R$l#>+=TuFg
+=PR"k ;/y%OeOn H
+%*v	.H%hq	kO0rnS}9tLA o,	vG!97__+ o<-#n 0v {*#.MiOkMB&U
+	.+;J46*#IH
+K `?nx xe6x0 {CD%}/qkz,Yk^	}
+
+b+,"Z."	N6
+v 
+%2
+}RQ?2OP g#hp
+uQQg_?C32$Ho)	eI, %
+
+
+]( "EAA6H[6h
+ Mo_ EMLF,`a	QB5!
+~:Yj(/M&\c[Ub#q
+P(U[l[Lox	7sR nbJ~:a"  3\/.mv;T>M&7	p[Yt oB-+.l>> 	2E	
+c<8IB/G4 gd,b(<B#;LUtCIG9S~iM|u'r #v"-`g36(U7 v.ZO.9V
+w	 .:
+[
+
+FiQv-i[kK/ 	A1w!sYjAz Tia % sswk9SB?[&A29 '[|[y= wI~,v\IfU'$).	]-O6[KR}	OJj/q,n JF%% 	QbAoT]!dZM,@o 81@b(eY	RSIS	%O"?KmYls^eEFrCp5\_>@Y	%U52 ajnf\ tN	`	&k iK<
+wQ3!	H
+')x|MGaM`5!yY&l_E } 1PMOsQs#R*]d.81$!*b*7V+i(@Tm:gM;Vipk(XU9 DB\_&f&H)&#!&0=,##$ tEH	5i0m:.HlYN,yr[7C1-#P&u!(4! ?C _
+k{sO\  <F#_#SZ 1x826 (L CK^'&S!"K%%%2*+,A &\P
+O- L{HR/s]S].k%|Y_^Gsr I5f
+{U$_]M&"v&w)d$l#b+1b'\#H i
+1-
+%?A}:~d
+rG5a&LpLgp	C;I""F7"#!Y-  yKQFY}qg04BZ\\y=V) [aMzEp)e,um^vmp		Ol^!n !'0# %*%.'-"*y Gz5bZ /J>tT Q_ s9g	Il!'d).-f'&','w*&B3[wc>p  sSM y&hE _n#Q nL4{s:6;#%%d%.!A% #*Uu/	/W[07~w8Qar)2v !7
+:w|Cid%(o!.eL !$c	?
+,4 h%:$@? n~UHZ_/*w./I <|`k;!(!#D ;#tp?		Fp.L<c*3CEd6}b$i&]YK 3uk%|  	=bklb$	@l=|Ij-H@sdYPNi! K8?V! eE
+]
+~7dQ6|?Kn9X7onOH7.4qx*yjL	q'E 6!+C#
+k	76n~(OpD&P}g	U_	
+	
+_lb'
+A(I	a -E+c< TH	MV,oC.h:kV?	UE|L4 /:
+o_ K>L Bx 		
+d\1
+g`
+$K	
+
+Il!Zfnq 3}?7'WU4 eO-6R33l		dy,l
+&O
+.s 	8RCGYb\i[Qs.@N5
+&hATaII8#M$aO-r]HwX
+ CoD_!%7WW@TX{v8vW!#2-,+%E%)-+(4'5$^>x/
+cFU
+ mb9/c:a|
+ck]M4I+-2A(+,17D=';9J;_:^5\-%{ ui!!,/J`"8}:b' FhH7LH5R ;xW"!u!$,$%0&/(0C3Q35-4R34@41,& VNq0B	4n.BkFaR'<T^8dQV }#|"T"<!	 "v!w S!C%")*@%" W
+,3Y?+^r"/.LcA#
+OBm6$*!-WLWcN_e^Q?
+;	@	6< m)Qg]7j]g "5| 		esl4HzJ)E=
+a
+
+\()%<|q1Oi3m8c"3+!i`!xX	|Ul 
+2 V\.EG]_\+0i6	=
+1h{}/@bt(b@_sN	b }IAm>GMX!o{N"".Bq! mjHrM}1B xr  vR|Vw	 R1&fxJb(6}z@gTT9 u^>R:t&m"%5#B!d"sW)	AvZM?! KC"3$/W
+
+-Yg/^!  "'%u&\!*5LI_\yH=Zsw{%m$!"Y"$"({ ^!l  y gs	4	I	 8b <]4t)V
+EFh*7+nvdvi"# e#*%6"Wi )i4wqt[lK
+X
+Vxeqcts6
+&!/"6#'x'e%&*,)%%%$!/P4,	0~ ,xp1~LY.xPP	WkmR$$R!y$#"%$s 5zfy
+	!yie_cX-hE|mUzz ?_Qws]"Wh?D.S
+c HD'I1z5	G	zb{K	3
+5M6b
++gl\	{	3 n Xh
+tT0|1oLb8CE 6| y7%{D  v	K
+I	o[
+q-s	,
+*
+
+dy
+9X+ ##
+>RK{J@Xa)w #~$$s"(#5B5
+33p>i@-1"=a=lel4T5N u<kz#*].-0l/z+)(R'&# ]Kj]Fi
+
+a6RQoJM-|w|;bR]MYW )Q
+Z&,/-)<%#"p!q"j#"1!K|$<fNv Ed\U5E- f8 P 4s6I=W
+x		S[ 2s|z0QW9X/[2;uZ9A
+`	I
+ Y
+
+h-Q	Y
+r	/*g Fp+-4.zS7 \  fDw~d1;TE~kki;
+
+[
+u 3 jD'U] RujD%-JC 
+2 lBz6
+VuM)S}}znAK/`g"x a^eWxI}rdi0YP(V	
+
+(rG?.vWjxiK0yn&
+ aXN.4.oN ['=
+G*(GP2p.Y@pz.	E
+pT2]'6s D^
+MW	|Xf0+>r_  >gI:2=YSm9V#	-# m9=r6O=[:nN+S3=>'4) ^F
+%i]d8-8u"f@
+>Zx(PlQHpqw~vqoMK- |J=`p			
+
+	
+J	c	o "s	/	B=P*d*hu
+7$@A C _kzQ i	qI|sW4(g-)V`ci7Is|ikoQc	/c0
+]~
+7`
+f3kW(sLuE>6if%*(	_oAO
+e-l	r	 lj[p_3p,P
+9v,>eU
+x0GA	
+:G?\X
+ v(qX^G#~<"p}}i;
+	
+		G	iG	%49<cEb # $$		SX  y >msR`=Y")aI: -2O#	jE
+(~T}L>n
++)uM"%^ef?qM_ :M3 # ~-K k#$q" EYm3:55c,<NT zl4l%:{e!%(^'h'?'$"8+0![.d0S	*3(^?w<.@>+
+bDxL
+ %H(L)k)=*-'"cK$TT y,1
+'W0@t#	79
+
+<($1U!*^9@g Sp3zIfiZMvAYC
+T(PU=33&XT:nM:?	V>[Q| "$$!"!a	+m1idQSqdQ(T qe\g9C"$P&%$$D#$ #!
+(< H.t7DP)F1G Q
+~G0AT !Y#$$J$o##!hxy
+	KJfzDHI*xX'7VX|&.o	f "#"$6 	BW
+ReRG~EDC^k?E'	Pm
+@\L(f1BP;;f%ki>7yC_?o8*Igial	ek/-O	
+'
+zJpuLa%,z-p  kFx L v*3_(, -Y^%#QQ5+ % $ |>	h[> HdlmL
+	C/ k0>(yag	 f4wp	0<	[58'
+M Y	 fF.Ji}#x*wr/@39ETE
+
+%kP txk*-
+EEkjebF"[Z>EpO E  ^0P34
+U	g
+,	
+)ODc,hN	Cl]`"xyH
+{b# 1#0	H&",vq?-+O*z+	zDP _(0~lL=4X3|7/,7!'w18,u
+w(w
+xJ9FXYdx:2l!}2<X($QJS#>S>u<'NbS
+=/o01/26*
+,-#n} 0gAT%/()!S"$$..2E9N08"1V<aJ411q.w2;6! 3.? J!o0a~~K4 _S>	j$1%$.C4J4&T@=A.*0334.<&.?W
+">_gE	uMr<g. 63z4NJ4,.0)Y$D'(wA[5*aqXn1nfh$+rP(v G25%;.(4QA<$-'*)W !n
+'T;/{G,SvF[2AHL|
+V--&A'G8UK??A:4	4g,xF$@<?492X ]Od
+O&Rz(D
+xJm-&!Gz;D0nMO$]a4/N39#(|_AUiJ\E&	1V	;"E22'*A(*{)!+a*}.B4{vxuK%o0+t			0D4];.'']Kdme-F8383+@-_,	Ad`jOqoc.KnZgb0 9|!*'$%A~bfN;(99S57<4+00;)u=gN[Kf Zd
+;zYc }7PN!;5AgD83K94:(G f9aHmsA\R7AqO Pl	4(?9 )u#"1"(o V pbpe];f/z}j9xXk
+$m!$O>~Ie 7x-JMQHA;M.e);NC&3#R+]^gl*b*4_H1KJ{/
+F!*Q)NYK?U=%8//;C<e293#5'io@IwVJ,	|TK~O	I Qd H
+w6NK?:6=/5FOF786;!1|~r2
+g	qqxYz?AkJ H
+	Ypu#""r?#O643)j+46F57;o6++3/BY Q^
+WeAGacW[BTQ$;|2}:F*y.- =1IJNLNB9{@sKF51y<:% 0RpBYQc	2I+z0.=K2j*O7I6F75 @EABG@A.3{3DEK1iVv
+4QTkrI7-%yc[\*2	 8 g,<4-d')%/7EPDf623-"*78FC3	7	?11*Ve4N6S	BFfW.Dm ?a /G^(#Q23d#\(R8{=>=5&.+EA	-h}xT>3^k )@R	LtWwd!sxl(`34j',;@F(3'h9'RXPJwG=<.2HL)aKm r+8N'dPuzb8C52G2VG24VCNSX'TD4)3JAGi0R
+%E@G2h"Sk,T! W*
+ &/  6d1""'>9DDA15(+@RKFs"%REav\>L!#v
+8,$B!u<E- 2+:5A3MCKJ2 +@?8R!7%Pv{*oh*
+~$	{Z-(BbR%@1r27'3,ClHn/e5JR\RUA!e?M05C/	4!j y-uKHKK[p,J*!ni#4I3" :+SM5N(-6R?RaY>N2Z?D,\X
+m8ehJSV 2V+8Vgo&*(l=2>]'3ACMA(s!8"L@Ck'/C$4vH-}8_C64Tm	joK.X!$ sX+6("/A<D4R']0Ar:bru0[0eGcx`RZ{'4Y#	u%03^');^@/^&-:OEOFJ5%<.EmGZ+WSpj^f0'o'9(h(L%dpO,;("*n!X$G8D9)'*9ABGJX=-/;?D0v-A+KNW!%D  I(*!w4N0,/w;zF}L@.+.ETE&5-p.l=5p[*E!kxw	rDV#( K"o)*X08;>k1C%%)A19(RK{	8xQ>_)\Xw
+{ y BX YhC'j1)z)1'M#\*8LCS*C ,+o:<)#U-=UWPC"/*Z	8L *%&'j2-&-:i>:?|EG|;f+,=OB0 ^_kqhh-f[M_8@fR _~	\' ?(;KP\P:4B@G9g"~a:G@HT@w
+)3YK1isnC@"f&d#)-S4<6${":)"g\.>v@;PR-B _&)	J2R#$%m_* <SB6@(*3M-t
+vohfRS	O6JTR#1i&03C6?B9,..88&*{;%-z/r{g %\9
+,	`
+/.CN:G]849;2'( \	k0}{~bl_
+Hn_dry|
+o	 ^'5-8r@;/*-, oQO4	|k(2sDSzPM7A)?KE %2Y=8)!$&*pGH,aKZ
+C*<re/ "+/4e99V3/1T1*GsB>Mw0N'Gl)t	;e
+a
+1o&./8;4r,N'#,N
+	O %g~M cwYfCC4zE1xj!f'v)#%"k q@>qv6Oyv_^	rT|,ta 
+ /r<@
+	
+N&.59X60`,)#A
+d ?yP9	%.q&JKgC$*-B-5+*_(0$;gm~
+xyGP>v0hQ( 'S*%>$v0772("@!""""!'7cI@F;Lf8}gmF*CEu	*
+a#}+,1(x*35,4.l5!P07&a\Eda }rF(U|vn^sp?Uj	
+u 	QipHb
+omj@QK/ e 7
+WO, #Z)<,+S'}#|o/ q@=w|n/n":HeyP ,43q-&"[!~"# 'J2W }QWgXh%,PsA#Ph? $#"%$%g#%W
+: mBPVsxx:
+|].~7n, -88o2$(WxX2q:U,%]B  "1W1X#%%=QoJ:8X4:c6)]cp[Yoafxv]~2b=0Sf2"w	[M!U"!!zC	
+bg$/ l<W`z=d W9bz5.Ye'-c'[ c)snd*OW*Vs/&	#3 YU%A - r/74u.'&.c8!69) XRBqkj5+`zlF	!r]v*[y %("A"H8X.1/Ojz< X
+%Z2^O	**Y>o_%a!Ny9Si "02l){rhjt
+@lrA~Jc.')+6;4`~!45Txkv [
+k*hF	R!?R"1R1!9I[)M!>"_${0=2&kBW?BB6.GlgL 	[!$)*	q
+ >$4]IQI	@JA@5'>O<f[ANG. `Xl  +UXWe.@&G&v!! %& !#C+^{ >qvE.ef,vDq(1=%?~H< 3b
+
+~usD: w Mw3}%s#5"n qAwe, 
+ j!Z Q_q$X(r#t(2}.E%%V%Bb>"rK%A'(^$ |#Y-)J/BKG>aEp510K| _fx &)9y%
+Es;1BC2hy'&d_<:z%3x	=?vl0[<g	 + '+ ]8/?b7	f>	T, \	
+h:%5?)|&b((+qQj6m
+,F%$6 Lg*99[j~%!;	vA5=x`	PH@q 	/f ! i	7
+&"`Abul yBBXy	Pcm!-2(O$'B)M%s+n19wfC9R,"n~/3V<A!4(8a2LsA	kM
+3xB"	<,{`{IAC(7i3+&O%MuWET(@O&n)# ")-+' #3
+I0&w];
+U3[ &a)s-M!"~&0y1,i4*'84	6#D2EC`&;Yg"	m/|I#"+sQeT
+	=idvFO"6	g2}iJ8
+KbA!J$'*'#&3&KRvpt+DKaW>`A4L^WP!  4	 :#(_
+W	 V/
+pxJg !{L8#0+uqt
+	'2g#
+l	h\T~	 3f
+U1& %\zX#V	Pe\ZW^F$_!;z	c>3KC~=z8 Y] 6
+ 8b	n
+=qhB}6(tD$hr}H>Dg#/4J0!R~?&0/A*#]>vJL?,I|:?qh	1,"8:<X>5g?2Y9Wz&m
+HY4OH2e~S?R; q(& Jp8*"TNr}1RQI= C)~
+Y CQx.\87
+t$4wI"(*U^
+
+=m7Ko	 ^?6%ee5s6	m#T'g!+%etQB}a	wl^N'l7CV~08XWQGkN5&	
+ x FZNU?2Eu7 sCc,3l#ryzpZ\'t2	
+Sg?V`RcZC o_IpALK$!xk(jE*3w)	 c$yo3}}gZTK g 1(w4 !#"pU'/+l H{_ 	Nm	
+yW)EDJ}FDu|?bV$j3.DPmlF=OY	jf	zzG&x?/
+	VX%*%o >F*+'#<jy@|
+
+W%5j5u"IX&*.Rf	 -|(
+V-Ps) xis3T6x`"V 9Yi*,K
+s G?P>	OoJM~O/t%!AOk'@Rp
+	v
+B<-#%\iUtGI H5<	U	me rwH=$<{	
+M $$n`	?${%|D*$%UMDE	UHCP=iaU8).ra}xTq1mb	)Q-?	b($&6}Asw	l}@
+1!%0!p"G0:Ju	 {{7oq]qPUG[bOx?
+K%=&Dv 	j'`	E*"y	^  ~ S"#*D_5Jn{ .[E
+n7 gk"|S G|q&+1,(.`.ZgHi/	R7}9"i +	`y1X\1KKu	S 	I`R~jm	(
+$VBTt )X
+
+5 Zm|!E,>KC)[w%&1BX= mj
+4+P\_$Z@  )"wjI<GVz|)
+*-
+6 t
+X+#ey	`/^@!GS~g v5(C/+ }zeB
+NvCGR_y^; 7KND>bv{ $VM~fC-	[m7	
+dE%-&vqL*#9lwg)8gua$#q$)(TD#[	m$%VsO VSv H9,J:H		!	kw$93Y1 5Y/"5qO 
+
+
+' r xYe{*$)nr'
+!xbq<U k  MKi5Uo_. "Ag! Yx t~!\
+Pk
+}XU4|>l 
+	G9ADM ?p;~d'N_kP-_HH`.2RJ WM3	G8u5C~l
+Z"#A<fqwT=! LC
+
+.d_<9		QVTQIK D4~;A r<4oz#*&&
+/kHp `WW.]y	]<m%vkpd ?&HuOX	6{Xo$Zf{85Q4	xg\nSTaM97t dw	7$LSz6/ PO
+Tbyk>.GE^(p)iC^t
+4mZ"
+( z|Asc^	0p	~:	P>"	'^#m2 Ia
+l$:sI^d"fk	ANxz	
+;Z;c	2y|]!yt"tHE	,O lOEXwP=761V		{'!	-ak~ PP-w%(	' &= 4dFc8 eqa'ci  R<P
+	$2DL#j	S`	n`Yt!
+7:o/;3 ; !L  l T= 
+	TJ	n
+4	Ll#=owUHr*E'   WC v:\	|	 l}_7NI5k QH	
+Hqi
+	-\%GX	DV
+(
+  7 ;  (693Gv
+B I^]X&w:|8|E >#J 6 5tM	1  ag	
+9(SS.gp()y:pNpS[ \w2 i'5n&[/|MSt# lA @Z N*  T~ <	n]{G;& %0G
+	,	e	?II| ^b.<-oD9Nl		m k . t%	[w\o`^f7a$
+U
+9:
+Ak
+7?(9a9 |,xN
+	3Fwx
+-	y\qLLS<9$F" 
+NU5 &$%Y3.
+rX
+
+}Qr5P3a0?yTv%#	9{NSca1UZN7W.C{e<%Quc  ],
+ 0
+8?	7 S*DN D. !"CD_:\a
+ %%# ;!F&-)($ Amvm2\N)OBmBf-f P);*	0bTtoz1W!$Y  [K}]mt)
+D 1%-	s@n@	=QH#$tP`of7")f]%&0VA	 =sx:=
+"5%"y	($
+}N)>x6 S_l9^#7!%W!S
+}c !eg0JxE"')
+CC.2eu={HUjFCn#Y?A" Z&LRZ		G@
+2kUWVz t'u65@e(4]s	N,	@
+a'@"A'[X2,^Z&>)F7
+;#Ft
+[7(Le^1%]& -""*k f1x"t!
+QAQ'Oj9xeD	SCVJb	Q# "c4}sk)>(zO
+m#6\K ^K02;J	2('@,vl!ag#%,27=^/r H:"&alpJWw*.!5Q.+E/mDhm.
+:vq
+Gt8C 1}KWH_0D+CnuE	<u=H [4]mM#.t#48A+~nEm?BSO
+R:@	4MGC1??	*
+ Y15+\ Cm(oI	Y 9|'FO-Lib#;:90=Sw$3
+]%Vk	Y/?	5Z9)"%zqItTm /XEESt!(tx"r(qK0d~ %
+on"
+<ZoS}1au.m\A{Y(CrNw#e"83 
+HT[	8I%
+OziTO5DhfY%:,eA(t)=I=ElTnf ci:ek.&"9'> N-|5I  o aSMnLgx"a|'>41G#P	V< i".2!,	2'(	J~ ~x\~>(;/4a 
+>S
+ZI
+lvH%E
+A@)7r'A&G
+#au0J7o
+`aal119 ?!q'	$-6"4x<Qr;	 O u5#7.( #U81KBqOY_4B" ig3{ne,(/"TF+k5jN~aE).C.Pna	 '<
+="52*/W =$.j2g>*& Lf
+JPTY
+G
++hMO
+	\&,O!;W
+E4MC#L R&ITu
+J#dS_:_	z$f^y9{	aH"d G f A,J#42{m"[3]WN*"C	\nr.!'5?(\%Q#  %^#;x	$X#e`2{	+;	/#w"0Jta GF!|BF6
+:A($X $;~
+x3(Ro:'oCU%84
+}f[2!t@iL4:(Q /% as&Z~.x&4aE	WZ^h= AR&!%"&'.x<"\RLzlq?Y'!$S9<K?'*$d %s%)Zbw/"Gse  \l4Z%//a+)2"&E8\-7'SZH^rc/ i3}/+FJ1W v[.}nwM-)qWW|V "0 !, 964M)0*I>su|$aMuU!$
+P<,5-#X,K>`>j+d$(XH-G IR-L	y)#+
+O-Gj5"{C!
+.2huV)*(1(.N4783!<H~!kUpgv)9 N3. JMHl8LF6U!/o)H$5'ODZ)*2/38[5(U!)%xKkw!>,
+0
+-itN79Y~#v^c	X D?f+(9
+) L"#qg	#"4v{M9B=:5E 	k sNWfU(Y`Vc,'&!qGS~;Yr"+&F"+%yYgPN%%O
+CW k 
+'~:8/)~ !
+8m1W`Z6'
+q="II!%k&a/09pQ)(UlB."1#ER)J2!1).!$p )%T8
+v~'*tsn+>tS@$R*DSk)c`Bd)_/# G)q,N"r&G*d		!N6Tad.4b
+	Y\wNZ)6*7%"/:$vsE.(P#Y'\z)~D8&!
+VY"0K1$S6$0$x 7r["fPegqi[
+yNo?R A\z_s\%j5^
+ YrV&-^?.:X4-.050%  JL\s$  .W8RBZ#r`"J(!fJ)'( *6st,[n*ae.eJ/224>%C	|{
+L$(6
+[B1 o G$#%j"pMB |'C##.x2X%$E	w\uN~ u`#<;'$&B:9:"+hg+* wT7fx. H6VP+<;m_04)GZd?D`G	9=-PC%SI
+&E N o L	pC&^8i~
+e !0K \~hQt".q%fh
+aBd>E^_4 4
+("x 	|!qm ~(o4,%}%*MMc
+Cfq/M h5s/h8>"<P{F+j/<997v89>2**)jZ1@?J U.%yMU.x%wG\	I-	fso`bj
+T=FN3L2F:	,
+9z d,(1L)@R
+P
+ *Q tn.JHywF
+juNh<W
+g!{	xB=&E	{"6&)].145=/6#d#v[xy!Cthr+&
+U\6]JjykyT$:9 Xyg7rB||  ok9 ?01LEQ_ %9#!	ie":1Uv$(y Di:W2xJ@NsS~#xe6R2+o~D0VqO2	|JT_$y]7LZ? ?Em< `!W	KklSQOS*	tjy_p(%!$0 Fn#7dkwf jLF\^u Td
+T3`Y	Q;
+*O!*`/:0H,V"#H Z_hrmwhf OV:Cb P(vriu
+F .w:WKI@ N
+`')_kG)-[.	V
+	,
+~~ J	{e	E$\	|J.Nn^8TP:4@S-@Ao$'(r% kp.hPw*g2	m  3DpyG !fiMllBcN+'[
+	3F @]d
+	aNt	2*@$)jqUM4  s 7M3 /.	|
+#DNsh\i		/Thk=e W0RDNPjkD&	LS dR $m]s?;6 6vJ6  {  C
+[r
+
+o
+	
+\x% (B `| S>kG!:%K H`GJ,#[p}qd
+m*3Kf`#8"S4U#z ;	 <yP}%2^yi;+@MqL{iC v	NH$,2 iX2MA; H9J 
+^,	{!,b=}m;, _ yJ1
+	H=
+2	r2 Y~az;<r\3 QBy	yqW~" 8	]4sYBa{~um 1N			Pl`W7bo5u-m/1vgNiQ	H\>ZKkjBin! yg -SRqE%k*g+/3Q'[RmW
+4g 4*
+ra(n)7\"]%=nd"'(%'S4A1^d_<dkI<3j+
+	'	%3Fk	{
+*fK.Z61%*9gC:9$+*48]
+	\		'&WG;d8bp	 Pt! O$!)%0%.jz aD* ~^
+
+]MUpD/Li_'90 9N9?$y/rGuT>[ ~!P"`V$.&]!VL0
+
+68o#!wg,Y/BGt9K-F8,3;!+fCrB	0*m34Z#(lz4&nciJ1 !/e0$%)!B(('b"  XadMJ5+*v-+e22+\c !6
+-tdS	,Qd!-u]0/>D*'
+o
+(dK6	+	!fl!
+	"} '\;W
+K[_$)%(+0@(FA@:'~A%Wv+LwQG.i
+^ERfdfa;  bL29 :d6&Yt>R+^)HHS'8>88>6=/+ x	#P.>|K	]
+cV/[3):?Q
+*H,5
+ -H ~ L&^l
+[m@{o	51 K1L	UUG7T0(/F\1	H8oJZcKTHwR~"0"h!N		 r*zu!b t	p 
+7_C4"-|
+~dJi
+
+&$;:e519k5*h+PsWk W^!!Y%-;B=%v,;[e?C!		  	FB:5"">2F?$4?R[)G{
+mE*Ia D	({/`L`d7{Y  >< 'u.&E$1+(.[8-^x;c?	l
++"v0("&))i	<7 ^^3I#H6:*	C	XIrT4J\q 9+!<vb3e&80(*AWRNRF\=	*`=&u@G;WE"p"vCf*5u*w u}3Z-nuMU$' nc w@rBzj'P c (D-%%%! D+%PsP@q^L%t99#2-P&M"!i
+z>O%6[>GjAfUM~WT@jZ b5(/C)M.<:2c8<5'H<2)L/w#X.S>$1:(!B}U-M3PF
+	5  -\O~6,-L8)9f8]&WDi!*#\AWH Md[|I'.o)U,3/G'7`SEIl 5J:B	
+\wk	|x/T{<,$>9'4t4-0/;@>}9-I'b([V\zZ&?2 I,B0-&jtY x6,o7 )s 0?0($94 NG?"}A
+QE77}/( "~%sS*vg*><-+O23+v	V_*%&94"+#$J$ ='N&}5}27""
+r'a3V._h7#6&[#A!{A$32B.E?II/1 ,3%0PMO9?Hyi#
+ R	 gPs^%x	Q.@CJKr3!Z-)lA?a)DcoxwO.%{R%)K")*66vDZ->6)$#	KJs*HTw	N"%&")<!)84z
+Sv!D<_Y;.X46)S C})PS2Y2r3$x	WTF&R&O_<PD'>$$L'?}5
+97C287)odQ'xNX;e#)D03_>eqK#ERA.uC : =*&,~m0'"'$'-sch3."&EJ<2/+H1)FMZ O'9:8 ROm~%7Z l'(=*B(/-+-'ey&vd>Kb!( +{1(PK?dAw] l3g,x8 )(&#5;'@#Pd86_Sy:9~@
+j"BV,$9(.i/?0<*"/)o${br3SfVF
+!+0M:8P0P.rK*1&y)u0"4TcC06;Rz# )D	g	9b	\B
+p~41R<"W)[ 5 ;gv{EDFU9a!|7##"34
+icsD6|6'A$a285$-
+%mG;>	dt*LCmgNPHMq@4kX!X1&T+M;-M+9`NAA|/g p5"1s"px(%R|
+t/5OI&N	0tk|\oZ.Mt(\)_O! .	-:hH8}L34,#p+6#MPksr~ G_Qm+7 .)r<3HT
+&}G&^
+i)71
+*
+1 ^RgXqy
+C6DR@j
+{vuO&* #v3*+C8tx4xP3 _/
+E#/yAP+Z(%Vx$-U,bL8	_/"[x	K q>< )}P"!y5&oJKS %(#z14{jpWt\jRn2
+ZtAv2)V!		snS&3(6> pnE7!	v#{GNP2M 
+a&. Dd )<TP&#Uy[1: Cf5		Xv[;h,58)f,7ZKU202	Qi]}6/lJ
+M% +6q$q !Z%<QxP&	g qfBMI/(] %7Q;Z _kOR1f	qN
+XmIq\!|' M
+C;/S 4BMi!'##%M:,;fPvT^#)o6a [ y"F7[/D 
+>%7#c#i
+G+[G&!i _*;fGv	*4#o/"*qf42FL+QCW69$&A8vJ .UwJZLA(ck?T*DC O9V"rn;VZ 4}
+	A	c	Q}DCRo,  S/Q?C8!kr8V30@/x	S(	5`iv[dk8(ne^s1t{,@4BJ+mL'uK TGJ|1 w	V}/ rW 
+m0W a$g.s<v).TgM ~r( a  4]s> ALhd'AUVl~eF. Q=	%d<J
+"
+\InQ"'((-&v d?: Sc  ts%`C'#
+  pxp	 )yP	>keD'&b (!g<+6hS/[E
+1 /E	FI N?%L6	t	kR&XOtv:LufYi)F(I(
+D	FQHFOP|zi\ 	Pi
+du@`F*;8hT
+b)(a	??kwCRQT	
+9 X6
+3	
+
+Td|-T9ot6:{|<9y6Ve-0? 			}	j)$ 
+5w	aPCWc6I R}0AQRRg 9
+
+A,J57-g
+
+{).SQ+D 76NO0SJDq4y R
+D&I eiTe  'q9  q { H  g $ j^YI.atWdc.~mq- ; }i_vc[@4r
+ ?
+,	 ]XuUT[VU "T  }
+Ps=z
+\N?x\&"")Rgk	.  )t	F5XnT_
+`<+|`
+uB Fb]Kg oY
+cV,\u34GF.k!0.O|;t0+i	ixp1 &'+>}a@	I	 G|Ii	l
+O.bj	1"P @X=h*+"&"t! w6e|@EM
+FJ Y	J,S	zsQY[zzE dly| UH^-_	aO^&L"%&'$V'p^% 7 m3ebjZEu/U 'oy_\b !~3t #H93eN @T%" %+ !]"MFA
+H$0!$8>4|$ ], ( TzZiC0;.h%"w!!h|121 m;, 	$Uw> 9%W%n$
+NN!ZoITH,z.G!0*#I)512#,;T's
+AqM/1 SJ$f$A*'1!rgf8~5ha%"b)ou)&_^GcL\6 +k-m7>vwPv*$3)[!&,%J} 0	gL t!
+$1#P>Rr 	c93 /m3)6A	JZ\9v rf	R	@a(Rt6P )`b|r-$Ub3I%%0)o	D| cF-! Kp:Q"
+p	q(O4!#  "3:8m=DT<z4 G> 1E>WD.V
+#S1\g&!+4XI|SV
+
+;Y//"A%/ G
+	  j
+)	h-![;6B6 ~4@=L|5 ir$m%J_^q|KkO'm'
+
+Sssmz	)0l*#B:@$4\'~$w' :Hxe`VE"*)	$X!M.y!K.+T\"d]"Tr.
+/
+^.4S_-*pu6L'd !&F8\"" j0e/FAN~\| <c2
+t%M:b	vpe<-?2;+7TFE!Y;A 1R^&JsI2n{U&wb4%"<UHY%}!!n0=.,:e%9'	')f12ISd
+tFB{+ 9` 	*/Mme- R7u#D}!9j	C	]r;!d!*&"	<X"^Tl&)[@ GXMI3L=[`'f*V}9$-d+D"VJVt	G!3,5w+(e" )!% {C^	dB,H	 D
+7WahFh ;(CCP 6'-s 'd!G(Y	zg`%0O<Ti@W
+
++^uj7![_P"#8IDK'"eDZ-vk$y5x,?70t\RG0=6_cP%#@z 2FU
+H1?mGP&0n-&Wdt$-N!&"x|wP[5*')ml(?e@o+N5V	r "v	s*D
+
+w*NkB}&\o$.USV	K&H S S;W6M-o'y/]UFj1]{<W!	Jjj<4  ^b9S[N8d/ "KY n x	-Af	o70!/qZ#p) g!A
+\~$P U9X--^+{!a54'v+U"xB&1s)($8#g;m)*0/
+i'^[ Zo'p/AFD ,`*(#'j~+:4O#vE#t";"jDX)4}
+O}F6=j|_/0W1bX$?-Zqcg!/v+2a]5/j9] f 7R@hR+ /c%nz}j
+6d) JH
+{%Zne^\{ |f!@i08\V	:6&%l
+)$d(B"b4bPT% =Fy5^ j#rE4ykjV)'1/!4n(n9'E4}w
+%N
+0l2/uLd #0Xb.$	g"-#4
+)3M/eHpOqt{e-er:P
+.SPA%KHA>&B7{-?.+  V{#;!$#"T$<P.EYUr
+-l,2) @7Bd,*46 5+5~)fm6T`[_8YZ;L09	 f'
+?bSN-<p5%$=	IG2e+mx	L +-eU	jR8>l.]cffBx:esB-&a"bHcC#h#j!#cYg]:`j%p$4
++Oj | 6F^!P4U5O#&V(	X$j
+g
+ 
+q<I=[ TP"6Y=NbB*)f)9,	%	dO5""$4)>22DF7X)?]Kgv75ds4<`!sq%Ak$+?!/MQ+$d| ADNTtj)Xuj_(*"
+(B]VYc1(	f	%C+>As2}L =#K4!7:.<KC%#\e{^oFGn{"2i<(qKi22"7+ t-\y 3T22GDi?Pr$ hr	qV;G0&M\S1Ai	b@^ nP(#)C4]+"
+<*Fy3!`XZf^
+AXwr&Ao<*ZtH ]^;7#"zG#}	,(dP((+Q&+ */T !#+-
+" 3"+8.SIQa!SaX.q(	 Y%.>+{&7-0q1w'1' t5R" /jn <L1:`	^Hj:@=z[&e!%2E03)xhrR!)
+x} o&BK6	CuTM .i?H $Yh!
+ V{ndw9qQf'	Ly XO9M=k		T8;e$
+B iB	1]xx7:
+fO P[k)_ $id~#+3&&A^'H1#?%M#$*.!tY [VbrF8Ow?%=N p~j11c	/F -	P#0	(
+l2vu'+lOdt>:4R&Mx,o 7t?mF	eyNeUg)UR=/!U	zk-0B90!	QLzg E2V 
+i9UU"x^9)%N-k7Qk(:0l" b1/s<&*] /=LY&Z'110"v.E1j&{jm Xgi
+w66>n4/G+2n.,3V	Q )  3H~j|gL=q3!yz]9!'!#,P
+l 64T%+"
+[Wr0u*fyj!)	2t<@{no.,z,L}qXo=RDYa	zaUw#.3~4'E h)*v" !m!8-
+/mFa =Z)}r`>p&C4y}Cp"&8d
+# 8C&H{bE 
+d=bKtDE~raA,25UH$((,hS
+ 1_}r#WB#
+AQ(/h$v9U	7)f:jX"	"Vi]SL=S6&j!(
+Ri&rd olN|90'6");'~	| x	a"8 
+w7 \Un$$&5{fe=Yp%Nz q1|wZQR;.G%F?>y +	'2: )?
+?
+v8x	&E>)m(0~1 -Z w%bP83c~'3B{I	6r8yg>`! +/`:8yB|,U"[cg)y"%*ffCO;/	.+PC	Df)
+*3P2*ZMN +
+'zp'Y,4<	0
+(qmG$H %v0)}U#qAM6xLeI%-1'B,(1gzH"*	.P rIOR;U7 u`6F.Y	} 4
+49IpEnh	N	 :Ng_R'w5D:*z#pcx:Rm	  p`be@>
+v)
+r%FEn=.
+S'3U"#&Ri<zi_-:7"E++Ry< IDX!~JUw	?	&_!W'*$B' r&,\I~'6"E<MS</ |T
+N
+	j7 &g1 C	@f
+ 91YlGsZ b	x|",
+"!*  #U :p	l& _q9%7WQI	kh!$oHDEg?W?)_.* v	 gH9nr
+j;^, Fc`88	-
+D  y	!   UZ
+zzi\,'Y0Ha
+~RvbE Wh=<,E!n*4  hm>sZT/7
+-S)YXkoCMJ	{R,sbZH^(,
+zrdR@	?k+O3:/h ewm4JA	$ @t-f@ .u{!
+8/p!`##%xe7.RA9llV\o %a	
+!r	2'm;J
+Pu<aH){,]KJXN		g s" (Sep;
+i
+	U+[.nVFl+g+Hp:! OP	D9%U/I!~
+{(
+]&'x!G%){	X}B>:h~DJ!;>	<$l"h=&W\
+0
+ h:J]7P9g27,ss,s	qB	5 z
+qz{9\h	:7.g@$p* e"L*NqR!	 F*_cVa\Y n|%0vK'3K\dLO82SQuWObX!  3	O; r{
+]^_dTdT*LnyT\<K
+"9Im7Z	hp )65 kba1 c1?#(r}#	ZxA/c1E"W#Yym GNP
+m\	.r@?gd:;!}>M	fjtT(WLp^<MC7	u	Thl;	$u:IW^+	 'cGSwwp`,PRQ)\T		/v 	:,;
+%YE	ZNW0(vsjM:xLF Pu~?*ZDE*o ; NCN
+&	"Gl)W=uu^@MIV%"[[	E}	(T69s	)R	 (E0gqd :m2	 '0 	e	;&,@s>PI 
+"QS 	}  2sai(aP evS[ PcMu
+Ljq}0Est l=	Z/4  d{o_/qjY59 ;/	t Ov]FpdUK,
+SR	CbGiirFarl,aM^P	JD2zC-tu0o!) K<zZ7<NqGII@@5:
+m	}	
+XC|@]eS"fY!P!C		u \
+3	O< r
+|<PH._/e N_O k8j	zT
+"f8
+P uG sZ@?1~LKO<  5	T
+<E	`J6	y2C9 $q!	T\KP?ZFzz9|T m,CT G	Z
+=tag	xwWUmg(7~f
+As\6)hBf0BW[4A
+v  CXc@B	Tdz$% urQ5#Z$ Uk	R	i	x*+CO {p^~17`g S -	+Lg.		#	b	8F``
+y|\ @ eC6B+|L,[$1D|SZ>	}
+XIOU	"		dzpj>rr iq6{u3 y S
+b
+Na	q  c  Hq # [dUS:OG @ ][Go8dMM.
+Q%rx#;I-qNXTL\X 8?	
+
+Q4
+.
+	c P
+[(6q%%x Qn @hz Gf B6>f`d`	iZh/
+S&Ybm8M	VZUJ[\LYHs)XL 6\}XLdGz_8}	 ,
+8(F <I0`
+\ akM9Wx=g&gem <7|	O)
+n	
+W	h
+e d=lq/ S;?] ]
+,~		c	H'%	!	>|	qyb*JhZ Xy6(0
+}	d!v2_w S8uZhZE< B kJ{P @0CC	
+	=_>]-  0[ja" jPdF	f-		;(z@zT`F<7I.cMq]
+|@w d" RS}9c
+hy7+  *'z+?[A* "[sSgo[, p: ! n^4doO=}L	%B Fk5o68B4
+' 8  [H	PnR i^1 {5yRk IX T'A98"p :*C#aB[>en(oKntE	WbH~JJ -7H5q -eM0Sp=y+G:myD;
+T^84M}Ya@pzwH]k(D[  @ 1 / k~	VDso
+m42rV}i e  %hh  T'z ;K M/ 3l@B  >!s eo7 ._
+q0y%
+	 ?c	W	7 x9Pu`E(r -xdE(s a@{\m4u{X	8 QN-  [AijZq6.5 zRw_1^ N`/ al7 Y@c!2/+6 ,\ rs= @ 5 &t ,5@[CyWEdo0
+S  z#J7:9+ X  ? D 3  !dV$Y4qBS u"7)%UJd4L  f    j J,	NU*Famt2)$ve+9{F  } 2 b V P%_3{Ycn"  ZAux2)+`n3   g c8"`8Mi<?.:tKw D  /g
+64T S"Y7s>QIq<T[C){R c1+$l R Hk)l aOT3s! *I4w H F b  =a 2-}  ^) |5 :[K  
+#zffV?4A3 gVdw1s7OK <=  >:F)agbpt  ) x
+  43}/Y} q _ *|1biQ* 5 w -\     4  aIHo  } # @ ^68BN$B
+yy   _ N  kY_O0_LY   Q h 3 Lj n nubv.0   p yrK)	 { I 4 H y? 0 E r.B7D  ?h.R7^ vTto1-  ` +  j &Yaq  #pD Q Z  Qw\._4$tkK)-'%EY8t`Fv  	 n~xhvY   KO:fJy ;PX X
+v M H {X  <    SM e _s70by-os  U ; z{ =mhC X GpMlU!tBc : < F6x9>ir i 	fHu`P F :m  H |G0    )&. &=Wt 
+ 8 =D:] F 4  14 n3`ta r  'F`VN  d H?r@!W bFg?a=  \ [|#UI4 PFti {' H&1% 9?1[ a! 9 > <   u !NM=M| O.\D- l D { ] c  j hTy  "  -Sz+]pMi&}1H A<0|
+}# g3m_/+|iQ g}l) M ]   y XQ H8` & Y  .Q1  Ws( 8 J`""{ GT " P6$ h  
+ m  NF7I rC| dz   % mhCx   ? kjy,x(Fw|.s=u M ~v  9 _  X	DlkZ |  z < @t  7~+9Yu 7 e = G  e=7Aw z  O zqT7     8 u [ g]  {V2 $m~*$  Bf G j f   q   ebhE|HNXjP|[. ' /<li1N    )YkP- z F0Htx.5S G1`| !r]UL9}f5!*   Vzqn,PKFrbyQ? V   M z  G   3dS c H6H _p6K'wYX  N |   &VF; T  7    N  %  S < \;dF  t 6   E Z q  8uIfR    Z.  >  . /   4 ;V1	}<<J2Jj~T * O        ]6Eu79    S W [=z&T ( <`Y_p	
+*<@]O5  d V     
+7Lf MJ=oM@ y  ,  {     F  ft~U:   t       3 `Vg  G +]  MX A  P E y {4 D |  Qj  x 9  $ 7       #= j) Bw    {   &NN 4c2 -l;MAq+h 
+ a #  9    q 1 9 qu  v[    
+ c _ C Q |h WfTx| 1}    {|E 0 } h {   f  )g(Q   uS'i, n?      {U ) Lc d s% 0    ` ]  , O  + + <+51r > U k ~ UQ  @ g+; P` _ O / s  i < N      K_  -3J'	 }0  I t   _k-H  8 j / . K  # .   & mc{o  k U      \ $ g "   ,+np D?6 R  m^J t1Qt
+  #% # ^ ?  L $ 6[cqv
\ No newline at end of file
diff --git a/sound/samples/sfx_1/09_smo_custom.aiff b/sound/samples/sfx_1/09_smo_custom.aiff
new file mode 100644
index 0000000..596dc96
--- /dev/null
+++ b/sound/samples/sfx_1/09_smo_custom.aiff
@@ -0,0 +1,437 @@
+FORM  rAIFFCOMM      j @       SSND  L         z?  5 , 1   cYdRMwt\z  I BQhE<	.
+
+lr	i	^	<	/M-$e^9FLTY=+hrD"qWz	%	T{3
+ 
+	c,F  H B8WRHiz=|bG4WI	U3
+	?CQ"y%w90k		wjEbIQ[m:n}xmDe 6f*	O+k"#Z:P
+(q XW6jg^gjveng$1	
+< =	
+4aF
+	^
+l
+ 	4 1L2qf.xHcZ
+px n#%&#@:&C d\^OY\,
+:|bp\'@Yc[W&	$wZ 
+";#%&)-(+v%'to-fL[Q&#+ e
+ n!kqiB .q^Ty!%),U,,,("ezcM4hL2PO#N'+033.*)=$Qp
+V`+9t3\hzJt},F_Gk	,w=WOtD[<$&!''*085>X?;77662*((zuqRC}!*)&-./1o0,%!:? F!D~ J+g|"!j!q(:/Q/'8,
+?1?G?b@m#,*2O:<@F~HIK<H?A80)Z!p>us}
+a 7	+t 1<F>paf1mFJFf$:-X26<CIPKGDD<B=..kVoA]kj;x4|n/:N(-j,)`%" LE$
+")!7-);tDGEBA<DEt>t2%.w$OPNF3f;Wl32!#*1_5d9>BC=>94r.&)
+M&@R2S\\2 1!%E*+%e1<NatId4(&5CF9CDQNW]gbQ@;E C-B[c
+M$p#!.+(Y7	C
+uv#'8,-8|M\a`3^%\^d4ddXdBy._#:
+JF_^)ET	$.R153:=@C$@97+B;	Ym:J#)-39R>D6E>y51#.'=		nmk-a=>4+:hE$-8DNV[k][Y;ZZbQhC4,&cv~x
+`U 4<")'##'6''%s$Z7z0
+3*AEpITbGhJge:a][NYO>-< x`g+fPD`	P6W	y',3;6<5.7.Y20&*
+LHu<Cj8%
+D a!5%Y-@4z3U-+
+(%# "t1cf-Cl&:$.13D5:+?aA@:656T4+ 9<e{tOgtc&N*&"(p	.
+		C3fj	&=c&V(X^4I`?J
+IMSi$,3>HO|QO-KKJLyLHA@4'?B	x~N1rP,6!!# 8t=8ln4l+3@K\mN%c(+2r=^IRPI)BBEC<4.n 
+B2^HCPi1NZ\FS $y,6<o?C=84466 -
+zm{~wf\ N!@,^=kcp-	?5hU?i8
++&o.45s0/254W/7)"*OO	HDB\W~ 3q x"H	|
+w_9Dg}OoWW 20x{t3h0S> MVV >! = @b!_gNvJ(w$!(--*)((\))0&)
+
+ONG{h
+)U9I
+d_h-f*eg-M G$**.75;?A=463
+20l)1	qG(9#L,6~!$\ w1"\_?f5yO t^L.
+!%(++'&%y')E'%$/	% Y	f6ND}beN
+'2'$
+xwM
+E";bM4	1^)#*.,;&&-1+q`
+%nrK`X3y`~6;J;h?-{{:l0		A!(.}/*j!!&EWw]n0-f v("*g,*&(17X5-'$$!wW	k 0 a[=r	~SYm$ )*D-|6AH0D;9=>D<D:-$Qk_
+# <2_rtk EFRX|_Yg`0D.._
+
+j _`0@TZlTw}q`$#(a&0'-I0l-'{"%1)
+*P&"l4	J={(`t;.f$	cT5&,h-+(]&*.11)X3Q
+Rck=	Zp}!l"h!")?1v43/!,.-(N V sE}fe2@m=D&,3=tE!GCW=<d==:,5#0E* d203PWfPU(}Up,"
+!&/(-*4<ACxCEjC=y70}*r'#1g=#/`A+ S,sjFVU%0#<G]Q W7X\S^_=^u\YETKC:2&&
+<|u}}7K`1(yp$1,x17>GKM?OdO|NJD?~:5/(+iWwKrC%b0\+C'!0u M!'.n3^42:1t3z65u1, %6cNt]((f/^c <<~$,43:=?)>>/>??<61j-F':!/HvG\x#J\99I]_	RT#i+/0Q1y1333423I.*G"Q>oj9azAn0q " )'2)9@DEFGHE\@=;94)r#D
+PX qe/U;5EniQj	 |*157p9J;@C@;4.4*&'!T]} 6~lX)X[<,z	D &[+1i6E77Q6!5661,N$$r_bi_ga
+X `$')})I''W*5,,(B#!(~#8O2'H': w52't'S%*0
+3F3.*'a a&
+}2KA`(}&\Cfp)E0578::<>@>;6+Z"i>K'!MJ12`&	I[u%18r8/2/0440)#fT"*]n+4t?Ge$(/5:j;<@E(GC<4.*"$wtJ,- k'*5O3SBN{d+ #v#&.07=<:X:<;`6p.&""D6Y!3E#1 Q#'&'-V131O. -0i43	(syvNn{fsEpS(!(05e6o6n7:<u;	72/J.+$GF< FBR?YZZYxxgfH%+/(3$9={??d@A@=70,	&";M/ I,?6eWM "7$',-/22..(%#{%2v/,m{ERj"
+h!$6%$%)%a$#! mF]~_	e'ml9lfl6yE~	 
+
+9T/	V87IRq{U{T-)  eD
+		+)nvW{	L[c,$dxi a"&(\')$+*'&%MckgffIbW0lM 'f"F&+D,/E00////+Q%vi_
+h>Q$%!9m#)-4/1@4s6642x0/.--+"'V!o&1!N#)],?B|gC7[NvY_Xcgw6j$jEbYdy4X`k mtyg0l)ru` p	
+~
+61xkqY_Tq
+Fg '(dv!\^b>2/$*-147;V<;=`?	?<8Z5V2/,%]:#,\JPe }HV_!G	t"*0+3x57;?-@A@?.<62,&^!_%	!OJ
+mD4w|HO
+plT7\Ame"6(C/2/.17<;62)2 45K/z($i"!,D,	X^|/&?mq
+XU %&)).b7w?B8ABFKxKGDnB{B@;3_+A$"E./oKQk~\'ll.;>C$s+/5a>H*NDOcQUfXY:TkPO#N?KD>i9r3* U|eK.7qtxD{_
+\y&.`7CAHKgNRXq]][ZXNY^YTKK?u520&'NL&VT|;Ix}&iG`dM&T/V7y?.DHNS$WH\i]^x^_]XSLG]A=5`'!4KQ9GZ-3 Y^ %''.@6>OABDFKPQtO6LFKXJGC3;k3,' 
+ -IYvb:OT	T+FY
+u{FbVw!8*/2y8=$AFWMLSMVZ=[\]\\ZUMPL3IAp7.6%3<TehJ#NYo>Vrx~ '2:7@F.JORXSaTVWGURQ%Q PYKgDu<5d.*%	|h'r-'v&S0li$U)C.4:VCJNQSVTNV`VUiS PtPLKEAJ<95+!82'|0J}"ue
+:I?n.pl$,7A7GIK'P8VBY\ada\XVVBQ/IA:2+"2
+4p"`	]VnHz%e5+6 $~0P14l<?EG$NOhGKLLPMRM&=: ;g>/So[|i~}?BI	t)1t55y:AC,C=A@AACB>8j2.-B)%!T5R( ) 9/:t7A&'v}Eg$ ?~ .%, 2`57o8r:u;;R7555g51B-)"~xU} Dz4PO !^8[d 
+V!'1,16h;8=AD&BCbD5B@<6997T4E-<%u)
+L(a7(7cKi8.v"%R$V%'*x.m0]405H4334:2<0-o,P)$ N* [yvr,SqRB-2Ag&#Y&&).L47423n4D66663o/g+'%R!*l5>fr6[j33IOTK
+W (*)*y.m29v:S842O21/g(%" 	\(	t= = [U##N$+, %B*/)!h 3!9F:
+	=U)Yntbf>?8 IK
+M4IV! 8BFo?D	)	gk	x,
+4:JUsSm&LuzjD4\b
+~k(	nC[IRVH? Ax;pVjX	,M('XQj=N)`^o	|r ZS*	
+z		uL0c_k<\?cl
+
+8	E7m
+sg&qQ7) 
+? PRJ[5@fq	`F0
+
+		Q{X&6~u^Cqflj0N0w	3EBs#6 'P*')h(##$A\D^2o"(j-muU>zvLL@$* //-04a9$9$53J,=&$r##	mI7w13 Q U	
+) o\ Bi
+9X0?R%J-=.x./$/j0G1	0-'# !!^
+pcq%^l7tc&S(*^ L"(" `k $(($Pv")*($ #(d$ }b&S.-COaC\$L3gdX=!'_)(*0174G.X)"!"T%c&*/Q,IGnQ<qE?1vHNpd%7%)Z,8&62p)c&***'!lV )&	M
+Nb<*3 wt,7"Z%E%\%" #)$)U'<%T!Mh
+,)2t7me!*182;8@BEFPI|JKIMGA<?<:5/,*&("0l
+hSo4X0Blh7}1o.(Y2i;ACpJ+QZ\Z'WZy^],XSLmHB{:22(; 5;C*rA6~{NvW-z	  $P-26=C(H'EIDSFLO*OIB?@~B<E0"]zx0jH{RsWlJ. l<K$('=%&s(r+)% yb]3`w3`v]?1O);7#!$.%G& &<'&$
+!hUD
+GHDbs7[X+3]dUn]fCk/")~+.5 9>>??@BC@a:I5|41,#Do&	  6b0U]/YM
+*kV%>jm)W
+hFC`$)-R/S.069]5300F.*[$ uI({/a2B>k.w0sXzL1o < B;fGATag	x
+k	4	 p Uvdjw5j]z	e:mlX=V=Wdod7:Nd` L'IH!"J!\ #@%&$65
+  ~$U +Tnyw,jTAARHUfS L Y<A!$&(),/C/_.,+)%B"4 0FhE
+p xPGhsR}?}I66<(i4D:+ -ZWA'x$&)-)%$!#&W%LYr*/y<'Su
+HRpd|^uw2d$W`2eO!3 mgD :_<r)O2&wo ~TKB=	m,9 ApB!# VH		p> 5 `j^\{LL+]%ET
+p	]}
+
+wb
+fi?		
+`?GM8T#6GX8	IFMFjx0}^sf@:j}?(`_z<	z>XV !#$-%&%R&X(**%r!L(?~`~F7z!;s[`'ja;f[)rG-		
+3^I1%  MQoQNq
+n* @}1 me7  .+1D^_E11^$
+y|s,U=	W}i4\31 *h$w HtdL 2| / }Up&o6,/X tpbi"-%%"r"\!"M s_	ffs}u;hcF i|_L|^<$.Inh	$^f  "!xh
+^iIr	=fdrQ}V\FV	jO` -=k9A1 j		
+	9y	+			rq! ^u[U!Z- W\u &YH8kX9]	U		0	#	
+*w_
+Q_
+th  J ks7KC.a})Ziu	<VA:r1tiM	CveW'z}C .%E
+CX5
+yz
+					Ah>	(~)A}f~[	=~LgV\*_v [=NX+f:_Yjmm.K3 b  g)zh f8`i;efLd	e~ +K9@<D+%# 
+V?l	e!'5JjRv,%{BMZ 5@$=?Dfw+bC+N&"1!/ 6!$%&A##$"8 {q	Y 6HrZznk]r&
++:eQ}l r* 9 `,=V6i	OMM"Q%%.#"%&+#Vt*m	.5uROK#T{mhg
+.M
+E	i8
+	 z 3t {jDRi{H 
+s	
+A=EL
+X~G5% sy%7jP )
+!
+v #a0WF_&![ NuX
+?f /0;u	6[[A jh/Qc4Y%p.z^~2	zfSF	C
+x=4[kePW			T	
+x	a53s{>0\Q,f[v|
+@	6
+V
+
+QD
+%oiS*xo =[%
+	(
+"g$ f8sNoh N{CAIxU
+)g #r %{1
+		?ZF}	2 aIR7!6jc
+\y'		:	W{]Ygx\cH& a
+y30Np@xi
+J
+	C-tmn93`nVO^+ewO:yDk
+Z)k/C;+d&=	9w	h.
+UK`$'z)xV]!w4
+
+=	/
+oe#Qh`leVB.|+F 7B8	9E	|	
+J
+N	 * " BU_Ea>2%YNUs/~ >4  k,	DN
+?J?	
+
+# W F([Kp/QWz>#
+T^3<WC
+[
+^
+	xm0im&!:v _N
+`z
+=*VE1A	($aEp7s7<jLTz!D N<z0{   E V 
+b U5k  # hPV{^ a	 Q`vWQM
+#
+:mz
+A
+/>)T?Y 
+n-:0x c
+
+y	edJ)T*1
+2Z+ jjd ;>8$w1 Ge=yod^{=Dp)yz"BU& > (  .R	B
+{4q#Gz8	R	:=~f0
+
+Zb0c+~jS_c n-/$HK&7?m	jMn!J}fN/hB_*G(52vaTVQ}*O5H 33E&m<(B8ZqW91R4F )*%R\DPAj.& 7Aj4 ^]t 5Ww6/rNVG&.'k@LCW6e5u=EuC3mud;q|JNi23gf=	)*!'p57(e@zDORIpn 	((*+6HSaRMKyGzB=	7t*=Z, J}-:)6@CM3P!QoS|VEViL;-#)u)+UKR x	zT;&0_6'=FIDo=6,`j6JP4>;"K"!-CNVB_R_[QZb0hd;Q9*<$<wo{!<$_R-8BK+FBIITXNM;,!w;
+)&ca;oa*c5>C1GMOMGP<+1?&6
+>A/ZY:YJ!"r7H+PU7\juwpcYMTPaE1Y\:~&qoF'$*2:><78592l.$TawX[M^	+w!T'i2)CTo]VaJ`G^bghA\Eg4+@ De=c1(_b'zv'l375b4I8x:6-!x J#8|NHuK\)4;HMfL^KQ[\RE>G8#.Q
+o"?HSIu,	U=)28@LW+\]XSMG?d3#rk;}y9yHXns	&r0222B72>lAA8&m
+;<8/	\%(4@-MZexjjiioi&dZQH87+38=*("'('(X'$\NWAd  7"/2
+DOUVX^ef`XPG=<-@NF/HqJh$'-9'CJJ$D?950'\g/TmSj +e9VCG)C>===:1;"Z7k2d>7 }/?JQaV[^`s^^ULE=a2$i%6OE.c ##$$f"N^hRM%K1NE~'I2>VJW_}^YVXbqIr^E87@99%', 3r=Y$G~aSt0~u-;=_6,&5!1gX#=BL%--4EGT\\XSQWE[^Ob7C!}[
+wG 	!;LFUC!e3AFGrKNP]S4VUSK<.'$ :64}][; %-3<1(!p~7|P#@wt"1R;F(P}W[^ba][S[
+SGD9S/w'2GJmg:iRE2oN@LAA$[K]!|t{)b6`;;0;AHLLpD<L7J50'J9 `RJ_d_(!^=E5t
+]
+w 
+V
+	<)bw M
+f<yoUwIN1b b
+Er*	 D9ig'q{G\m!
+	JAE9j+4#,-&!\&0z2';%k2Vp?q%n_u!'%!"$4(-120+ L_!aNQ?yVxP$G"(.54 93:963e/,2(#TYjj=3J_7a> y'.E0/017I;;;70.x$<fLrWCEe c!"W
+f>^
+ ;!#d%),/.,(^'#^w4&;oSLs;CQ&*Ga_6 GxbH  w
+ IfU	hn	
+9
+UZ}Q,:6F"J=rZW/T7a 	QB9er5ou|1"&h'<% p--Vu	 XT
+wz'BtidI)$(&3jYy{d\;)2)TFE$'&##n$h#uT9[9'1>k8L A} 5%{'c(3(\)+0%1,$mwRDNuRM4	L6 _@cp#)p+>**('''l#K
+	S_n;Gj@E U	RN	iu*2U#U
+m z"G w&+.*---4*&&#I##kRHNs|NaR	6le l>N
+~G]
+kd!-[S:I4	uE&x.=,"F$)'aW	\%&8;?EDt@nE{m ,z!#&w$HS=RD%Gr#j!  	uH(k9Iv $K*,,'`d2apr (	{
+|!Z%]'
+*1872P.2e7'4+^_?	RSnLoP0'#_r 
+%'"#*X.s*#<
+us(s1;ZL@)!$$(607m842@235-~!c	v\|lFdPJ0p,C	$v'I.0-)(-4C72D'|iD}	
+A0pL#53H}BhO
+>P U	,}ALanx-#k(d]
+-
+N9-  b % [|
+k
+H
+I*\	W;jCk*!ZuOi+\X#<),-..0 ,o& pD0DR$
+ak"<G)E3 :S>;U87"55X43/%*FMqPD}vuz(2','/10j03O8l;S:75Q-%~DQ6
+|}]Au3e	lF-c`
+pc^Oj\WL_#o pAj	K	T'	&jz!A	)>3L`PBt 2w3	)  AW */Zf6jku"(.488510/'*(4'%#=#^Enk$@0x#5M]'q
+R%)+}+r*%'m'f)(U#4+ |^uyo]V}MqN 	(Q/() "#H##0 )l~< pazGWCX=W8;ZXs
+x	-
+6
+Act5R?  5%]NjT  %FNhgS~r(Ar:NT5S
+t*O)\SV~G	&al,A-p~**rB G~~cu4\$V}.n#"D",(W,+U#WOCkk]G#` r 		u	}PsmSc
+( h6p$330gW	aD">$& ]-HFa8p6|d3/PD_	.~RNS	yo
+Q2]_6 4K+,ivq[-U#$$%)-/m+(&$$i!G[*9w
+YCY^eri);)4>CDtF*HKLhIEB>)8o.&!I
+wC)-PTaJp	5".+24568:::8"2,*$f5
+6)mJl$Y! :F!%()*n+**
++5+ ($#$"?
+lw)qu%ZIhz` X- s
+D#w! "&!#&/$$"? N@%k!5"02W"5M0J	b
+Yu1;	-[#W
+]	5	Ah}Y,Z"W"q'#UF\|@;^
+z"'\,269g;;a;;:95/**%"h E)I+R(?&A,+y1 #)w.12j11]2K210.)'a'%!a
+WdR \?zC#!a&(s(3iWBB	z<v #'^,0(159=t<<!=
+<;9630~+:&!X	D s(YC;qQn 	PD$#}(=.E5=DBEHJMLMHLK)HD?;8-23*%e+``oFOH?3&!)29t=g@EIKXL}NQSaRLvFVA=81W&P\O`w\[3~*(j*_}+l1m(/4e: @EIORSU%VZg\YrUMXHFF@]7/&Y&ErL P=-?c)dpI",3L80>LE^LRrTUY6]a`[URPWMCx80-M)"E/t~=ZEVo}+K%.I6|<O@EO>TBROORVVQHB|@>Y6+#IR\t
++,el 	V'A[>yfI.Eynf ,45]5-;E^NQQiSiX]]WX;SRRNG=L61&*z :H
+	9M"C2 1SW [2b#F1/67;iC(M6THVRWXZ^__*]?ZWtSN'F4= 5n/*-!d>VyezyP1R+]2R <&1<?FDM/QU[i`Tcee1dd'cb]VOwID:.c"  3YIvd{QI/v @#Z,C5?,F LRWJY[`ed_[YmYYU3MbC;5.&zp+$IKczKP	hw&08?yDI4MQUXwYWWwXX_VSOgJFA9/&!n`h]I*ha+-)MIvo'].5?:>6BAGKWMO7QHPNfJG{E7A<173.)9"<"j2{
+c6).q38C<?B6C-EFCF@FuDT@y<84/)*%t ;
+O\A =p 7	`>se[ KoV%,/4W8;I?;EJEKK9J/II;HHE>8|3/+#zI %Sr#/b
+C+#-4y<>C:?@BBCF397[7364"43# 	m) 'Og29IZ`9`*#,(Z+/$9@B?M>D}EC@f<#8312\07) N	 ScQ3T5}D+:(6-s mX"*.02G4;85<=<::9]6\2+'j%Y$1	IpT.7(]
+J28""$),-n../_/I/G/+'k%#o	Td	5c/+F\6
+/D
+2@=k6
+l
+[	C~f@%L*?{1BK 6p7?m"[Yg^	Q ^  t,\6yQWxB/UT3"c
+r?-4c h
+/J7m'=7 __	G  C JcbN1x%]^RN-_U["#U3/H[&8\narH	q*Z T V R%N(t^!>dp	7y(-*%&],x571[)&*-'o !)6&	xBZL1lO#)R%9#h 	2NM}Z%C*o*=)-55Q<>:77<? ;i2)'f'i!tiDQr7%)
+Y7cc 0?tD;BU!s%(/1/0/0M3k21/c--+)$Fd
+`#_@Gsq%z[2 Q7iLp:QLA"3#!  9%%:$"%"$&$t  oEE"mcZTo U")6/ .0
++).%_"Y'iJ:BS7-3,tHa dd!u)	.C11.026	61,I#LV	<V|[Vfdm]Y'	m"h "R !b!;$# 7""m"$"X&k$!j"!h wU	i&I];wLtz<-Y9=b>BIUx[\WSkNSRRZMF2>:860#\*dQ+%`p>v<H[\)8AK+LQ U`[L_&`^[_f^cXiNC;;744t*dr8}Y7rE`(Kijq 
+_R*48AB1EHTZqSMDHHdF?~;1)5`v; cf,u A29Fm!%!!p  1"$7t(3Y)4wV`%Z]B)tm#(,3,./.1"10/s+'#|#/( /?r^vsJa\}E&@@a\ Y	_!%+
+0m6!:>=>AFGBB<89/7;/<'r#
+.<DhGRr#"e+y6h;\h#>#'j*1.+'F(.I3:40['#C#'$	t%L}AEsO*[!s}Ii~~u>,tvtmwg\-90w7k
+			62;gIp 0 c$	V1O	^mv5rgvc} i	qR
+@N}~Qx
+mk #~%&$'()'$"J~Q56!]"}ODhn	*/:0ej
+i.-gQ!)!
+3# 51Q6>2B6d\U	]cVg%
+F%/
+ 8kJXPqP~gW	
+	
+z sE+d3*a}3o<o}c.'S7>6MbTd ujdz
+|
+^KG~:DW*+H(gD@A1$!Y"D! * 	Xi zu 7	wI@Sr;$Wf:%'VXpa-N37R#LR0l.gMX7Sj.		@
+@,Z.4J UO#0%X9WaVeu6Mn $
+&%!"-"#"u 0!@ """! }_Od#	@ Wqn+ KjkDt]A6[8sT*;"A&"''# 0s# Oq
+E	v WuW_KuOD:h}?!v`+b{$ bK/'D7h3O)+h	GZ{bK_- o
+fD3op0C
+*]eZu^9r>sg 	ON T		qTdZ&,O o#&)'n%##%'!4Khl	(-_,+GC&
+ZF(N#&!}<gS)
+67(+1'4c
+\d2yP	xhb	8	W  r Ui,{x J	n*		{		Rf1G iB0E ?Z[\ R^  z4	6FJ{
+2	A9*_ ]~/1D- 'y@"c	y	D
+	 (%= #ru /OLbx6z9~vb9)UXH #I$$I$'))'".TNy
+ Dy/$z\g&3@xi91N a%M	k}t0:;B9bhbrV%	C f#gQb1zNb5d.NB	DZ/B/c'@C^a
+	;9	=PClAU C
+03EH{_<N(N0P hL8(7
+[._ b	n	G@|}:!0DVrki
+3qB	7	l
+	}
+XG
+.	0N	~
+
+ 5
+]/	]
+Puiclu		'9}I)1Ak0i 	a
++
+	fEA ZLih|} e"   f X	BG< ju V=gZ{A`<uIC+DA]!;Kf.
+m\Eo| !%G
+		t( 6 * S   X` Z\lK2+8 ~	,EABxZ`	
+ o$Wi_s<M$+pa%PFKxn`r}X:?$7FW44/l~ qA|V0+	x
+
+Fa'	,2
+Up	t	ki
+jr~'?)yY=f"EurgKFw3XEs&-G3 %.I"(YRiHDJD,{c>?D&5, @
+h'QG &sd6		K9	(@
+	ntz	,t=g >} A gw!Yy0:e MXZH`5jTpMm8V2ph
+	[,  )?Ivk:j)/0 T GJImn	T^5
+{7?g)fe@y( u0.XRkoP)9#je=%p#(E1u	a01
+	,	"z/$	's=Qh<F T Ru d	I";6=2\)"BY^,)b
+vg$=<Q]o2+Zh	h		Je>H0<#WM`XID0  Q Hx uWqnK ~V]
+?z=
+_toF 
+uI
+&joEh{=trn?~ us 6n
+Db JUTY$q3/W){L p		\)%{yY/)/7
+			b6K=~B"	7#Q|@*CZjbLriI
+h7Pj 	9gj		3'Ad&@t\G~17u[!n# @
+Y} K =kj&p)HPg/:"~"E8TyL!\*
+
+ ##  4lT[zTdpche&j#q[gAs
+
+Da
+|
+}uS `7lU"{x#hf|l,	sIh.P"|!`"yl;	,!t56 uBO^|Ly&H5Ae+G"
+8$(F
+$;6	g(x6A|G@*>!. z
+J	<$AcA&`hfa*q%+
+7
+W$ =F=0{.A8[	^C!_P$MhZpr3grt$=rB7/6.J\W 8)-ivOdz|lGtYSD
+0t@:+)v2:9V.	j,P~HKOPp`,A*O;RL]DEPWJ2!w$7aA`dk#G/2<U?O:798964+}Z`i!
+dV-;7D>HRZ^p`c	`WbJ;-)ETW.8,Y~	n$.U6>FuNR=P|H>s4)G"Yz+S[#))-p:LY+YSNOQN?z'.	<s|24!9*RQ_l^YXV\bO]NK9A'H0 L/7$w${x
+Z[&//46=C+GIID99Y-""
+_zzpTCf`,<@JV-d i.kLqG{"zom_TLA/Co	.7,	#*3:8840-)s!Zrdr4GY`'f6;BM[fajhdAb`\Q}>&)$l<r](6TCJsGD@EH&E<P0$JdiWC	W/<Al?=AGGL<.$/.&(?G>,ro R}!3AJPX;`hjtgybZSQJ@,3"$-QK}!Y< 	djY$H'8()/y3.s *(sb6/nx-t8IBHN[aej%lic_[YdL9&Fq
+Vp::`f1\3	++|4%6H69J:t60{*L#U&C#*RQC{
+UX)61A>IZJH>IOxTLP
+CN93*fI(8f'4Y79qBN*VX;SJB><U5>''5
+=&}.4.+>((r'>"n+? G"]hIm	 *J7DKORW\)\aYQHAB<v38$[tF_Bpj)q+I
+
+-sFPK	&-23:XEpJNCB74?GLN>'$h* IFh'K00'`(32=
+
+[D*zg
+Fb%<$JKNGJ}U+\e[CVL? 6616*sAJ	;~Ro-h$,}06COlSQ0MsGA>;3	#/P*'f5Q& /Q8P>FOtSlUJUNmA73/!Tk4s#|'7EQ;Zadkdeea,[TH9(5q#h!}/=z!g*I/8CJMSL}I_DY?:.4q,<\pfueM!%*-2C?LPLB`=9?DBV5,$I.2x"LT~^t"f &+%/5;*@`CW@7.**++|$ G6qA	O^
+yH5QM["]
+cJtr26f1UA#_(Y'A VFeQ'	mNR00Xs*MiG,*-%^.$04b9V>JD.IgJ>C:7)944$	D*$??
+`"-8BGHIGHGD@;2[#OlT)Qa^~%`|k6!'0>HNaNNOS5TRI;-"si|\n[AA3 %=.9CKtQpU7SPJL0G'C=1U!m|1gp_<i%g16Y8<"BMEDBF?u;}5=-+%J [s/LL[>Jg%,1<23X320.5+#S@;D!\[\H{b 1"W&&
+'((S*+x-!,t%Nq.8qLW+F	BG"*./+')/6-4/*2$]<Udrl=u6`?ZJcMTz39FTsr^=/#l.|772[/0d0-*'6"13oO sK7/v"~t+!&,*3b:3=B9412B2.$A O
+3fw#7	!'.,V14?431/ ,)$*^R0ZE8[<u4 '0O9@E(HO9TVRJBN=:3)1mqFpPn
+B_$1l7878>DA?Z8R-#X8'`<v3sX] !%(8(()(%>%'\#	TjG]7gUTwApyvw+L)D=
+ xQ>_{tF< 26 F *2 
+@qEm?	= E exQ@O~4KR2K`;A4A'..M06S:Q;n:8`7w8f5.'#7&8t=s<  (n1:$>h?j?,?CEB29--%!M``lr5l|^:"2ACN@RTX,`ffe:b]SKE:y2++"4D?9<^&1n
+$/5<ENQJN.KLSOMPFHr9-R$	hN&f`zz#HJH&r./, 2=sFGBD=:6p2.,+$TP	
+WQ36\h{<hR0'
+OV au4#olMt{s7]U#:~pe'9 3 ZG:+NH&esW EM
+M)~ #)/1%-)'()& 1	0$5O<qF^Eu	) ~(+,*9+@.01/0//n.+&Ok
+	  ~'%w _k[
+U3!(,07>>; 3k-.0#.)LXY H] S3pK]A\}#%G&)+,--/r-.($ ~HM3y!+5&ylz"%s%$H!q-_O>	o ~+	gAT#`B
+_EG		
+Te`"xyy "),,+,-0341* i}
+_jIc	~R\(}}	($*106&7 52.<+*)&"r'	 5x!i4!&'m'),.0230y)#G?r:.82N|Eb[E6"Fq#X')($(+<o5.P _7y57`=l/
+zim""&"$& &')h*'"w=-}}gBf/p~#{# !#O$&'y,132c,&"!`[oWn;Jb\_;{2'P/z23 5)5322^2y1/,p&
+?Wly!`4~Mc ~.F* L
+;5 -[ 2r #
+;
+ 
+KX_1ts {d!`}THDPFrp7	VOAr Ujn/%$ 1&+#)%A o C&c-(/*$ !VU	qhgl+?!_yOXgE[Sx(|2&4Q1..4s871*&E$! 7"@xh{t[	a L&Y-1347;=	<>;D<>;4I-v('%	J^%6&oyg6{A[&m $& ()*++-V040T-Y+*	(w%"!?"e 	7|:>8W4	&;SGQN/
+hWw
+pVM?7hrZ  F% ztO3\YF$	>) Dq~z!2"!!z"$#b r/vFtnEv9ngFY!t	j"*/s2316:<=< :9z87:3z-'W$o 7HA	wb!! *b ^vu %c)4*+z+.*//.-F-++:(%"God	HE'`zse, _Un x'|-.?-_/11o3733F1,&)5&!3UY* tm%.`#!9())a.O5;>?B8E5EaB@7><.8O2/*#eWXI3ofCf3>;f@_r?Q	&*+106:>#@AGBCEsC?5<U84/)#c"}J0 O]M6td
+i!&+/14K8$;?h@AOBF@<c9$753-T& K&a9'#&4q	!"&P,27	9^;Q;_<>@ABpA$?>;71-*'A!`{
+,Un)1VwU!*+149><J@ EnKYNN#MO)QRLFB2A@;1'X/v0lcb*_Y<#EVR!8.;AF KQYi^abP`c2eaZSNRLrG>1F%:nA${#%'Q`"yT<#-59g<MBJ9OOLKNRPR0NNII`I Fl?{60, &m3;/("'iws|7aODOA1SEi5J+K_$&)2<%@W?_>AH(LKGD$BCaCsAm;5g1_.0*#K`:'*@LAX3
+V&-f1m5s<CIIGH#IJIFB{>;Z7-45.(*!??^ 1,m&5i@4!%E)*/6W;>BF|JoM:LHFBFGDEu@9l4]1/X,^$-($y#|rwtL5vDBx 	5#%', 27s;=I>?@>@@><:v984/+&z"vd6+E'K+$2Yka_~:%+/4:6=)>?A CF$FE B]>:8]51,m$wDd'hAPy"->Cmst0
+Zt"(F,1N69<T>??@?>=);.73}.)$IwJS1n>rq]S%	p 	\
+#&(,-,,0.1/,)?&m#.! N	=~?T~d#l
+xEN#% J!QXM+	`fvN8qD=.kWmVG=;2@_&vjt/- j )t4E3F
+yz?C#jy`,*O	S&8Gqo#$XNm}	E	b _VxQkxXS{U Z	l	r@]! n[.;
+|c`o~.zF,2:-X^Y6|r 
+4s!$&/'(c)*G*+\*(k%#!s#
+Zb6Rhaz\<\;$RIj|U|Z;C#&[(M({(f+J.U0\/[/11.($8ad55BTZx)6fKF-ux IaL[wSl!%(('m'*^.I,(D&#$%q%%	"`R	^ flGG0iQzXWcK/v	R#	%X#++G&w$D#Q)13*! E$'(""D c/
+f<JX[.F$n+RKBFr;
+"
+\$-.)O(.M6S;70,,/-;$(C i cJQ*uNQ6z#
+$*")()/K5i8H3,4(j*,) DF!o"dd;XI) `	#	|8D^`E.57S X5&=DB
+hr60Hb~dNI>b{s&.6"9\@xEHGnEFHC0BA{>G942.#'{x	lRp?TSLJPP*N(><P["H.49=GoOuTU;PTwW\hZZaTMLEE=O7/(d W	$v"E,.bN$Uh0{eFeZ;&/8:@HGK\OqMKNPiQMyG?@7Z/*'!\ZC?I.Dl6,"ER		 
+3
+	} B]#+#&#P l; Qp*Px:gn EgF)B(+)!*008	?	81L)e**(%FQh]G`@;>/qu+b7zHl_fkNnp!&2d8?>{==>v@>93i263([4k	o]oaa#8=%[}+oV	` "'o(s'(/:61'!')(#NkaDA+1|ifdhiLj}}DvK8Qjk2
+\UpS
+(	Pi0 2Sy&L roI
+[ ]\?<dS|JT\[ T6
+ =`H	
+;!KBa !"` w
+	L1d(?ar-~dd]fi	VY!>x<dr
+71"h$HBQ3/#X IW2
+	!2g"v&'#5{ 1mr_P85ov7?7oOz@8@`d
+WqxL!s#M%&%*-*))&#iQ_KC=Jc
+k V mihkc=@tk<8
+c)( 
+#&))*)'&$9%@& {R fI<^DG[E0     ;k =LRsq4<+_u_	Uh]OTx8Ku
+6
+RjM\i= G*PHD }l{B rM\dN.2-CscYTR	Q!$k%n%#6%%#}]f'
+
+V0^msGueUg5fAXY(=(eMr"(*'e&)*./(,M*)S&U!6>nNu*&22@5H*2Rw ( T9L IF6u ;z]]wpQ
+
+~ 
+V 0SxoS8
+qQ6~YxNY
+ra#]L@orbd;P6KB6t>t			9~SoyT+u''K
+sP[iU!		L xCc-TJl   /Y?vk8:t*(o H#[ #87V*.:kL'6*,e	!	v}Huco(z8%
+A})NE*y\-("V7$ 4?zi682H:E) 2= H@Y)h\NBdQ] 6.H
+:-9&~
+y D=m_u=vhNQ
+		g?C<
+
+OEY7iv! Jj,T&QP_0 - 1f\+ 6 )aIWAG" K2`! !H6C65?ns-?^ .:%h^%
+ XiO6
+?w	"H7 G|YnXsC o"l^7C&0]mC1$~w"gdE!$"$$ ,
+=qPL,;0x!Q
+J	o	
+Fq Y@J&|`R1>9%\vpR#I#!X!$"/	fVc2Rl}i	H 'F
+e7zk.FO? ?g/4$th3NGgk bFv\SXU knmFn AjIp;   f 0bOFeS+ 6 f	U	+VI+SY4	 -1 vqGWt;} 'X
+#
+(z{KElF'6 -J
+.o9GJ= ~4%)4	<W
+(x@dOp<wUV' &;,H@@4q
+O
+m-m
+
+	
+	Z$ eeTHwbO@fPkW#& Wp qsR 6U7s i;q # ~ psS=[X!#uY
+	
+Te'(NGth|Om 	yz5,.CW'|?Bu
+MF;J	F {Vjj#y?K/
+
+
+h	l|^
+	>-WI69`8O*k<' 4S#J
+mR/<t]*k>C$, mYL9 42	
+
+r
+ 
+
+
+
+	<k/ ve,c42kV;J"Vehfo_ 53
+
+;r
+	)b	
+	R$#Y>>   :|w\\F F  IPw{~w;{ 3  a,uAkt_nHy ~ _\  cO*EZ   m@ <eipIEs      ms=_Y $ Oiq2^mxb_MM9U <ib  tz  2]]Q2  Bt  87  F.SN   t `7Q*ha3EIf%/ *pLw
+<"%!3Q
+			p=&   8$IIOemoA v e] 
+
+?_M5CuYk9
+h8tX (Z/@~n\wTa  v^OW(>) iK/FP]jr4Bi tfQRi.!f(w~$  0B#\5<|   4>+Hknn@GMI   4 >mvn > 3 %! 5< 
+I 2 )2  zJ;    - v  %I\\  _  A] e   1   o z h > =     h S  E#lhT{u    Q G s 
+pL	A#3     kr  E 	8`_
+rO~u| E  =	(r0Z+   ,   8    :u^8FM=+{+Bl1">TGlr :  ~  O@6|ei<      e 3   ^l//#8f#)f  C      P /    ~ ) p   [ 6 - 2    } 7 
+u M c 	 # %  ` m   9 ( o    g P    D r h  W 8 D   ~  + 0YQFc/,O  9 E           o     U T o U   4  M   " vRu\      N  : %  v       t : i ]  u W 3   * G *x         	  . 9    1 , / *  ,  #                    
\ No newline at end of file
diff --git a/sound/samples/sfx_1/0A_smo_custom.aiff b/sound/samples/sfx_1/0A_smo_custom.aiff
new file mode 100644
index 0000000..800b246
--- /dev/null
+++ b/sound/samples/sfx_1/0A_smo_custom.aiff
@@ -0,0 +1,238 @@
+FORM  }LAIFFCOMM      > @       SSND  }&        H   4   d pl +  Mp@8 5p 
+  ) t  '    H   = Y~  sO X 1_ 5 "T { N58d;65(< 5 !{46  2,h= S^s 7W  e  @~XI?%629 pGo L[1'!TeLrxU 6pd P1 P 0 
+V Ws1" |n6J 	K%h_= `5$D_C(?9=;2
+BIb<X8!8SI:vM7e% O$LzE}c=DJLANnF69ZC>@1,gM+T`A@S-sG]5W$4w!D0AU4,-LB<> ;!)AvL^6';;SM:''C&4<GN
+&MN0.&$p;UcYYB63fXDj4t
+_b(2=o?K3=aoDuK#383
+PkPT!-TM,]dVRel>] 9Hdo+=W78V"%#Tk(cx?YI3U&o8$,E*0YOL\SHFBs54H+	4lk2,5zV!%	*2SL/AJ[CK;*Y(j&	k8d{pP9{5dTXVd]r0915 m3*!? .+y2csUF
+ON>\'<pk E%^ H<s	j.42'<WH}( l/Kgb,9Q>Cr3Hx8%=$VQL6!9/({x)D
+2;g9X5.)RrW} ~"nFs"E,5.l@@(5S9t`40/;I#1At/%;= 7 {t-%l)&#Bq .J'HzC	P u|(S.TL-Rb]$Mm	]xy 
+]R)g&F N(l?F l L& r[	!1/ JVC@
+q!&D}boyI!>O'V!	6.106
+*_u>OW`=O?O)VB'e3x:wveNcupqm-'%).yG7MI)07:
+["
+V)HNy3,_@N;S!N#HO*L4R	:&SJ!L<8DU%B y#oZ@R"* 'h+C]	Ci Q+.#l0}5H6+#yQqa#M%8 u( yc;h{	&3H,L39#DlX> xO07L@5'a0kW+FuTegh)J	4I1retJ1@Z )J@?LnxZ*EMJ:#	z2\%)z:&]_ZVCj""0W-@E=~pj< F7NbsZL-PUb_f+?I	_-n
+	!=eL@7+(IW3r	G"&o!yn#;K"@+ Iw-V	<)7?$Y92%>
+0c*JU| XRQDQPhsu?N7f&I0p_Ms*4D)!57=2,k7_P$`5>@|f=~+c2=B/#n"$N "lC%^RXjT B8&s3wM	FW`* iIO}t7B!5IW"s5G7
+
+QKZ)
+;B:l7 +_!=;tkE8>5w>`,B1w2
+%-9f:uyx*I6%
+*hGts	 H=DD1H46^* 	*B	FWMKA_:`~K%w *0<'?%r+8)\> ;.
+5"j-B&.E$%QP s+C/*"0*c{{$.R+ 1IQBxTWHIS:<#
+O9XX9h
+O_:n	E*%#F%l79bWU2?";<#KhN1W>*>:PO DdE1"<p9 M11E%U(4!6$W? NfLT /53.s'G^6	&ek;h
+3#k)n{7s5B$tBjG\	21q>qrkD')]&	hnNiBHfhSX(y
+lC l[7 I6lr( $B#	". 
+8	&&  -Q&$'_P&+
+6)0=y&/9 {tE $3&#Up
+Ixm"Bea6a7l8v
++}SKjnS uuG dD$If6
+-Ms
+N~ () 9Z?w;(g4kO\ (:?l
+`J\% <Yz;
+uS>Y %)InIQ ]{ ca4C
+P?f$9"s8a<_]G?l+~Xe,`v;2kr	R.S/)j^2p 3'&6oyc8gk;YNY&s.k V>GR
+~"+%1/&-',4.*&-d)O1&w .*(T Q!P jm1r+edTtLUr,v"}F-@?&-t6Gd \c ]uv@j<!>ZQ8h/	`eN\Qo Q<l.S0C# b*2HTG2(r Q~>.<! H4q)g:>#;&(cw#X*il/-&"
+^;%EDb(pK? Q	m	+#
+)$
+7$4
+0yN y%?	 #Va		b}7_A,Q*S"ANxdLk :(1,	
+bTU *g	I!)Oh&1T
+$ 8ZZ\	N"[B3~Spyr7! 73TRm!z>w<Pk2	L"	"Y
+."'"
+=k5	)6gI+R{ -M {(XCi\]pq7gK<&4*&
+(	\-
+A!m`^G-#SMEl%]UkNo!0 6Ue-zFy!. aiu;|;(G!H%o	('2!	9(M
+H,;cwy)!ao	J
+RB76 7!4P9m
+)T
+Rs		\qc@} H
+
+ |.9 KjUap	K*	@y_
+%
+ \"1L*9d<(  }RC ~=Cnyn	MHl5,m^-RXy|$`h# odn7<nBd-tR| Sw 6Uq[tar0Z Y%?B6lR_z\BkbV=	)[	7 gAQ"?	i`Ns	\|$	ECn
+=- Hs;` :Fg
+7A{
+s![y>*et; (	ss'PcE gY& tf
+4sq^CjsE
+o
+LR
+g]k:>Y/2^u=,'yh!#rD *!bvUkwgoh 5bZHp*Y^e)o#+\O mN2	!#i3
+3
+{*q(3O?I#9*%hC?2!V$Dfe lU6U^X4 a#	zs
+8q8t6M=gtHG%&`N.
+'	j}3'e(OC#!m|v $)AcC : MXb!$;h|Yf&>/ *X2*#=2)GDY6~1:8	.;,6x/n -f	
+V@#Wq ]=$:	[n%.XRo#l&y		b Bz
+t'mBF"S0VmRyw0W,z
+%V/X'
+TBS~WI aD<n
+KjL
+"j9r	9I}A<h4# m6z  f%OF [D]qZO	Qb;	J^6QD^
+CA7G
+fWM	8|
+0U#bPqg	ElG|R )z?X`
+}DCSy >| <Wfy;2d_>5	@ tZEmI	2XGn c4a]&Jr$}:ay^{ jj \
+4dT) 
+u?Ni	gG%c2	$ blP   "dZ	x)&S*&+@	 aRB	 
+ A
+Q U/U/ r4Un*Jd!Z5 ne	I`
+D,%$/#	d bu[k~L	u	]IZfA%	}yW}}sXeXYC 	geV
+% C -x;{`5C( { | 4@1v/p% @ J *:  )j
+h j		y3?r@	e1Ml
+^ 3d*	;
+uK	?!	 {]\H/T? 3	~^ M  4dY 1Y8 <W-	^	Or m6: =&g6S  	
+5_ d YQ<lx LHqNqHI(X[Qp Op ]GN /R \
+ P
+	Do[0#1Y$7O
+U"B"Y22'>R8[% /LDEcT5czM!l~H  X
+ !M@W?taYP [cx)p	Sl "4m@kb YdM&+	F4"	+pf&?^=   %=&fL{;<WO
+3 | 1{6D 	C
+1
+~s i$ I &e:a	$t
+r 0avJk  8a e  !=^r4nSlFq5 <V oQ?2l ONE_ I g\tn	* l
+4
+ '| #CXNmL
+XF* mE]PY4;] vz~Yve F
+h8UA jbi V  7-jXn. `w]-{f(uj $`6 r\R E  bG) ? 8: R	}G?vP **C HKU.2P$u[| L ,) e
+ as"wVeC  :HGh);NO	 G&: /	^0 m]uiv"h*.	;4NVOUPu	0t)>!3xq	o,=*~5
+7Vi*:I?%!7)zPWz]i^;3Q3@+ =ji><+A4id 	:vD6T%Z'?0C2,)(v2-'d]] ?Oc/
+1Bk)eL*Q?Z$>;%'*3&}[V{	m	u(-JA0EA8 U1<9>omWErB %*,52$!3EGGc5b
+$ +%6:%|;,7/)-8:x/BEo8B2@e(EhQ$E=1$2HHa5(72&Ew\|uSA4"051F?IK	PCSxE:.DLm'0e<;D;@1D\aXOx+!+&C!jv	--2C,5Ud5{:++u>.,9A+,w2QF)Kd;
+a--OK9Y+<2fZU5~0R;",+wVrY8~'$}Kc6/3Z Kbyhv
+8&U<	y<	M4T )  PM^]	Y={zK^ib	N68SB
+PoL 0)x Rm^#p"/K(2e E
+	Vdb(C,4 
+	Cv6 729~Ry~{wyS
+jP*A{2N/gR2S-B")! D
+tlic6:&*!'E(	 `0:@bGIXO	zJ
+-
+))RO:
+C X\Q=8 z
+;v[&A)#Cr]Cx("m(n c&AN
+VV7
+64L?4)s-2 ;+
+3VGi]ZKN"(<:++10sWf} -9%:34M?SI5g TM/73s4FJJN?,r'Guk<M/()>NH=W6,{1:5&pG^l/hB16OK-7,+50>WN:L5,/".Tb+#t+$[- E1K7's@2 !+)s!#Z-Tc 9
+g!e2M(P-<N	KuxH&)>4;nWZ7&	(<E7nkNnH><(0i%v	1QSd5W
+l1J148::6/809bQ	7;pV05'&y	3 u1$2H3
+Y&g@+r8X0H\}8 %*;4E[t1:6%0#M-/\h!><P	lQ~d::{>x3-F l*h{7=;J?<ab+`c'j;4-l8^Z1zJ$7)7-0/00}Yo5)DJ
+.@$,T
+j'B$5$J[sVJ3`>m	;9 ;)iB)i)=0'(
+@[%$U,M6U_7s-X+D")2K]qp+#T '0(N=$![
+"hhGRN*bA; Qw2B~?E	 Ap8US D _+,H'Tz	c^xk ~Jg+yl
+7[!: oOB]Yb(ee%k|b|#s4
+$g.V4V 6f $
+K,1E1
+.x!O=^bSRHG
+n?I bQ*e#h* 	!ck@LGA%z? i" <u08E,pD=}{7
+rA 
+f	W !om
+_H1}m EvJ7
+M^{ 9
+A +`i&	E '  spFa2h-=W	 
+RM-+W1GPw&
+7% o   ""6V+9fd&.xO(s[7:;9	&g m(xL]Z|M_Soy	a   m{8 @G %JI,UrP `m<%		=W[ 3lHY
+ HH>)`==9 N/X4p]tY3@nijH 	-n'$ @%HcR9'1>PV
+N :
+pH"R,~)h|"00:CD dA8
+Njuyh"	`H8{ ]:	5
+bT	q	pI{PPu :T Ue' <F?+	3  #vm;h@)PD'XnvF3~!!%#6Y0w=
+C&6	l"k/6BdB%`k/ V	VT*T}i?i^
+aX\!lDZnrnf'xv?-dA }&[	_[}.@d 
+ 	N`L#
++	2*
+t>7	n
+x" 62Bm|	wBqoe7<&N
+Y-s; xi
+_II#H5@:5^b R7\4]|F9X+<x@jH=fL	0<	yI	@'
+	N >M	
+>/U `:cll^
+
+k	Fn2kcfK
+	(I	Ob9\5gj2#^. ,f_z >TOc7'	Z= 2=`Fn4jWX) 
+o9K",rG-A fb9CVR jjM5#	
+LpNqH G {"Z_@+3qy ohg'XJQ	<
+8<i	%4Ft%}N^ g	zb_P42HGn
+*clq v-
+; !^3#xvqq'xKsVcD	!v ~WLZ.od?2M9	z r mWy.
+ 7P	V
+_x. u-$%
+
+o B3;+	`~vI	DJ\2 _ ED 
+
+K	y X0
+	$ni	2h
+%  
+D9IsXN -8Kp .*]>-70
+
+R  @l >	s /5v>yz$q nc	`E	&B.;t{n
+})
+]psz DNFM }yU{1ta
+/LU	~Yrcw =~]F7''i O	c> h		Bi	zL oOb	NiB
+G -	:n .'-l+l41 hPC9"
+e4'R W?TM 6WG	5E	1*G T PPi QNmX`Qpi| v1oWo0mX	 D3M&	c mjhv /		8' !/	-J$ 26k1
+-=U1Kf	]u
+}
+tM	iCJ@*7.	 *J, >l;jPbdPX E.x Uc
+$eW9cu^L\dC	9c -b&E` v !~$ vDx 8. C	n_& 4a=9TDs} ] ]g{?
+n'I^6uV,y> 	 f D!U	R4H p V v 	wOl>G;3 Q[wj'7L bv yNzYK1   %b	 g_x6O N?G"uYI{[ Ho@7b n0wFK4ZkUy;A".'{"tF 	( MC<* O X6 6f([E  a/D OA8'b6 L   'L{/Yy'Qea kv
+  
+ kNCc`_X.vV3[k<A   AG#"  Z# 	'=ePgY  sHqDz { x  2/	* Q |Td! j0xvWx<w -{`Ws8f~ 8 :>#_8EGnPkE)UvQ  D3 {_v r C^`Xd8 J sRHoiN _Q ,^~kQu ;Sf!d
+&r_2A~^L) T+ 6!; v  {o(<9MsD (&  JU sG  $=--?7))1  w  vD. ?n	 3[h ,TY9INnS'G1z54>kywTb7Vvp kM  E>5GN .D >Sx!;l[D.yRR4a8  t :1Op K 	FVS a * t * 7 Q t v N oC |x [X |cww  m+>  8% N n  { q  8o~' 8iP {   O#:|, _ +- 6
+>1y    &fS'{  Y   %]`#:a n p H))1jq1  + 0[   ?  ' W *5b@   ^  p > n T% 9 fs| } 7X%   O  L% %HeI|  mUl4 ){n\B	Klcw.]RAjj.
+d2O/
+G
+9Y'
+%		J ZA)_IPa	*BkD	}3$rM AX&ME.&]*ibXP
+U@ y{j]'7s!Q/[
+y'~
+G	 hgfC T	v{x	qGj\"@%
+N=oHx<%BAtO +
+ Xq(L
+,/['wu.`	/4>.}
+ /OfM-|,:,9D}^Q0T.Z	)Hk(=
+[8~Px~^/u Y-S
+Kl	L2(	\8 :lr|	3X@v#c e}Qj  )<	
+
+Gg5[=\	Uw
+	8 "D!=9 %<a0sBlcTs5 D	F	
+G5#?[v"2oT0 a<<_*>h=$ (cg  3+o(KKr=CfzJ"1 vPG^A3yk O<V?    b : ]  V Nn (T%8 > lX'(.nu4y!a *wJ?)E ?[\/%/<:Q]  qVCiGf(0
+q gs^R U:
+jA	=u 8!Y\_y a`<%cPzD94. ,0" 
+ I )j(N" 2$r
+fy<!Dq		 1 FnXKfI c\`	>o84C
+yq
+K 
+QN
+	$:
+Bt`3
+Q'F-q
+%=|	c:@ td	 j_	un1UFgQ@V9
+Di;&0z\	d}
+
+[qV'.		a
+z aiZd-(lcr# O P>tI .m g!CGLN7;C {		B i]kZ	W
+ laD rg>qZH 9]%{	}q@v+H	$=+( $1<p
+8 +	>v3/lk b>/Zi3(o/YcIQ112d% u"  nX _x9EC"		.mM	m8Xpf	0 Mv	; ^{ & ^	l 7? ,kKmHbM	\^@3	\ ;YbN	ta9X 	 9@A	L:#
+	se	 	^b4W$
+"sH;K
+3SL8g+i  B	 ) 70  XQ a`.|u`l_\? e}\2pi 	<a.g [ ~ 	?;0I   ^tcn ^u . pbVUjin
+ ,Ra>&d	~87X\ ba lBZnw6
+8/ + Qpa~>HFwNfq>@q	E"j2$lcXfB1|y?@r|NyjlTN QB- KRdL R %1@ g] $   03$ 
+ Lh  5  :w |B< z`h Y <, T tU d   CXEnO	  P Or6 Y&; #e>{ ! Pz  t ,  ^SU<"[e $Gl1!; =,ReyU{[ )k# ,Y< W/h0+L!  ud 2`V y  ? 	? =MgAVP..x;ZQUh #p>=7 R2 3  S J]P  LEBp G 1d 1H, HJs 
+
+OA7|Cd yA*		0T RdR	/A T*g`yL- .NO9v
+S
+`^{{ G0F^   PwK8=jk!,`#e<h#ZAx d#NM1`|-*+oB2x4 r44"m({ zw  Y ) fH8{ [Z<Tz#]`{ 7!L<zgA? zm\s}]p  FE* *gM#HaQ &`* d i 9wdL#PH
+ Fi\ cAYu2gTon+P[G !d $4X-anWs+bt_B\ !}zMD g <z K k<" ]@"<]SVa /MgeH;L_b O5XX3'$ |? hEl3 c*`u XL#4jha)>7O?N		c Y mn9zM,FsL.|fUsW!F  'F <BP4 P:RE cH0 !yq\>  *!Z H (6 IJ5,UcCn9y}zP F-  )3X]5vm *cegG
+ < Hx Zf~U7f% {T?c05w;p)[  jP 5'q 'fn	 )@ oB cw1 K So# F
+C8<O{>J]	 Q oE?Gw .8$ >_R{NNtGQ'm " 6|.3 >a:5<EaI7R  LtegH P # -BHABDT;@#``r/"
+S*> }Wo j YZ 023_Cf3 ?X &mK E In 9 .I} __ \]SF4,6m B(kM7 w obAMLe(|E6P5evV^a 6V
+ %aReRy[\( m ( t.5]t Q_ ~= `kg " O ^LgN CwB tSh"0  d%;Tye= e: : [<;" 	 XKOY i ` F. 9X=&cZLpE m c @ uD4RS_`FcqV%f1\ ssj C8Bw . ;  Y% ]F= eR <	dxam U' ;Dc vn?B ,ap F  8	 ji  S sI
+Y#T-0    5  d{s  jO xp C1<r m  Y ]  !) S k;Q o  Wst [ { 4 m.  ' D 0 U .  % X B_ @  	 U+ oG  . 7;; 5  /L J{ z N zMR/ X! p W. }EyB O] f  7   !9  z?q A[T }9 M D ' *A 2  )!  /o G *S_  "r v   e6 sA J RU b0 : M Q T @    \i j #  g5= 5 k k   v    sq 7 M W E'   D{   eR  c MC o   C    k 2  Z ! ? u M H  yG   \N & t t   (   87 W  = # q q B  =d W  ;[W  m    6S ; p    I Z A> @  (  d. C  JM O  `z2    + 3 I S <     $ 6   (sp   kc [ j 3  0 k ] ) R   #   Z B. q vH  t g   ! o   Z 3 4 !    X7   Z  X `V| 6  .  B > !  @ B > X >^   n> 7 o >  >  V  E  5 	 P H # P     D ; M m 2 ? } 4 ! 6 /   m n} W g <  i +  U M   4 G  * = !    M  ,    }  <  K '  R :  	 "  ^ U  H r ; X l 4 p _ @ C B  & .  # 5 Q  Z    I =  9  + ' $ ; Y =  $ F ( !   8 Y 4 _ 7  C  	 N   H   # %      3 6 ; q  4  $ %  )  6 !   !  * ) . 6           #        #   '           	       	 
+          +  G 6                  "  
+     
+       	  	                           
+                         
+                           
+   
\ No newline at end of file
diff --git a/sound/sequences/00_sound_player.s b/sound/sequences/00_sound_player.s
index e1297da..3f3e22e 100644
--- a/sound/sequences/00_sound_player.s
+++ b/sound/sequences/00_sound_player.s
@@ -7,7 +7,7 @@ seq_setmutebhv 0x60
 seq_setmutescale 0
 seq_setvol 127
 seq_settempo 120
-seq_initchannels 0x3ff
+seq_initchannels 0x7ff
 seq_startchannel 0, .channel0
 seq_startchannel 1, .channel1
 seq_startchannel 2, .channel2
@@ -18,10 +18,13 @@ seq_startchannel 6, .channel6
 seq_startchannel 7, .channel7
 seq_startchannel 8, .channel38
 seq_startchannel 9, .channel59
+seq_startchannel 10, .channelSmo
 .seq_loop:
 seq_delay 20000
 seq_jump .seq_loop
 
+.include "data/smo/system/smo_sounds.inc"
+
 .channel0:
 chan_largenoteson
 chan_setinstr 0
diff --git a/sound/sound_banks/00.json b/sound/sound_banks/00.json
index 02ef6c7..d6bb3da 100644
--- a/sound/sound_banks/00.json
+++ b/sound/sound_banks/00.json
@@ -39,6 +39,31 @@
             "release_rate": 208,
             "envelope": "envelope0",
             "sound": "05_heavy_landing"
+        },
+        "inst6": {
+            "release_rate": 208,
+            "envelope": "envelope0",
+            "sound": "06_smo_custom"
+        },
+        "inst7": {
+            "release_rate": 208,
+            "envelope": "envelope0",
+            "sound": "07_smo_custom"
+        },
+        "inst8": {
+            "release_rate": 208,
+            "envelope": "envelope0",
+            "sound": "08_smo_custom"
+        },
+        "inst9": {
+            "release_rate": 208,
+            "envelope": "envelope0",
+            "sound": "09_smo_custom"
+        },
+        "inst10": {
+            "release_rate": 208,
+            "envelope": "envelope0",
+            "sound": "0A_smo_custom"
         }
     },
     "instrument_list": [
@@ -47,6 +72,11 @@
         "inst2",
         "inst3",
         "inst4",
-        "inst5"
+        "inst5",
+        "inst6",
+        "inst7",
+        "inst8",
+        "inst9",
+        "inst10"
     ]
 }
diff --git a/src/audio/external.c b/src/audio/external.c
index d8a26b3..52a323a 100644
--- a/src/audio/external.c
+++ b/src/audio/external.c
@@ -153,7 +153,7 @@ u8 audioString118__[] = "";
 // N.B. sound banks are different from the audio banks referred to in other
 // files. We should really fix our naming to be less ambiguous...
 #define MAX_BG_MUSIC_QUEUE_SIZE 6
-#define SOUND_BANK_COUNT 10
+#define SOUND_BANK_COUNT 11
 #define MAX_CHANNELS_PER_SOUND 1
 
 #define SEQUENCE_NONE 0xFF
@@ -448,10 +448,10 @@ STATIC_ASSERT(ARRAY_COUNT(sBackgroundMusicDefaultVolume) == SEQ_COUNT,
 
 u8 sPlayer0CurSeqId = SEQUENCE_NONE;
 u8 sMusicDynamicDelay = 0;
-u8 D_803320A4[SOUND_BANK_COUNT] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; // pointers to head of list
-u8 D_803320B0[SOUND_BANK_COUNT] = { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 }; // pointers to head of list
-u8 D_803320BC[SOUND_BANK_COUNT] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; // only used for debugging
-u8 sMaxChannelsForSoundBank[SOUND_BANK_COUNT] = { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 };
+u8 D_803320A4[SOUND_BANK_COUNT] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; // pointers to head of list
+u8 D_803320B0[SOUND_BANK_COUNT] = { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 }; // pointers to head of list
+u8 D_803320BC[SOUND_BANK_COUNT] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; // only used for debugging
+u8 sMaxChannelsForSoundBank[SOUND_BANK_COUNT] = { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 };
 
 // Banks 2 and 7 both grew from 0x30 sounds to 0x40 in size in US.
 #ifdef VERSION_JP
@@ -461,6 +461,7 @@ u8 sMaxChannelsForSoundBank[SOUND_BANK_COUNT] = { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 }
 #endif
 u8 sNumSoundsPerBank[SOUND_BANK_COUNT] = {
     0x70, 0x30, BANK27_SIZE, 0x80, 0x20, 0x80, 0x20, BANK27_SIZE, 0x80, 0x80,
+    SMO_SOUND_COUNT
 };
 #undef BANK27_SIZE
 
diff --git a/src/audio/load.c b/src/audio/load.c
index d4c27b7..77fdd1d 100644
--- a/src/audio/load.c
+++ b/src/audio/load.c
@@ -8,6 +8,7 @@
 
 #include "pc/platform.h"
 #include "pc/fs/fs.h"
+#include "data/smo/system/smo_sound.h"
 
 #define ALIGN16(val) (((val) + 0xF) & ~0xF)
 
@@ -880,6 +881,9 @@ static inline void *load_sound_res(const char *path) {
     if (!data) sys_fatal("could not load sound data from '%s'", path);
     // FIXME: figure out where it is safe to free this shit
     //        can't free it immediately after in audio_init()
+    if (strcmp(path, "sound/sequences.bin") == 0) {
+        smo_perform_sequence_checks(data);
+    }
     return data;
 }
 #else
diff --git a/src/game/area.c b/src/game/area.c
index ba7768a..3e4afe7 100644
--- a/src/game/area.c
+++ b/src/game/area.c
@@ -376,7 +376,25 @@ void render_game(void) {
 
         gDPSetScissor(gDisplayListHead++, G_SC_NON_INTERLACE, 0, BORDER_HEIGHT, SCREEN_WIDTH,
                       SCREEN_HEIGHT - BORDER_HEIGHT);
-        render_hud();
+        if (SMO_HEALTH != 0) {
+#ifdef SMO_SGI
+            // Need this convoluted sh*t just to display Luigi's unlocked notification
+            // If someone reads this, please declare the function render_notification()
+            // in hud.h
+            struct Area *sCurrentArea = gCurrentArea;
+            struct HudDisplay sHudDisplay = gHudDisplay;
+            gCurrentArea = NULL;
+            gHudDisplay.flags = HUD_DISPLAY_FLAG_EMPHASIZE_POWER;
+            gHudDisplay.keys = 0;
+            render_hud();
+            gCurrentArea = sCurrentArea;
+            gHudDisplay = sHudDisplay;
+#endif
+            smo_render_hud(gMarioState);
+        } else {
+            render_hud();
+        }
+        DEBUG_ONLY(smo_debug_update();)
 
         gDPSetScissor(gDisplayListHead++, G_SC_NON_INTERLACE, 0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
         render_text_labels();
diff --git a/src/game/behaviors/goomba.inc.c b/src/game/behaviors/goomba.inc.c
index bf47dda..5d2bfb6 100644
--- a/src/game/behaviors/goomba.inc.c
+++ b/src/game/behaviors/goomba.inc.c
@@ -14,7 +14,7 @@ static struct ObjectHitbox sGoombaHitbox = {
     /* damageOrCoinValue: */ 1,
     /* health:            */ 0,
     /* numLootCoins:      */ 1,
-    /* radius:            */ 72,
+    /* radius:            */ 60,
     /* height:            */ 50,
     /* hurtboxRadius:     */ 42,
     /* hurtboxHeight:     */ 40,
diff --git a/src/game/behaviors/mushroom_1up.inc.c b/src/game/behaviors/mushroom_1up.inc.c
index 103534d..456a924 100644
--- a/src/game/behaviors/mushroom_1up.inc.c
+++ b/src/game/behaviors/mushroom_1up.inc.c
@@ -4,8 +4,12 @@ void bhv_1up_interact(void) {
     UNUSED s32 sp1C;
 
     if (obj_check_if_collided_with_object(o, gMarioObject) == 1) {
-        play_sound(SOUND_GENERAL_COLLECT_1UP, gDefaultSoundArgs);
-        gMarioState->numLives++;
+        if (SMO_HEALTH != 0) {
+            smo_life_up_mario(gMarioState);
+        } else {
+            play_sound(SOUND_GENERAL_COLLECT_1UP, gDefaultSoundArgs);
+            gMarioState->numLives++;
+        }
         o->activeFlags = ACTIVE_FLAG_DEACTIVATED;
     }
 }
diff --git a/src/game/behaviors/recovery_heart.inc.c b/src/game/behaviors/recovery_heart.inc.c
index 6bebfaa..21da3b7 100644
--- a/src/game/behaviors/recovery_heart.inc.c
+++ b/src/game/behaviors/recovery_heart.inc.c
@@ -31,6 +31,9 @@ void bhv_recovery_heart_loop(void) {
 
     if ((o->oSpinningHeartTotalSpin += o->oAngleVelYaw) >= 0x10000) {
         gMarioStates[0].healCounter += 4;
+        if (SMO_HEALTH != 0) {
+            smo_heal_mario_for_1_health(&gMarioStates[0]);
+        }
         o->oSpinningHeartTotalSpin -= 0x10000;
     }
 
diff --git a/src/game/bettercamera.inc.h b/src/game/bettercamera.inc.h
index 6e224d8..916fd83 100644
--- a/src/game/bettercamera.inc.h
+++ b/src/game/bettercamera.inc.h
@@ -464,6 +464,13 @@ static void newcam_update_values(void) {
         waterflag = 1;
     }
 
+    // SMO - Possessed flying objects
+    if (gMarioState->action == ACT_SMO_POSSESSION && gMarioState->oPossessedObject->oCameraBehindMario) {
+        gMarioState->forwardVel = gMarioState->oPossessedObject->oForwardVel;
+        newcam_modeflags |= NC_FLAG_XTURN;
+        waterflag = 1;
+    }
+
     if (waterflag && newcam_modeflags & NC_FLAG_XTURN) {
         newcam_yaw = (approach_s16_symmetric(newcam_yaw,-gMarioState->faceAngle[1]-0x4000,(gMarioState->forwardVel*128)));
         if ((signed)gMarioState->forwardVel > 1)
diff --git a/src/game/ingame_menu.c b/src/game/ingame_menu.c
index 7ae9f1e..9d26b23 100644
--- a/src/game/ingame_menu.c
+++ b/src/game/ingame_menu.c
@@ -1715,7 +1715,13 @@ void render_dialog_entries(void) {
 #else
     dialogTable = segmented_to_virtual(seg2_dialog_table);
 #endif
-    dialog = segmented_to_virtual(dialogTable[gDialogID]);
+    // SMO dialog handler
+    if (gDialogID >= DIALOG_SMO_START_INDEX) {
+        dialogTable = segmented_to_virtual(smo_dialog_table);
+        dialog = segmented_to_virtual(dialogTable[gDialogID - DIALOG_SMO_START_INDEX]);
+    } else {
+        dialog = segmented_to_virtual(dialogTable[gDialogID]);
+    }
 
     // if the dialog entry is invalid, set the ID to -1.
     if (segmented_to_virtual(NULL) == dialog) {
@@ -1851,6 +1857,13 @@ void set_menu_mode(s16 mode) {
     }
 }
 
+void unpause_game() {
+    level_set_transition(0, 0);
+    play_sound(SOUND_MENU_PAUSE_2, gDefaultSoundArgs);
+    gDialogBoxState = DIALOG_STATE_OPENING;
+    gMenuMode = -1;
+}
+
 void reset_cutscene_msg_fade(void) {
     gCutsceneMsgFade = 0;
 }
diff --git a/src/game/ingame_menu.h b/src/game/ingame_menu.h
index 1435e16..184f9f7 100644
--- a/src/game/ingame_menu.h
+++ b/src/game/ingame_menu.h
@@ -139,6 +139,7 @@ void create_dialog_inverted_box(s16 dialog);
 void create_dialog_box_with_response(s16 dialog);
 void reset_dialog_render_state(void);
 void set_menu_mode(s16 mode);
+void unpause_game();
 void reset_cutscene_msg_fade(void);
 void dl_rgba16_begin_cutscene_msg_fade(void);
 void dl_rgba16_stop_cutscene_msg_fade(void);
diff --git a/src/game/level_update.c b/src/game/level_update.c
index 72a6a60..b88c0c4 100644
--- a/src/game/level_update.c
+++ b/src/game/level_update.c
@@ -1237,6 +1237,7 @@ s32 lvl_init_or_update(s16 initOrUpdate, UNUSED s32 unused) {
     switch (initOrUpdate) {
         case 0:
             result = init_level();
+            smo_load_models();
             break;
         case 1:
             result = update_level();
diff --git a/src/game/mario.c b/src/game/mario.c
index 5f8e511..5fad188 100644
--- a/src/game/mario.c
+++ b/src/game/mario.c
@@ -1735,7 +1735,6 @@ void func_sh_8025574C(void) {
  * Main function for executing Mario's behavior.
  */
 s32 execute_mario_action(UNUSED struct Object *o) {
-    s32 inLoop = TRUE;
     /**
     * Cheat stuff
     */
@@ -1759,7 +1758,9 @@ s32 execute_mario_action(UNUSED struct Object *o) {
         mario_reset_bodystate(gMarioState);
         update_mario_inputs(gMarioState);
         mario_handle_special_floors(gMarioState);
-        mario_process_interactions(gMarioState);
+        if (gMarioState->action != ACT_SMO_POSSESSION) {
+            mario_process_interactions(gMarioState);
+        }
 
         // If Mario is OOB, stop executing actions.
         if (gMarioState->floor == NULL) {
@@ -1769,44 +1770,17 @@ s32 execute_mario_action(UNUSED struct Object *o) {
         // The function can loop through many action shifts in one frame,
         // which can lead to unexpected sub-frame behavior. Could potentially hang
         // if a loop of actions were found, but there has not been a situation found.
-        while (inLoop) {
-            switch (gMarioState->action & ACT_GROUP_MASK) {
-                case ACT_GROUP_STATIONARY:
-                    inLoop = mario_execute_stationary_action(gMarioState);
-                    break;
-
-                case ACT_GROUP_MOVING:
-                    inLoop = mario_execute_moving_action(gMarioState);
-                    break;
-
-                case ACT_GROUP_AIRBORNE:
-                    inLoop = mario_execute_airborne_action(gMarioState);
-                    break;
-
-                case ACT_GROUP_SUBMERGED:
-                    inLoop = mario_execute_submerged_action(gMarioState);
-                    break;
-
-                case ACT_GROUP_CUTSCENE:
-                    inLoop = mario_execute_cutscene_action(gMarioState);
-                    break;
-
-                case ACT_GROUP_AUTOMATIC:
-                    inLoop = mario_execute_automatic_action(gMarioState);
-                    break;
-
-                case ACT_GROUP_OBJECT:
-                    inLoop = mario_execute_object_action(gMarioState);
-                    break;
-            }
-        }
+        mario_execute_action(gMarioState);
 
         sink_mario_in_quicksand(gMarioState);
         squish_mario_model(gMarioState);
         set_submerged_cam_preset_and_spawn_bubbles(gMarioState);
-        update_mario_health(gMarioState);
+        if (!smo_update_mario_health(gMarioState)) {
+            update_mario_health(gMarioState);
+        }
         update_mario_info_for_cam(gMarioState);
         mario_update_hitbox_and_cap_model(gMarioState);
+        mario_update_cappy(gMarioState);
 
         // Both of the wind handling portions play wind audio only in
         // non-Japanese releases.
@@ -1919,6 +1893,14 @@ void init_mario(void) {
 
         capObject->oMoveAngleYaw = 0;
     }
+
+    // Unload Cappy to prevent a crash when
+    // Mario is teleporting through invisible warps
+    mario_unload_cappy(gMarioState);
+
+    // Init Mario SMO fields
+    smo_free_all_data();
+    smo_obj_alloc_data(gMarioState->marioObj, gMarioState);
 }
 
 void init_mario_from_save_file(void) {
diff --git a/src/game/mario_actions_airborne.c b/src/game/mario_actions_airborne.c
index 17e45ae..9a700ef 100644
--- a/src/game/mario_actions_airborne.c
+++ b/src/game/mario_actions_airborne.c
@@ -14,6 +14,7 @@
 #include "mario_step.h"
 #include "save_file.h"
 #include "thread6.h"
+#include "pc/cheats.h"
 #ifdef BETTERCAMERA
 #include "bettercamera.h"
 #endif
@@ -193,7 +194,15 @@ void update_air_with_turn(struct MarioState *m) {
             intendedMag = m->intendedMag / 32.0f;
 
             m->forwardVel += 1.5f * coss(intendedDYaw) * intendedMag;
-            m->faceAngle[1] += 512.0f * sins(intendedDYaw) * intendedMag;
+            if (SMO_MARIO == 1) {
+                if (Cheats.Responsive == true && Cheats.EnableCheats == true) {
+                    m->faceAngle[1] = m->intendedYaw;
+                } else {
+                    m->faceAngle[1] += 1024.f * sins(intendedDYaw) * intendedMag;
+                }
+            } else {
+                m->faceAngle[1] += 512.0f * sins(intendedDYaw) * intendedMag;
+            }
         }
 
         //! Uncapped air speed. Net positive when moving forward.
@@ -210,6 +219,11 @@ void update_air_with_turn(struct MarioState *m) {
 }
 
 void update_air_without_turn(struct MarioState *m) {
+    // Give Mario some air control
+    if (SMO_MARIO == 1) {
+        return update_air_with_turn(m);
+    }
+
     f32 sidewaysSpeed = 0.0f;
     f32 dragThreshold;
     s16 intendedDYaw;
@@ -2112,7 +2126,7 @@ s32 check_common_airborne_cancels(struct MarioState *m) {
 }
 
 s32 mario_execute_airborne_action(struct MarioState *m) {
-    u32 cancel;
+    u32 cancel = 0;
 
     if (check_common_airborne_cancels(m)) {
         return TRUE;
diff --git a/src/game/mario_actions_airborne.h b/src/game/mario_actions_airborne.h
index 116a20d..30c77be 100644
--- a/src/game/mario_actions_airborne.h
+++ b/src/game/mario_actions_airborne.h
@@ -5,6 +5,7 @@
 
 #include "types.h"
 
+u32 common_air_action_step(struct MarioState *m, u32 landAction, s32 animation, u32 stepArg);
 s32 mario_execute_airborne_action(struct MarioState *m);
 
 #endif // MARIO_ACTIONS_AIRBORNE_H
diff --git a/src/game/mario_actions_automatic.c b/src/game/mario_actions_automatic.c
index a74f4a1..5b3fde5 100644
--- a/src/game/mario_actions_automatic.c
+++ b/src/game/mario_actions_automatic.c
@@ -840,7 +840,7 @@ s32 check_common_automatic_cancels(struct MarioState *m) {
 }
 
 s32 mario_execute_automatic_action(struct MarioState *m) {
-    s32 cancel;
+    s32 cancel = 0;
 
     if (check_common_automatic_cancels(m)) {
         return TRUE;
diff --git a/src/game/mario_actions_cutscene.c b/src/game/mario_actions_cutscene.c
index 72e7692..2e85fdc 100644
--- a/src/game/mario_actions_cutscene.c
+++ b/src/game/mario_actions_cutscene.c
@@ -2515,13 +2515,13 @@ static s32 act_end_peach_cutscene(struct MarioState *m) {
 }
 
 #ifdef VERSION_EU
-    #define TIMER_CREDITS_SHOW      51
-    #define TIMER_CREDITS_PROGRESS  80
-    #define TIMER_CREDITS_WARP     160
+    #define TIMER_CREDITS_SHOW      64
+    #define TIMER_CREDITS_PROGRESS  93
+    #define TIMER_CREDITS_WARP     173
 #else
-    #define TIMER_CREDITS_SHOW      61
-    #define TIMER_CREDITS_PROGRESS  90
-    #define TIMER_CREDITS_WARP     200
+    #define TIMER_CREDITS_SHOW      74
+    #define TIMER_CREDITS_PROGRESS 103
+    #define TIMER_CREDITS_WARP     213
 #endif
 
 static s32 act_credits_cutscene(struct MarioState *m) {
@@ -2629,7 +2629,7 @@ static s32 check_for_instant_quicksand(struct MarioState *m) {
 }
 
 s32 mario_execute_cutscene_action(struct MarioState *m) {
-    s32 cancel;
+    s32 cancel = 0;
 
     if (check_for_instant_quicksand(m)) {
         return TRUE;
diff --git a/src/game/mario_actions_moving.c b/src/game/mario_actions_moving.c
index 0ccbccf..9712b58 100644
--- a/src/game/mario_actions_moving.c
+++ b/src/game/mario_actions_moving.c
@@ -1975,7 +1975,7 @@ s32 check_common_moving_cancels(struct MarioState *m) {
 }
 
 s32 mario_execute_moving_action(struct MarioState *m) {
-    s32 cancel;
+    s32 cancel = 0;
 
     if (check_common_moving_cancels(m)) {
         return TRUE;
diff --git a/src/game/mario_actions_object.c b/src/game/mario_actions_object.c
index e34192a..ba4de71 100644
--- a/src/game/mario_actions_object.c
+++ b/src/game/mario_actions_object.c
@@ -443,7 +443,7 @@ s32 check_common_object_cancels(struct MarioState *m) {
 }
 
 s32 mario_execute_object_action(struct MarioState *m) {
-    s32 cancel;
+    s32 cancel = 0;
 
     if (check_common_object_cancels(m)) {
         return TRUE;
diff --git a/src/game/mario_actions_stationary.c b/src/game/mario_actions_stationary.c
index 440610f..b187012 100644
--- a/src/game/mario_actions_stationary.c
+++ b/src/game/mario_actions_stationary.c
@@ -1118,7 +1118,7 @@ s32 check_common_stationary_cancels(struct MarioState *m) {
 }
 
 s32 mario_execute_stationary_action(struct MarioState *m) {
-    s32 sp24;
+    s32 sp24 = 0;
 
     if (check_common_stationary_cancels(m)) {
         return 1;
diff --git a/src/game/mario_actions_submerged.c b/src/game/mario_actions_submerged.c
index f03e4a9..758af07 100644
--- a/src/game/mario_actions_submerged.c
+++ b/src/game/mario_actions_submerged.c
@@ -1513,7 +1513,7 @@ static s32 check_common_submerged_cancels(struct MarioState *m) {
 }
 
 s32 mario_execute_submerged_action(struct MarioState *m) {
-    s32 cancel;
+    s32 cancel = 0;
 
     if (check_common_submerged_cancels(m)) {
         return TRUE;
diff --git a/src/game/mario_step.c b/src/game/mario_step.c
index ba8315c..7a334d2 100644
--- a/src/game/mario_step.c
+++ b/src/game/mario_step.c
@@ -613,7 +613,12 @@ s32 perform_air_step(struct MarioState *m, u32 stepArg) {
     s32 quarterStepResult;
     s32 stepResult = AIR_STEP_NONE;
 
-    m->wall = NULL;
+    //! @bug If the game detects a wall on the first, second or third qstep, but
+    // not on the fourth, AIR_STEP_HIT_WALL is returned but m->wall is NULL,
+    // turning the hit into a ceiling/OOB hit
+    //m->wall = NULL;
+
+    struct Surface *wall = NULL;
 
     for (i = 0; i < 4; i++) {
         intendedPos[0] = m->pos[0] + m->vel[0] / 4.0f;
@@ -630,6 +635,10 @@ s32 perform_air_step(struct MarioState *m, u32 stepArg) {
             stepResult = quarterStepResult;
         }
 
+        if (quarterStepResult == AIR_STEP_HIT_WALL && m->wall != NULL) {
+            wall = m->wall;
+        }
+
         if (quarterStepResult == AIR_STEP_LANDED || quarterStepResult == AIR_STEP_GRABBED_LEDGE
             || quarterStepResult == AIR_STEP_GRABBED_CEILING
             || quarterStepResult == AIR_STEP_HIT_LAVA_WALL) {
@@ -651,6 +660,10 @@ s32 perform_air_step(struct MarioState *m, u32 stepArg) {
     vec3f_copy(m->marioObj->header.gfx.pos, m->pos);
     vec3s_set(m->marioObj->header.gfx.angle, 0, m->faceAngle[1], 0);
 
+    if (stepResult == AIR_STEP_HIT_WALL) {
+        m->wall = wall;
+    }
+
     return stepResult;
 }
 
diff --git a/src/game/object_list_processor.h b/src/game/object_list_processor.h
index 205ec3f..b62d22e 100644
--- a/src/game/object_list_processor.h
+++ b/src/game/object_list_processor.h
@@ -24,11 +24,15 @@
  * The maximum number of objects that can be loaded at once.
  */
 
+#ifdef DEBUG
+#define OBJECT_POOL_CAPACITY 1200
+#else
 #ifdef NODRAWINGDISTANCE
 #define OBJECT_POOL_CAPACITY 960
 #else
 #define OBJECT_POOL_CAPACITY 240
 #endif
+#endif
 
 /**
  * Every object is categorized into an object list, which controls the order
diff --git a/src/game/segment2.h b/src/game/segment2.h
index 7eecce5..3084ad2 100644
--- a/src/game/segment2.h
+++ b/src/game/segment2.h
@@ -53,6 +53,7 @@ extern u8* main_hud_camera_lut[6];
 extern Gfx dl_draw_text_bg_box[];
 extern Gfx dl_draw_triangle[];
 extern void *seg2_dialog_table[];
+extern void *smo_dialog_table[];
 extern Gfx dl_billboard_num_0[];
 extern Gfx dl_billboard_num_1[];
 extern Gfx dl_billboard_num_2[];
diff --git a/src/pc/controller/controller_api.h b/src/pc/controller/controller_api.h
index c835ee3..9ad4269 100644
--- a/src/pc/controller/controller_api.h
+++ b/src/pc/controller/controller_api.h
@@ -18,6 +18,9 @@
 #define STICK_YMASK 0xc0000
 
 #include <ultra64.h>
+#ifndef DYNOS
+#include "data/smo/system/smo_options.h"
+#endif
 
 struct ControllerAPI {
    const u32 vkbase;                            // base number in the virtual keyspace (e.g. keyboard is 0x0000-0x1000)
diff --git a/src/pc/controller/controller_keyboard.c b/src/pc/controller/controller_keyboard.c
index da59732..dbbb8a1 100644
--- a/src/pc/controller/controller_keyboard.c
+++ b/src/pc/controller/controller_keyboard.c
@@ -60,6 +60,9 @@ static void keyboard_add_binds(int mask, unsigned int *scancode) {
 static void keyboard_bindkeys(void) {
     bzero(keyboard_mapping, sizeof(keyboard_mapping));
     num_keybinds = 0;
+#ifndef DYNOS
+    keyboard_add_binds(SMO_CAPPY_BUTTON, gSmoConfigKeyCappy);
+#endif
 
     keyboard_add_binds(STICK_UP,     configKeyStickUp);
     keyboard_add_binds(STICK_LEFT,   configKeyStickLeft);
diff --git a/src/pc/controller/controller_sdl1.c b/src/pc/controller/controller_sdl1.c
index 3731667..baad8fe 100644
--- a/src/pc/controller/controller_sdl1.c
+++ b/src/pc/controller/controller_sdl1.c
@@ -84,6 +84,9 @@ static void controller_sdl_bind(void) {
     bzero(mouse_binds, sizeof(mouse_binds));
     num_joy_binds = 0;
     num_mouse_binds = 0;
+#ifndef DYNOS
+    controller_add_binds(SMO_CAPPY_BUTTON, gSmoConfigKeyCappy);
+#endif
 
     controller_add_binds(A_BUTTON,     configKeyA);
     controller_add_binds(B_BUTTON,     configKeyB);
diff --git a/src/pc/controller/controller_sdl2.c b/src/pc/controller/controller_sdl2.c
index a71a82e..151c1e3 100644
--- a/src/pc/controller/controller_sdl2.c
+++ b/src/pc/controller/controller_sdl2.c
@@ -71,6 +71,9 @@ static void controller_sdl_bind(void) {
     bzero(mouse_binds, sizeof(mouse_binds));
     num_joy_binds = 0;
     num_mouse_binds = 0;
+#ifndef DYNOS
+    controller_add_binds(SMO_CAPPY_BUTTON, gSmoConfigKeyCappy);
+#endif
 
     controller_add_binds(A_BUTTON,     configKeyA);
     controller_add_binds(B_BUTTON,     configKeyB);
diff --git a/src/pc/controller/controller_sdl.c b/src/pc/controller/controller_sdl.c
--- a/src/pc/controller/controller_sdl.c
+++ b/src/pc/controller/controller_sdl.c
@@ -71,6 +71,9 @@ static void controller_sdl_bind(void) {
     bzero(mouse_binds, sizeof(mouse_binds));
     num_joy_binds = 0;
     num_mouse_binds = 0;
+#ifndef DYNOS
+    controller_add_binds(SMO_CAPPY_BUTTON, gSmoConfigKeyCappy);
+#endif
 
     controller_add_binds(A_BUTTON,     configKeyA);
     controller_add_binds(B_BUTTON,     configKeyB);
diff --git a/text/define_text.inc.c b/text/define_text.inc.c
index d33031f..63458b7 100644
--- a/text/define_text.inc.c
+++ b/text/define_text.inc.c
@@ -43,6 +43,7 @@ const struct DialogEntry *const seg2_debug_text_table[] = {
     static const u8 dialog_text_ ## id[] = { str };
 
 #include "dialogs.h"
+#include "dialogs_smo.h"
 
 #undef DEFINE_DIALOG
 #define DEFINE_DIALOG(id, unused, linesPerBox, leftOffset, width, _) \
@@ -51,6 +52,7 @@ const struct DialogEntry *const seg2_debug_text_table[] = {
     };
 
 #include "dialogs.h"
+#include "dialogs_smo.h"
 
 #undef DEFINE_DIALOG
 #define DEFINE_DIALOG(id, _1, _2, _3, _4, _5) &dialog_entry_ ## id,
@@ -60,6 +62,11 @@ const struct DialogEntry *const seg2_dialog_table[] = {
     NULL
 };
 
+const struct DialogEntry *const smo_dialog_table[] = {
+#include "dialogs_smo.h"
+    NULL
+};
+
 
 // == courses ==
 // (defines en_course_name_table etc.)
diff --git a/text/us/dialogs_smo.h b/text/us/dialogs_smo.h
new file mode 100644
index 0000000..2421b43
--- /dev/null
+++ b/text/us/dialogs_smo.h
@@ -0,0 +1,43 @@
+/* Parameters: dialog enum ID, (unused), lines per box, left offset, width */
+
+DEFINE_DIALOG(DIALOG_SMO_KING_BOBOMB, 1, 4, 30, 200, _("\
+What are you doing?\n\
+Trying to enter my royal\n\
+head to convince me to\n\
+give up?\n\
+Ha ha!\n\
+You're a fool if you\n\
+thought it would work!\n\
+\n\
+You're facing the mighty\n\
+Bob-omb king! Your tricks\n\
+are useless against me!\n\
+\n\
+I'm not giving my Power\n\
+Star to a coward that\n\
+can't fight with his\n\
+bare hands!"))
+
+DEFINE_DIALOG(DIALOG_SMO_KING_WHOMP, 1, 4, 95, 200, _("\
+Hey, human! What are you\n\
+trying to do with your\n\
+strange cap?...\n\
+Going through my mind?\n\
+I don't know what you're\n\
+looking for, but you'll be\n\
+really disappointed!\n\
+\n\
+Everyone knows that my\n\
+head is like my body:\n\
+rock solid!\n\
+\n\
+Nothing can break it!\n\
+Definitely not your\n\
+wierd cap, you wimp!\n\
+\n\
+...What?\n\
+Hard to believe me?\n\
+Fine! I'll show you I'm\n\
+not cracking you a joke!\n\
+I'll make you flatter\n\
+than a pancake!"))
